# План пофазового проигрывания (Qt Viewer)

Цель: убрать «скачок» состояния и сделать пофазовое проигрывание, опираясь на уже имеющиеся источники событий.

## Что уже есть в Viewer (источники событий)

1) **model_events** (структурированные события модели).
   - В Viewer уже есть фильтрация событий и построение фаз/юнитов для логов модели.
   - Это позволяет собирать устойчивую «ленту» действий, сгруппированную по battle_round и phase.

2) **log_tail** (текстовый лог).
   - Из логов уже парсятся ключевые строки движения ("Позиция до/после") и фазовые заголовки.
   - В логах есть отчёты стрельбы/действий, которые можно синхронизировать с FX.

3) **FX-парсер**
   - Уже реагирует на лог-строки (стрельба), значит можно завязать запуск FX на события фазы.

## Почему сейчас виден «скачок»

Состояние применяется атомарно: `state.json` целиком загружается и сразу отображается, без промежуточных шагов и визуального «проигрывания» фазы.

## Рекомендуемая архитектура (лучший вариант)

**Phase Timeline Player (A)** — надёжный вариант, потому что:
- Использует два уже существующих источника событий (model_events + log_tail).
- Не требует изменения движка.
- Позволяет пофазово и покадрово воспроизводить ход модели на стороне Viewer.

### Ключевые идеи

1) **Единая очередь событий (Timeline Queue)**
   - Структура: `PhaseStart → UnitStart → Action/Move/Shoot → PhaseEnd`.
   - Источники:
     - model_events → точная фаза, battle_round, unit_id.
     - log_tail → fallback (фаза/стрельба/«Позиция до/после») для ситуаций, где model_events неполные.

2) **Синхронизация с UI/рендером**
   - Очередь событий хранится в Viewer и проигрывается через `QTimer` или `QStateMachine`.
   - Следующий шаг запускается только после подтверждения завершения анимации (движение/FX).

3) **Дедуп и защита от дублей**
   - Использовать `event_id` (если есть) или hash-ключ (phase + unit_id + msg + ts) для отсечения повторов.
   - Хранить `last_seen_idx` для log_tail и `last_event_ts` для model_events.

4) **Согласование state vs events**
   - Состояние применяется **между фазами**, а не «внутри».
   - Внутри фазы — только интерполяция между координатами из событий.
   - Если событий не хватает, fallback: быстрая синхронизация состояния перед стартом следующей фазы.

## Минимальный MVP (без изменений движка)

1) **Фазовые заголовки + пауза**
   - При детекте `PhaseStart` показывать титр/лог и ставить паузу (500–1000 мс).

2) **Автофокус/камера**
   - На `UnitStart` фокус на юнита (центр камеры).

3) **FX по стрельбе**
   - Уже есть парсер — просто синхронизировать запуск FX с событиями фазы стрельбы.

4) **Режим «Next Event»**
   - Enter → следующий элемент очереди (пошаговый режим).

## Следующие этапы

1) **Анимация движения**
   - Интерполяция между `Позиция до` и `Позиция после`.

2) **Контроль скорости**
   - Ползунок скорости: 0.5x / 1x / 2x.

3) **История событий**
   - Хранить последние N событий для повторного проигрывания «шаг назад».

## Риски и обходные пути

- **Если model_events неполные** → fallback на log_tail.
- **Если log_tail сбрасывается** → читать свежие строки и пересобирать очередь с дедупом.
- **Если state внезапно «скачет»** → форс-синхронизация на границе фаз.

## Что делать дальше (пошагово)

1) В Viewer добавить слой `TimelinePlayer`.
2) Подключить его к существующим источникам `model_events` и `log_tail`.
3) Реализовать MVP-очередь: PhaseStart → UnitStart → Action.
4) Добавить фазы движения/стрельбы/чарджа/боя с базовыми паузами.
5) Добавить анимацию движения и FX.

---

Итог: **Phase Timeline Player (A)** — самый надёжный, потому что он использует текущие источники событий и не требует правок движка.
