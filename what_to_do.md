Ниже — рекомендуемая последовательность внедрения, исходя из текущей архитектуры Viewer (PySide6 + OpenGLBoardWidget) и того, где проще всего «раскрывать» функционал без больших переделок. Порядок сгруппирован так, чтобы сначала убрать визуальные артефакты и стабилизировать карту, затем добавить анимации/сценарии, и только потом — косметику и эффекты. Ссылаюсь на текущий рендер и UI‑структуру Viewer для контекста.
Рекомендуемая последовательность работ
1) Стабилизация сетки и камеры (базовая визуальная основа) — СДЕЛАНО

Почему первой: любые последующие анимации и эффекты будут хуже восприниматься, если сетка «плавает» и камера дергается.
Где: OpenGLBoardWidget в viewer/opengl_view.py — весь рендер и трансформации карты проходят через _view_transform(), paintGL(), wheelEvent() и кеш сетки _ensure_grid_cache()

    Сетка 1x1, стабильная при зуме/панораме.

    Плавный зум/панорама (ease‑in/out, минимизация рывков).

    Snap к клетке при наведении (логика на уровне координат self._cursor_world).

2) Плавное перемещение юнитов (анимации движения) — СДЕЛАНО

Почему второй: это базовый UX‑эффект, который используется дальше в фазах ИИ.
Где: позиция юнитов задаётся в update_state() и рендерится в paintGL() — именно тут стоит добавить интерполяцию между предыдущим и текущим состояниями.

    Интерполяция позиций по времени.

    Хук на будущий звук шага (например, on_unit_move_start()).

3) Демонстрация хода ИИ по фазам (сценарий/тайминг)

Почему третьей: требует готового плавного движения.
Где: управляется логикой Viewer в viewer/app.py (обновление состояния, фаза, активный юнит). Можно вставить планировщик/таймлайн действий здесь, а отображение — в OpenGLBoardWidget.

    Пошаговое выделение юнитов (command/move/shoot/charge/fight).

    Управление шагами через Enter.

4) Слои UI на карте (movement/shooting/objectives)

Почему сейчас: когда базовая логика и анимации готовы, можно упорядочить визуал.
Где: уже есть подсветки движения и целей (_move_highlights, _target_highlights, _objectives). Это хорошая база для разделения на слои/рендер‑порядок.
5) Логи и UX (структура вкладок + ключевые события)

Поему после визуала: чтобы синхронизировать события с фазами и анимациями.
Где: вкладки логов формируются в viewer/app.py через _log_tab_defs и UI‑конструкции лог‑виджета.

    Заменить вкладки на «Все ходы игрока / Все ходы модели».

    Добавить эмоджи/иконки в строки.

    Секция «ключевые события» отдельно.

6) «Кинематографический» визуал (glow/halo/пульсация)

Почему позже: эффекты должны опираться на стабильную базу.
Где: paintGL() — все эффекты можно добавить поверх существующего рендера (подсветки, градиенты, пульсации).
7) Эффекты боя (вспышка, трассеры)

Почему в конце: требует готовых фаз и точек синхронизации с событиями.
Где: логика фаз в viewer/app.py, рендер — paintGL().
8) Hover‑tooltip для юнитов

Почему последним: зависит от корректных координат и стабильного наведения.
Где: обработка курсора mouseMoveEvent() + данные из _state и _unit_by_key.
Итоговая логика очередности (коротко)

    Сетка + камера

    Плавные движения юнитов

    Пошаговые фазы ИИ

    Слои рендера

    Логи/UX

    Кинематографический визуал

    Эффекты боя

    Tooltip
