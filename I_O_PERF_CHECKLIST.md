# Потенциальные I/O-проблемы (приоритетно)

Чек-лист для поэтапной оптимизации I/O без изменения боевой логики.

## P0 — самое критичное (влияет на FPS GUI и скорость train)

✅ P0 выполнен.

- [x] **Оптимизировать чтение `response.txt` в state export**  
  Сейчас берутся все строки файла и только потом последние 30.  
  Что сделать: tail-чтение с конца файла (seek + чанки) или ring-buffer в памяти.

- [x] **Снизить объём `model_events` в `state.json`**  
  Сейчас в snapshot попадает до 2000 событий на каждый экспорт.  
  Что сделать: уменьшить лимит (например 200–500), сделать отдельный env-параметр, либо передавать дельту.

- [x] **Ограничить частоту тяжёлых state flush в GUI**  
  Атомарная запись + `fsync` корректны, но дорогие.  
  Что сделать: для GUI настроить разумный `STATE_FLUSH_MIN_INTERVAL_MS` (например 150–300 мс), чтобы уменьшить пики I/O.

## P1 — высокий приоритет

✅ P1 выполнен.

- [x] **Убрать частые open/write/close для `gui/response.txt`**  
  Сейчас лог в GUI пишется синхронно на каждое сообщение.
  Что сделать: буферизованный writer (очередь + отдельный поток) с flush пачками.

- [x] **Снизить нагрузку от train-логирования в файл**  
  `TRAIN_LOG_TO_FILE=1` по умолчанию, запись идёт часто.
  Что сделать: для долгих прогонов использовать `TRAIN_LOG_TO_FILE=0` или батчевую запись.

- [x] **Проверить частоту checkpoint-save**  
  Частый `torch.save` с optimizer может заметно тормозить.
  Что сделать: подобрать `SAVE_EVERY` под диск/задачу (реже при длительном train).

## P2 — средний приоритет

- [x] **Разделить “лёгкий” и “полный” state payload**  
  Лёгкий — для частых GUI-обновлений (позиции/HP/фаза), полный — реже (логи/события).

- [x] **Сделать профилирование I/O по категориям**  
  Нужны счётчики времени: state export, log append, checkpoint save, metrics save.

- [ ] **Проверить финальный хвост I/O после тренировки**  
  В конце тренировки подряд пишутся PNG/JSON/checkpoint/pickle.
  Что сделать: опционально вынести тяжёлые финальные артефакты под флаги.

## Как проверять эффект (быстрый протокол)

- [ ] Зафиксировать baseline: `steps/sec`, `env_step_ms`, `log_ms`, время эпохи.
- [ ] Включать улучшения по одному пункту.
- [ ] Для каждого пункта фиксировать дельту в `%` и решать, оставлять ли изменение.
- [ ] Проверять отдельно сценарии:
  - Train (без GUI)
  - Play/GUI (с визуализацией)
  - Windows (основной таргет)

## Критерий готовности

- [ ] Train: нет деградации скорости из-за state/log I/O.
- [ ] GUI: нет падений на чтении state, нет видимых фризов из-за частых flush.
- [ ] Логи остаются понятными и полезными для отладки.
