diff --git a/gym_mod/gym_mod/engine/deployment.py b/gym_mod/gym_mod/engine/deployment.py
index a6040eabb4fbfd2beba394bb3b20cd6e4395a2ff..50aaa0abc1e501225f560f0cc89164e0f3f424b4 100644
--- a/gym_mod/gym_mod/engine/deployment.py
+++ b/gym_mod/gym_mod/engine/deployment.py
@@ -1,31 +1,33 @@
 """Deployment helpers for the Only War mission."""
 from __future__ import annotations
 
 import random
 from typing import Iterable, List, Optional, Sequence, Tuple
 
+from gym_mod.engine.logging_utils import format_unit
+
 DEPLOY_DEPTH_RATIO = 0.25
 
 
 def deploy_depth(b_hei: int) -> int:
     return max(1, int(b_hei * DEPLOY_DEPTH_RATIO))
 
 
 def _in_bounds(coord: Sequence[int], b_len: int, b_hei: int) -> bool:
     x, y = int(coord[0]), int(coord[1])
     return 0 <= x < b_len and 0 <= y < b_hei
 
 
 def is_in_deploy_zone(side: str, coord: Sequence[int], b_len: int, b_hei: int) -> bool:
     """
     Check if coord is wholly within the deployment zone for the given side.
     Coordinates are treated as [x, y] with x in [0, b_len), y in [0, b_hei).
     """
     if side not in ("model", "enemy"):
         raise ValueError(f"Unknown side: {side}")
     if not _in_bounds(coord, b_len, b_hei):
         return False
     _, y = int(coord[0]), int(coord[1])
     depth = deploy_depth(b_hei)
     if side == "enemy":
         return y >= b_hei - depth
@@ -38,78 +40,86 @@ def _zone_coords(side: str, b_len: int, b_hei: int) -> List[Tuple[int, int]]:
     if side == "enemy":
         y_min = max(0, b_hei - depth)
         y_max = b_hei - 1
     else:
         y_min = 0
         y_max = max(0, depth - 1)
     for x in range(b_len):
         for y in range(y_min, y_max + 1):
             coords.append((x, y))
     return coords
 
 
 def get_random_free_deploy_coord(
     side: str,
     b_len: int,
     b_hei: int,
     occupied: Iterable[Tuple[int, int]],
 ) -> Tuple[int, int]:
     occupied_set = set((int(x), int(y)) for x, y in occupied)
     choices = [c for c in _zone_coords(side, b_len, b_hei) if c not in occupied_set]
     if not choices:
         raise RuntimeError(f"No free deployment space for side={side}")
     return random.choice(choices)
 
 
-def _log_deploy(log_fn: Optional[callable], side: str, unit_idx: int, coord: Tuple[int, int]):
+def _log_deploy(log_fn: Optional[callable], side: str, unit_idx: int, coord: Tuple[int, int], unit=None):
     if log_fn is None:
         return
     unit_id = (11 + unit_idx) if side == "enemy" else (21 + unit_idx)
-    log_fn(f"[DEPLOY][{side.upper()}] Unit {unit_id} -> ({coord[0]},{coord[1]})")
+    unit_data = getattr(unit, "unit_data", None)
+    instance_id = getattr(unit, "instance_id", None)
+    unit_label = format_unit(
+        unit_id,
+        unit_data,
+        instance_id=instance_id,
+        include_instance_id=False,
+    )
+    log_fn(f"[DEPLOY][{side.upper()}] {unit_label} -> ({coord[0]},{coord[1]})")
 
 
 def deploy_only_war(
     model_units: Sequence,
     enemy_units: Sequence,
     b_len: int,
     b_hei: int,
     attacker_side: str,
     log_fn: Optional[callable] = None,
 ) -> None:
     """
     Alternating deployment starting with attacker.
     Units are placed wholly within their deployment zones and on free cells.
     """
     if attacker_side not in ("model", "enemy"):
         raise ValueError(f"Unknown attacker side: {attacker_side}")
 
     defender_side = "enemy" if attacker_side == "model" else "model"
     if log_fn is not None:
         log_fn(f"[DEPLOY] Order: {attacker_side} first, alternating")
 
     occupied: set[Tuple[int, int]] = set()
 
     def _place_unit(unit, side: str, unit_idx: int):
         coord = get_random_free_deploy_coord(side, b_len, b_hei, occupied)
         unit.unit_coords = [coord[0], coord[1]]
         occupied.add(coord)
-        _log_deploy(log_fn, side, unit_idx, coord)
+        _log_deploy(log_fn, side, unit_idx, coord, unit=unit)
 
     attacker_units = model_units if attacker_side == "model" else enemy_units
     defender_units = model_units if defender_side == "model" else enemy_units
 
     a_idx = 0
     d_idx = 0
     while a_idx < len(attacker_units) or d_idx < len(defender_units):
         if a_idx < len(attacker_units):
             _place_unit(attacker_units[a_idx], attacker_side, a_idx)
             a_idx += 1
         if d_idx < len(defender_units):
             _place_unit(defender_units[d_idx], defender_side, d_idx)
             d_idx += 1
 
 
 def post_deploy_setup(log_fn: Optional[callable] = None) -> None:
     """Placeholder for future post-deployment units (infiltrators, etc.)."""
     # TODO: add support for "set up after both armies deployed" units.
     if log_fn is not None:
         log_fn("[MISSION Only War] Post-deploy: currently no post-deploy units supported")
diff --git a/gym_mod/gym_mod/engine/logging_utils.py b/gym_mod/gym_mod/engine/logging_utils.py
new file mode 100644
index 0000000000000000000000000000000000000000..8e4a90b5b2f2b077a98c1b7f2e99a805b484ce48
--- /dev/null
+++ b/gym_mod/gym_mod/engine/logging_utils.py
@@ -0,0 +1,57 @@
+from __future__ import annotations
+
+from typing import Any, Optional
+
+
+def _format_faction(value: Any) -> str:
+    if value is None:
+        return ""
+    text = str(value).strip()
+    if not text:
+        return ""
+    if text.isupper():
+        return text.title()
+    return text
+
+
+def format_unit(
+    unit_id: Optional[int],
+    unit_data: Optional[dict] = None,
+    *,
+    instance_id: Optional[str] = None,
+    include_instance_id: bool = False,
+) -> str:
+    base = f"Unit {unit_id}" if unit_id is not None else "Unit <unknown>"
+
+    if not unit_data:
+        return f"{base} ‚Äî <unknown>"
+
+    name = unit_data.get("Name") or unit_data.get("name")
+    faction = _format_faction(
+        unit_data.get("Faction")
+        or unit_data.get("Army Faction")
+        or unit_data.get("Army")
+    )
+    models = unit_data.get("#OfModels") or unit_data.get("Models") or unit_data.get("models")
+
+    if name and faction:
+        main = f"{faction} {name}"
+    elif name:
+        main = str(name)
+    elif faction:
+        main = faction
+    else:
+        main = "<unknown>"
+
+    extras = []
+    if models is not None:
+        try:
+            extras.append(f"x{int(models)} –º–æ–¥–µ–ª–µ–π")
+        except (TypeError, ValueError):
+            extras.append(f"x{models} –º–æ–¥–µ–ª–µ–π")
+    if include_instance_id and instance_id:
+        extras.append(f"id={instance_id}")
+
+    if extras:
+        return f"{base} ‚Äî {main} ({', '.join(extras)})"
+    return f"{base} ‚Äî {main}"
diff --git a/gym_mod/gym_mod/engine/skills.py b/gym_mod/gym_mod/engine/skills.py
index 46c1e153e85afed532c50cc70c911613acd3ba14..281261fae0935e535577ed7cf97ffaf34c1715a1 100644
--- a/gym_mod/gym_mod/engine/skills.py
+++ b/gym_mod/gym_mod/engine/skills.py
@@ -1,28 +1,30 @@
 import math
 from typing import Callable, List, Sequence
 
+from gym_mod.engine.logging_utils import format_unit
+
 ABILITY_REANIMATION = "Reanimation Protocols"
 
 
 DiceFn = Callable[..., int]
 LogFn = Callable[[str], None]
 
 
 def roll_d3(dice_fn: DiceFn) -> int:
     roll = dice_fn(max=3)
     if isinstance(roll, Sequence) and not isinstance(roll, (str, bytes)):
         return int(roll[0])
     return int(roll)
 
 
 def _normalize_faction(value: str) -> str:
     return value.strip().lower()
 
 
 def is_necrons(unit_data: dict) -> bool:
     for key in ("Faction", "Army Faction", "Army"):
         value = unit_data.get(key)
         if isinstance(value, str) and _normalize_faction(value) == "necrons":
             return True
     return False
 
@@ -63,113 +65,112 @@ def _can_reanimate(wounds: List[int], unit_data: dict) -> bool:
     max_wounds = int(unit_data["W"])
     starting_models = int(unit_data["#OfModels"])
     if any(w < max_wounds for w in wounds):
         return True
     return len(wounds) < starting_models
 
 
 def _log_reanimation(log_fn: LogFn, message: str) -> None:
     if log_fn is None:
         return
     log_fn(message)
 
 
 def reanimation_protocols_one_unit(
     unit_health: float,
     unit_data: dict,
     dice_fn: DiceFn,
     log_fn: LogFn,
     unit_label: str,
 ) -> float:
     max_wounds = int(unit_data["W"])
     starting_models = int(unit_data["#OfModels"])
     wounds = _build_wounds_per_model(unit_health, unit_data)
     if not _can_reanimate(wounds, unit_data):
         return float(unit_health)
-    _log_reanimation(log_fn, f"{unit_label}Using ability: {ABILITY_REANIMATION}")
+    _log_reanimation(log_fn, f"{unit_label}–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å: {ABILITY_REANIMATION}")
     roll = roll_d3(dice_fn)
 
-    _log_reanimation(log_fn, f"{unit_label}Reanimation Protocols: rolled D3 = {roll}")
+    _log_reanimation(log_fn, f"{unit_label}Reanimation Protocols: –±—Ä–æ—Å–æ–∫ D3 = {roll}")
     _log_reanimation(
         log_fn,
-        f"{unit_label}before: models={len(wounds)}, wounds={wounds} total={sum(wounds)}",
+        f"{unit_label}–î–æ: –º–æ–¥–µ–ª–µ–π={len(wounds)}, —Ä–∞–Ω—ã={wounds} –≤—Å–µ–≥–æ={sum(wounds)}",
     )
 
     for _ in range(roll):
         wounded_indices = [idx for idx, w in enumerate(wounds) if w < max_wounds]
         if wounded_indices:
             idx = min(wounded_indices, key=lambda i: wounds[i])
             wounds[idx] += 1
-            _log_reanimation(log_fn, f"{unit_label}heal wounded model idx={idx}")
+            _log_reanimation(log_fn, f"{unit_label}–õ–µ—á–µ–Ω–∏–µ —Ä–∞–Ω–µ–Ω–æ–π –º–æ–¥–µ–ª–∏ idx={idx}")
             continue
 
         if len(wounds) < starting_models:
             wounds.append(1)
-            _log_reanimation(log_fn, f"{unit_label}return destroyed model with 1 wound")
+            _log_reanimation(log_fn, f"{unit_label}–í–æ–∑–≤—Ä–∞—â–µ–Ω–∞ —É–Ω–∏—á—Ç–æ–∂–µ–Ω–Ω–∞—è –º–æ–¥–µ–ª—å —Å 1 —Ä–∞–Ω–æ–π")
             continue
 
         break
 
     new_total = min(sum(wounds), starting_models * max_wounds)
     _log_reanimation(
         log_fn,
-        f"{unit_label}after:  models={len(wounds)}, wounds={wounds} total={new_total}",
+        f"{unit_label}–ü–æ—Å–ª–µ:  –º–æ–¥–µ–ª–µ–π={len(wounds)}, —Ä–∞–Ω—ã={wounds} –≤—Å–µ–≥–æ={new_total}",
     )
     return float(new_total)
 
 
 def apply_end_of_command_phase(env, side: str, dice_fn: DiceFn, log_fn: LogFn) -> None:
     if side == "model":
         health = env.unit_health
         data = env.unit_data
         side_label = "MODEL"
         unit_id_offset = 21
     else:
         health = env.enemy_health
         data = env.enemy_data
         side_label = "ENEMY"
         unit_id_offset = 11
 
     for i in range(len(health)):
         if health[i] <= 0:
             continue
         unit_data = data[i]
         if not is_necrons(unit_data):
             continue
         if not has_ability(unit_data, ABILITY_REANIMATION):
             continue
         unit_id = unit_id_offset + i
-        unit_label = f"[{side_label}][Unit {unit_id}|idx={i}] "
+        unit_label = f"[{side_label}] {format_unit(unit_id, unit_data)} "
         health[i] = reanimation_protocols_one_unit(
             health[i],
             unit_data,
             dice_fn,
             log_fn,
             unit_label,
         )
 
 
 def _self_check_fixed_roll(roll: int) -> DiceFn:
     def _dice(max: int = 6, num: int = 1) -> int:
         _ = max
         _ = num
         return roll
 
     return _dice
 
 
 def run_self_checks() -> None:
     data = {"W": 3, "#OfModels": 3}
     result = reanimation_protocols_one_unit(5, data, _self_check_fixed_roll(3), None, "[TEST] ")
     if result != 8:
         raise AssertionError(f"Expected 8, got {result}")
 
     data = {"W": 1, "#OfModels": 10}
     result = reanimation_protocols_one_unit(7, data, _self_check_fixed_roll(3), None, "[TEST] ")
     if result != 10:
         raise AssertionError(f"Expected 10, got {result}")
 
 
 if __name__ == "__main__":
     run_self_checks()
     print("skills.py self-checks passed")
-
diff --git a/gym_mod/gym_mod/engine/unitData.py b/gym_mod/gym_mod/engine/unitData.py
index 2684295c9f01f0de06960ff710fd15af5f8cd403..d98ad1cd29dbe802a708a2ba0fac780c7d6d53f3 100644
--- a/gym_mod/gym_mod/engine/unitData.py
+++ b/gym_mod/gym_mod/engine/unitData.py
@@ -1,22 +1,22 @@
 import json
 import os
 
 def unitData(army, unitName):
     with open(os.path.abspath("gym_mod/gym_mod/engine/unitData.json")) as j:
         data = json.loads(j.read())
     for i in data["UnitData"]:
         if i["Army"].lower() == army.lower() and i["Name"].lower() == unitName.lower():
             return i
-    print("Unit Not Found")
+    print("–Æ–Ω–∏—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")
     return {}
 
 def weaponData(name):
     if name == "None":
         return "None"
     with open(os.path.abspath("gym_mod/gym_mod/engine/unitData.json")) as j:
         data = json.loads(j.read())
     for i in data["WeaponData"]:
         if i["Name"][0:len(name)].lower() == name.lower():
             return i
-    print(name, "Weapon Not Found")
-    return {}
\ No newline at end of file
+    print(name, "–û—Ä—É–∂–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
+    return {}
diff --git a/gym_mod/gym_mod/envs/warhamEnv.py b/gym_mod/gym_mod/envs/warhamEnv.py
index c4b120573f5d99a406ed0d5d3dd6e1ba2e812129..5718088ef1d03c830d3aee61aa06e650dab24afd 100644
--- a/gym_mod/gym_mod/envs/warhamEnv.py
+++ b/gym_mod/gym_mod/envs/warhamEnv.py
@@ -1,43 +1,44 @@
 import gymnasium as gym
 from gymnasium import spaces
 import numpy as np
 import matplotlib.pyplot as plt
 import os
 import random
 import re
 
 from ..engine.utils import *
 from ..engine import utils as engine_utils
 from gym_mod.engine.GUIinteract import *
 from gym_mod.engine.mission import (
     MISSION_NAME,
     MAX_BATTLE_ROUNDS,
     score_end_of_command_phase,
     apply_end_of_battle,
 )
 from gym_mod.engine.skills import apply_end_of_command_phase
+from gym_mod.engine.logging_utils import format_unit
 
 # ============================================================
 # üîß FIX: resolve string weapons like "Bolt pistol [PISTOL]"
 # so engine.utils.attack() always receives a dict (or we safely
 # skip the attack instead of crashing with "'str' object has no attribute 'get'").
 # This is intentionally defensive: if WeaponData can't be found,
 # we still won't crash during training.
 # ============================================================
 
 _attack_original = attack  # keep reference to the original engine attack
 _WEAPON_INDEX = None
 
 def _norm_weapon_name(x):
     if not isinstance(x, str):
         return x
     # remove tags in square brackets: "Bolt pistol [PISTOL]" -> "Bolt pistol"
     x = re.sub(r"\s*\[.*?\]\s*", "", x)
     return x.strip().lower()
 
 def _build_weapon_index():
     """
     Try to locate WeaponData list from a few common places.
     Returns dict: normalized_name -> weapon_dict
     """
     weapon_list = None
@@ -763,114 +764,175 @@ class Warhammer40kEnv(gym.Env):
             self.unit_health.append(model[i].showUnitData()["W"] * model[i].showUnitData()["#OfModels"])
             self.unitInAttack.append([0, 0])
             self.modelOC.append(model[i].showUnitData()["OC"])
         self.unitFellBack = [False] * len(self.unit_health)
 
         obsSpace = (len(model) * 3) + (len(enemy) * 3) + len(self.coordsOfOM * 2) + 1
         self.observation_space = spaces.Box(low=-np.inf, high=np.inf, shape=(obsSpace,), dtype=np.float32)
 
     def get_info(self):
         return {
             "model health": self.unit_health,
             "player health": self.enemy_health,
             "modelCP": self.modelCP,
             "playerCP": self.enemyCP,
             "in attack": self.unitInAttack,
             "model VP": self.modelVP,
             "player VP": self.enemyVP,
             "mission": self.mission_name,
             "turn": self.numTurns,
             "battle round": self.battle_round,
             "active side": self.active_side,
             "phase": self.phase,
         }
 
     def _should_log(self) -> bool:
-        verbose = os.getenv("VERBOSE_LOGS", "0") == "1" or os.getenv("MANUAL_DICE", "0") == "1"
-        if verbose:
+        if self._is_verbose():
             return True
         return self.trunc is False
 
-    def _log(self, msg: str):
+    def _is_verbose(self) -> bool:
+        return os.getenv("VERBOSE_LOGS", "0") == "1" or os.getenv("MANUAL_DICE", "0") == "1"
+
+    def _log(self, msg: str, verbose_only: bool = False):
+        if verbose_only and not self._is_verbose():
+            return
         if not self._should_log():
             return
         if self.playType is True:
             sendToGUI(msg)
         else:
             print(msg)
 
     def _log_phase(self, side: str, phase: str):
         if not self._should_log():
             return
         phase_title = {
-            "command": "–§–∞–∑–∞ –∫–æ–º–∞–Ω–¥–æ–≤–∞–Ω–∏—è!",
-            "movement": "–§–∞–∑–∞ –¥–≤–∏–∂–µ–Ω–∏—è!",
-            "shooting": "–§–∞–∑–∞ —Å—Ç—Ä–µ–ª—å–±—ã!",
-            "charge": "–§–∞–∑–∞ —á–∞—Ä–¥–∂–∞!",
-            "fight": "–§–∞–∑–∞ –±–∏—Ç–≤—ã!",
-        }.get(phase, f"–§–∞–∑–∞ {phase}!")
-        self._log(f"[{side.upper()}] {phase_title}")
+            "command": "–§–ê–ó–ê –ö–û–ú–ê–ù–î–û–í–ê–ù–ò–Ø",
+            "movement": "–§–ê–ó–ê –î–í–ò–ñ–ï–ù–ò–Ø",
+            "shooting": "–§–ê–ó–ê –°–¢–†–ï–õ–¨–ë–´",
+            "charge": "–§–ê–ó–ê –ß–ê–†–î–ñ–ê",
+            "fight": "–§–ê–ó–ê –ë–û–Ø",
+        }.get(phase, f"–§–ê–ó–ê {phase.upper()}")
+        self._log(f"--- {phase_title} ---")
 
     def _log_unit(self, side: str, unit_id: int, unit_idx: int, msg: str):
         if not self._should_log():
             return
-        self._log(f"[{side.upper()}][Unit {unit_id}|idx={unit_idx}] {msg}")
+        side_label = self._side_label(side)
+        unit_label = self._format_unit_label(side, unit_idx, unit_id=unit_id)
+        self._log(f"[{side_label}] {unit_label}: {msg}")
 
     def _side_label(self, side: str, manual: bool = False) -> str:
         if side == "model":
             return "MODEL"
         if side == "enemy":
             return "PLAYER" if manual else "ENEMY"
         return side.upper()
 
     def _log_phase_msg(self, side_label: str, phase: str, msg: str):
         if not self._should_log():
             return
         self._log(f"[{side_label}][{phase.upper()}] {msg}")
 
     def _log_unit_phase(self, side_label: str, phase: str, unit_id: int, unit_idx: int, msg: str):
         if not self._should_log():
             return
-        self._log(f"[{side_label}][{phase.upper()}][Unit {unit_id}|idx={unit_idx}] {msg}")
+        unit_label = self._format_unit_label(
+            "model" if side_label == "MODEL" else "enemy",
+            unit_idx,
+            unit_id=unit_id,
+        )
+        self._log(f"[{side_label}][{phase.upper()}] {unit_label}: {msg}")
+
+    def _log_action(self, side: str, unit_idx: int, msg: str, phase: str = None, verbose_only: bool = False):
+        side_label = self._side_label(side)
+        unit_label = self._format_unit_label(side, unit_idx)
+        phase_prefix = f"[{phase.upper()}] " if phase else ""
+        self._log(f"[{side_label}] {phase_prefix}{unit_label}: {msg}", verbose_only=verbose_only)
+
+    def _log_rule(
+        self,
+        side: str,
+        unit_idx: int,
+        rule_name: str,
+        details: str,
+        phase: str = None,
+        verbose_only: bool = False,
+    ):
+        rule_msg = f"–ü—Ä–∞–≤–∏–ª–æ/—Å—Ç—Ä–∞—Ç–∞–≥–µ–º–∞ ¬´{rule_name}¬ª: {details}"
+        self._log_action(side, unit_idx, rule_msg, phase=phase, verbose_only=verbose_only)
+
+    def _log_range(self, weapon: dict, dist: float, weapon_range: float, half_range: float, rapid_fire_on: bool):
+        weapon_name = weapon.get("Name", "–æ—Ä—É–∂–∏–µ") if isinstance(weapon, dict) else "–æ—Ä—É–∂–∏–µ"
+        rapid_text = "–¥–∞" if rapid_fire_on else "–Ω–µ—Ç"
+        self._log(
+            f"[–î–∞–ª—å–Ω–æ—Å—Ç—å] {weapon_name}: –¥–∏—Å—Ç–∞–Ω—Ü–∏—è={dist:.1f}, range={weapon_range}, half={half_range}, rapid_fire={rapid_text}",
+            verbose_only=True,
+        )
+
+    def _unit_id(self, side: str, unit_idx: int) -> int:
+        side = side.lower()
+        return (21 + unit_idx) if side == "model" else (11 + unit_idx)
+
+    def _get_unit_data(self, side: str, unit_idx: int):
+        side = side.lower()
+        data_list = self.unit_data if side == "model" else self.enemy_data
+        if 0 <= unit_idx < len(data_list):
+            return data_list[unit_idx]
+        return None
+
+    def _format_unit_label(self, side: str, unit_idx: int, unit_id: int = None) -> str:
+        side = side.lower()
+        unit_id = unit_id if unit_id is not None else self._unit_id(side, unit_idx)
+        unit_data = self._get_unit_data(side, unit_idx)
+        return format_unit(
+            unit_id,
+            unit_data,
+            include_instance_id=self._is_verbose(),
+        )
+
+    def _format_unit_choices(self, side: str, indices: list[int]) -> str:
+        return ", ".join(self._format_unit_label(side, idx) for idx in indices)
 
     def _get_input(self, prompt: str) -> str:
         if self.playType is True:
             sendToGUI(prompt)
             return recieveGUI()
         return input(prompt)
 
     def _prompt_choice(self, prompt: str, allowed: dict, normalize: dict, allow_quit: bool = True):
         allowed_labels = ", ".join(allowed.values())
         while True:
             response = self._get_input(prompt).strip().lower()
             if allow_quit and response in ("quit", "q"):
                 return None
             if response in normalize:
                 response = normalize[response]
             if response in allowed:
                 return response
-            self._log(f"Not a valid response ({allowed_labels}): {response}")
+            self._log(f"–ù–µ–≤–µ—Ä–Ω—ã–π –≤–≤–æ–¥ (–¥–æ—Å—Ç—É–ø–Ω–æ: {allowed_labels}): {response}")
 
     def _prompt_yes_no(self, prompt: str, allow_quit: bool = True):
         normalize = {"y": "yes", "n": "no", "yes": "yes", "no": "no"}
         allowed = {"yes": "yes", "no": "no"}
         response = self._prompt_choice(prompt, allowed, normalize, allow_quit=allow_quit)
         if response is None:
             return None
         return response == "yes"
 
     def _unit_has_keyword(self, unit_data: dict, keyword: str) -> bool:
         if not unit_data:
             return False
         keyword = keyword.lower()
         for key in ("Keywords", "KeyWords", "Tags", "Abilities", "Rules", "SpecialRules", "Special", "Type", "Faction"):
             value = unit_data.get(key)
             if value is None:
                 continue
             if isinstance(value, (list, tuple)):
                 if any(keyword in str(v).lower() for v in value):
                     return True
             else:
                 if keyword in str(value).lower():
                     return True
         # fallback: check all fields
         for value in unit_data.values():
@@ -879,139 +941,142 @@ class Warhammer40kEnv(gym.Env):
                     return True
             else:
                 if keyword in str(value).lower():
                     return True
         return False
 
     def _unit_has_smoke(self, unit_data: dict) -> bool:
         return self._unit_has_keyword(unit_data, "smoke")
 
     def _maybe_use_smokescreen(self, defender_side: str, defender_idx: int, phase: str, manual: bool = False):
         """
         10e Smokescreen: —Ä–µ–∞–∫—Ü–∏—è –∑–∞—â–∏—Ç–Ω–∏–∫–∞ –≤ –º–æ–º–µ–Ω—Ç –≤—ã–±–æ—Ä–∞ —Ü–µ–ª–∏ –¥–ª—è —Å—Ç—Ä–µ–ª—å–±—ã.
         –£–ø—Ä–æ—â–µ–Ω–∏–µ: –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ keyword SMOKE –∏ CP.
         """
         side_label = self._side_label(defender_side, manual=manual)
         if defender_side == "model":
             cp = self.modelCP
             unit_data = self.unit_data[defender_idx]
         else:
             cp = self.enemyCP
             unit_data = self.enemy_data[defender_idx]
 
         if not self._unit_has_smoke(unit_data):
             return None
         if cp < 1:
-            self._log_unit_phase(
-                side_label,
-                phase,
-                defender_idx + (21 if defender_side == "model" else 11),
+            self._log_rule(
+                defender_side,
                 defender_idx,
-                "Smokescreen –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ CP.",
+                "Smokescreen",
+                "–£—Å–ª–æ–≤–∏–µ: –µ—Å—Ç—å SMOKE –∏ 1 CP. –†–µ–∑—É–ª—å—Ç–∞—Ç: –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ CP.",
+                phase=phase,
             )
             return None
 
         use_it = True
         if manual:
             strat = self._prompt_yes_no("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Smokescreen (1 CP)? (y/n): ")
             if strat is None:
                 self.game_over = True
                 return None
             use_it = strat
 
         if not use_it:
             return None
 
         if defender_side == "model":
             self.modelCP -= 1
         else:
             self.enemyCP -= 1
 
-        self._log_unit_phase(
-            side_label,
-            phase,
-            defender_idx + (21 if defender_side == "model" else 11),
+        self._log_rule(
+            defender_side,
             defender_idx,
-            "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω Smokescreen: -1 CP, —ç—Ñ—Ñ–µ–∫—Ç = benefit of cover –¥–æ –∫–æ–Ω—Ü–∞ –∞—Ç–∞–∫–∏.",
+            "Smokescreen",
+            "–¢—Ä–∏–≥–≥–µ—Ä: –≤—ã–±—Ä–∞–Ω –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Ü–µ–ª–∏. –°—Ç–æ–∏–º–æ—Å—Ç—å: -1 CP. –≠—Ñ—Ñ–µ–∫—Ç: benefit of cover –¥–æ –∫–æ–Ω—Ü–∞ –∞—Ç–∞–∫–∏.",
+            phase=phase,
         )
         return "benefit of cover"
 
     def _collect_overwatch_candidates(self, defender_side: str, moving_unit_side: str, moving_idx: int):
         if defender_side == "model":
             defender_health = self.unit_health
             defender_coords = self.unit_coords
             defender_weapon = self.unit_weapon
             defender_in_attack = self.unitInAttack
             target_coords = self.enemy_coords if moving_unit_side == "enemy" else self.unit_coords
         else:
             defender_health = self.enemy_health
             defender_coords = self.enemy_coords
             defender_weapon = self.enemy_weapon
             defender_in_attack = self.enemyInAttack
             target_coords = self.unit_coords if moving_unit_side == "model" else self.enemy_coords
 
         target_pos = target_coords[moving_idx]
         candidates = []
         for i in range(len(defender_health)):
             if defender_health[i] <= 0:
                 continue
             if defender_in_attack[i][0] == 1:
                 continue
             if defender_weapon[i] == "None":
                 continue
             if distance(defender_coords[i], target_pos) <= defender_weapon[i]["Range"]:
                 candidates.append(i)
         return candidates
 
     def _resolve_overwatch(self, defender_side: str, moving_unit_side: str, moving_idx: int, phase: str, manual: bool = False):
         """
         10e Fire Overwatch: —Ä–µ–∞–∫—Ü–∏—è –∑–∞—â–∏—Ç–Ω–∏–∫–∞ –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è –≤—Ä–∞–≥–∞.
         –£–ø—Ä–æ—â–µ–Ω–∏–µ: –ø—Ä–æ–≤–µ—Ä—è–µ–º –¥–∞–ª—å–Ω–æ—Å—Ç—å, –Ω–µ —É—á–∏—Ç—ã–≤–∞–µ–º LOS.
         """
         side_label = self._side_label(defender_side, manual=manual)
-        target_label = self._side_label(moving_unit_side, manual=False)
         candidates = self._collect_overwatch_candidates(defender_side, moving_unit_side, moving_idx)
         if not candidates:
             self._log_phase_msg(side_label, phase, "Overwatch –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω: –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å—Ç—Ä–µ–ª—è—é—â–∏—Ö —é–Ω–∏—Ç–æ–≤.")
             return
 
         cp = self.modelCP if defender_side == "model" else self.enemyCP
         if cp < 1:
             self._log_phase_msg(side_label, phase, "Overwatch –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω: –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ CP.")
             return
 
+        target_label = self._format_unit_label(moving_unit_side, moving_idx)
         self._log_phase_msg(
             side_label,
             phase,
-            f"–°—Ä–∞–±–æ—Ç–∞–ª —Ç—Ä–∏–≥–≥–µ—Ä Overwatch –ø—Ä–æ—Ç–∏–≤ {target_label} Unit {moving_idx + (21 if moving_unit_side == 'model' else 11)}.",
+            f"–¢—Ä–∏–≥–≥–µ—Ä Overwatch: —Ü–µ–ª—å –ø–µ—Ä–µ–º–µ—Å—Ç–∏–ª–∞—Å—å. –¶–µ–ª—å: {target_label}.",
         )
 
         use_it = True
         chosen = candidates[0]
         if manual:
             ids = [c + (21 if defender_side == "model" else 11) for c in candidates]
-            strat = self._prompt_yes_no(f"–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Overwatch (1 CP)? –î–æ—Å—Ç—É–ø–Ω—ã–µ —é–Ω–∏—Ç—ã: {ids} (y/n): ")
+            candidates_label = self._format_unit_choices(defender_side, candidates)
+            strat = self._prompt_yes_no(
+                f"–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Overwatch (1 CP)? –î–æ—Å—Ç—É–ø–Ω—ã–µ —é–Ω–∏—Ç—ã: {candidates_label}. (y/n): "
+            )
             if strat is None:
                 self.game_over = True
                 return
             if not strat:
                 return
             choice = self._get_input("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —é–Ω–∏—Ç–∞ –¥–ª—è Overwatch: ").strip()
             if not is_num(choice) or int(choice) - (21 if defender_side == "model" else 11) not in candidates:
                 self._log_phase_msg(side_label, phase, "Overwatch –æ—Ç–º–µ–Ω—ë–Ω: –≤—ã–±—Ä–∞–Ω –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã–π —é–Ω–∏—Ç.")
                 return
             chosen = int(choice) - (21 if defender_side == "model" else 11)
 
         if defender_side == "model":
             self.modelCP -= 1
             attacker_health = self.unit_health
             attacker_weapon = self.unit_weapon
             attacker_data = self.unit_data
             target_health = self.enemy_health if moving_unit_side == "enemy" else self.unit_health
             target_data = self.enemy_data if moving_unit_side == "enemy" else self.unit_data
             target_coords = self.enemy_coords if moving_unit_side == "enemy" else self.unit_coords
         else:
             self.enemyCP -= 1
             attacker_health = self.enemy_health
             attacker_weapon = self.enemy_weapon
             attacker_data = self.enemy_data
             target_health = self.unit_health if moving_unit_side == "model" else self.enemy_health
@@ -1025,301 +1090,291 @@ class Warhammer40kEnv(gym.Env):
         _logger = None
         if self.trunc is False and _verbose_logs_enabled():
             _logger = RollLogger(auto_dice)
             dmg, modHealth = attack(
                 attacker_health[chosen],
                 attacker_weapon[chosen],
                 attacker_data[chosen],
                 target_health[moving_idx],
                 target_data[moving_idx],
                 distance_to_target=distance_to_target,
                 hit_on_6=True,
                 roller=_logger.roll,
             )
         else:
             dmg, modHealth = attack(
                 attacker_health[chosen],
                 attacker_weapon[chosen],
                 attacker_data[chosen],
                 target_health[moving_idx],
                 target_data[moving_idx],
                 distance_to_target=distance_to_target,
                 hit_on_6=True,
             )
 
         target_health[moving_idx] = modHealth
-        attacker_unit_id = chosen + (21 if defender_side == "model" else 11)
-        target_unit_id = moving_idx + (21 if moving_unit_side == "model" else 11)
-        self._log_unit_phase(
-            side_label,
-            phase,
-            attacker_unit_id,
+        self._log_rule(
+            defender_side,
             chosen,
-            f"Overwatch –ø–æ {target_label} Unit {target_unit_id}: -1 CP, —É—Ä–æ–Ω {float(np.sum(dmg))}.",
+            "Overwatch",
+            f"–¶–µ–ª—å: {target_label}. –°—Ç–æ–∏–º–æ—Å—Ç—å: -1 CP. –ò—Ç–æ–≥–æ–≤—ã–π —É—Ä–æ–Ω: {float(np.sum(dmg))}.",
+            phase=phase,
         )
         if _logger is not None:
             _logger.print_shoot_report(
                 weapon=attacker_weapon[chosen],
                 attacker_data=attacker_data[chosen],
                 defender_data=target_data[moving_idx],
                 dmg_list=dmg,
                 effect=None,
             )
 
     def _resolve_heroic_intervention(self, defender_side: str, charging_side: str, charging_idx: int, phase: str, manual: bool = False):
         """
         10e Heroic Intervention: —Ä–µ–∞–∫—Ü–∏—è –∑–∞—â–∏—Ç–Ω–∏–∫–∞ –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ charge move –≤—Ä–∞–≥–∞.
         –£–ø—Ä–æ—â–µ–Ω–∏–µ: eligible = —é–Ω–∏—Ç—ã –∑–∞—â–∏—Ç–Ω–∏–∫–∞ –≤ 6" –æ—Ç charging unit.
         –ò–∑-–∑–∞ 1v1 —Å—Ç—Ä—É–∫—Ç—É—Ä—ã unitInAttack –æ—Ç–º–µ—á–∞–µ–º —Ç–æ–ª—å–∫–æ –∑–∞—â–∏—Ç–Ω–∏–∫–∞.
         """
         side_label = self._side_label(defender_side, manual=manual)
         if defender_side == "model":
             defender_health = self.unit_health
             defender_coords = self.unit_coords
             defender_in_attack = self.unitInAttack
             defender_cp = self.modelCP
         else:
             defender_health = self.enemy_health
             defender_coords = self.enemy_coords
             defender_in_attack = self.enemyInAttack
             defender_cp = self.enemyCP
 
         charging_coords = self.unit_coords if charging_side == "model" else self.enemy_coords
         eligible = []
         for i in range(len(defender_health)):
             if defender_health[i] <= 0:
                 continue
             if defender_in_attack[i][0] == 1:
                 continue
             if distance(defender_coords[i], charging_coords[charging_idx]) <= 6:
                 eligible.append(i)
 
         if not eligible:
-            self._log_phase_msg(side_label, phase, "Heroic Intervention –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: –Ω–µ—Ç eligible —é–Ω–∏—Ç–æ–≤ –≤ 6\".")
+            self._log_phase_msg(side_label, phase, "Heroic Intervention –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: –Ω–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —é–Ω–∏—Ç–æ–≤ –≤ 6\".")
             return
 
         if defender_cp < 2:
             self._log_phase_msg(side_label, phase, "Heroic Intervention –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ CP.")
             return
 
-        unit_ids = [i + (21 if defender_side == "model" else 11) for i in eligible]
-        self._log_phase_msg(
-            side_label,
-            phase,
-            f"–î–æ—Å—Ç—É–ø–Ω—ã–µ —é–Ω–∏—Ç—ã –¥–ª—è Heroic Intervention: {unit_ids}.",
-        )
+        unit_choices = self._format_unit_choices(defender_side, eligible)
+        self._log_phase_msg(side_label, phase, f"–î–æ—Å—Ç—É–ø–Ω—ã–µ —é–Ω–∏—Ç—ã –¥–ª—è Heroic Intervention: {unit_choices}.")
 
         use_it = True
         chosen = eligible[0]
         if manual:
             strat = self._prompt_yes_no("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Heroic Intervention (2 CP)? (y/n): ")
             if strat is None:
                 self.game_over = True
                 return
             if not strat:
                 return
             choice = self._get_input("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —é–Ω–∏—Ç–∞ –¥–ª—è Heroic Intervention: ").strip()
             if not is_num(choice) or int(choice) - (21 if defender_side == "model" else 11) not in eligible:
                 self._log_phase_msg(side_label, phase, "Heroic Intervention –æ—Ç–º–µ–Ω—ë–Ω: –≤—ã–±—Ä–∞–Ω –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã–π —é–Ω–∏—Ç.")
                 return
             chosen = int(choice) - (21 if defender_side == "model" else 11)
 
         if defender_side == "model":
             self.modelCP -= 2
         else:
             self.enemyCP -= 2
 
         pos_before = tuple(defender_coords[chosen])
         defender_coords[chosen][0] = charging_coords[charging_idx][0] + 1
         defender_coords[chosen][1] = charging_coords[charging_idx][1] + 1
         defender_coords[chosen] = bounds(defender_coords[chosen], self.b_len, self.b_hei)
         defender_in_attack[chosen][0] = 1
         defender_in_attack[chosen][1] = charging_idx
         pos_after = tuple(defender_coords[chosen])
 
         self._log_unit_phase(
             side_label,
             phase,
             chosen + (21 if defender_side == "model" else 11),
             chosen,
             f"–í—ã–±—Ä–∞–Ω –¥–ª—è Heroic Intervention. –ü–µ—Ä–µ–º–µ—Å—Ç–∏–ª—Å—è: {pos_before} -> {pos_after}, entered_in_engagement=True.",
         )
 
     def _prompt_int(self, prompt: str, min_val: int, max_val: int, allow_quit: bool = True):
         while True:
             response = self._get_input(prompt).strip().lower()
             if allow_quit and response in ("quit", "q"):
                 return None
             if response.isdigit():
                 value = int(response)
                 if min_val <= value <= max_val:
                     return value
-                self._log(f"Not in range ({min_val}..{max_val}): {value}")
+                self._log(f"–ó–Ω–∞—á–µ–Ω–∏–µ –≤–Ω–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ ({min_val}..{max_val}): {value}")
             else:
-                self._log("Not a number, try again.")
+                self._log("–≠—Ç–æ –Ω–µ —á–∏—Å–ª–æ, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
 
     def begin_phase(self, side: str, phase: str):
         self.active_side = side
         self.phase = phase
         if not self._round_banner_shown:
-            self._log(f"=== BATTLE ROUND {self.battle_round} ===")
+            self._log(f"=== –ë–û–ï–í–û–ô –†–ê–£–ù–î {self.battle_round} ===")
             self._round_banner_shown = True
         if phase == "command":
-            self._log(f"--- {side.upper()} TURN ---")
+            self._log(f"--- –•–û–î {self._side_label(side)} ---")
             if side == "model":
                 self.unitFellBack = [False] * len(self.unit_health)
             elif side == "enemy":
                 self.enemyFellBack = [False] * len(self.enemy_health)
-        phase_title = {
-            "command": "Command phase!",
-            "movement": "Movement phase!",
-            "shooting": "Shooting phase!",
-            "charge": "Charge phase!",
-            "fight": "Fight phase!",
-        }.get(phase, f"{phase.title()} phase!")
-        self._log(phase_title)
+        self._log_phase(self._side_label(side), phase)
 
     def _end_battle_round(self):
-        self._log(f"=== END OF BATTLE ROUND {self.battle_round} ===")
+        self._log(f"=== –ö–û–ù–ï–¶ –ë–û–ï–í–û–ì–û –†–ê–£–ù–î–ê {self.battle_round} ===")
         self.battle_round += 1
         self.numTurns = self.battle_round
         self._round_banner_shown = False
         apply_end_of_battle(self, log_fn=self._log)
 
     def _advance_turn_order(self):
         if self.active_side == self.turn_order[-1]:
             self._end_battle_round()
             self.active_side = self.turn_order[0]
         else:
             current_index = self.turn_order.index(self.active_side)
             self.active_side = self.turn_order[current_index + 1]
         self.phase = "command"
 
     def command_phase(self, side: str, action=None, manual: bool = False):
         self.begin_phase(side, "command")
         if side == "model":
             self._log_phase("MODEL", "command")
             self.modelCP += 1
             self.enemyCP += 1
             reward_delta = 0
             battle_shock = [False] * len(self.unit_health)
             for i in range(len(self.unit_health)):
+                unit_label = self._format_unit_label("model", i)
                 if isBelowHalfStr(self.unit_data[i], self.unit_health[i]) is True and self.unit_health[i] > 0:
                     if self.trunc is False:
-                        self._log("This unit is Battle-shocked, starting test...")
-                        self._log("Rolling 2D6...")
+                        self._log(f"{unit_label}: –Ω–∏–∂–µ –ø–æ–ª–æ–≤–∏–Ω—ã —Å–æ—Å—Ç–∞–≤–∞, —Ç–µ—Å—Ç Battle-shock.")
+                        self._log("–ë—Ä–æ—Å–æ–∫ 2D6...", verbose_only=True)
                     diceRoll = dice(num=2)
                     if self.trunc is False:
-                        self._log(f"Model rolled {diceRoll[0]} {diceRoll[1]}")
+                        self._log(f"–ë—Ä–æ—Å–æ–∫: {diceRoll[0]} {diceRoll[1]}", verbose_only=True)
                     if sum(diceRoll) >= self.unit_data[i]["Ld"]:
                         self.modelOC[i] = self.unit_data[i]["OC"]
                         if self.trunc is False:
-                            self._log("Battle-shock test passed!")
+                            self._log(f"{unit_label}: —Ç–µ—Å—Ç Battle-shock –ø—Ä–æ–π–¥–µ–Ω.")
                     else:
                         battle_shock[i] = True
                         self.modelOC[i] = 0
                         if self.trunc is False:
-                            self._log("Battle-shock test failed")
+                            self._log(f"{unit_label}: —Ç–µ—Å—Ç Battle-shock –ø—Ä–æ–≤–∞–ª–µ–Ω.")
                         if action and action.get("use_cp") == 1 and action.get("cp_on") == i:
                             if self.modelCP - 1 >= 0:
                                 battle_shock[i] = False
                                 reward_delta += 0.5
                                 self.modelCP -= 1
                                 if self.trunc is False:
-                                    self._log("Used Insane Bravery Stratagem to pass Battle Shock test")
+                                    self._log(f"{unit_label}: –ø—Ä–∏–º–µ–Ω–µ–Ω–∞ Insane Bravery (-1 CP), —Ç–µ—Å—Ç –ø—Ä–æ–π–¥–µ–Ω.")
                             else:
                                 reward_delta -= 0.5
             dice_fn = player_dice if os.getenv("MANUAL_DICE", "0") == "1" and side == "enemy" else auto_dice
             apply_end_of_command_phase(self, side="model", dice_fn=dice_fn, log_fn=self._log)
             score_end_of_command_phase(self, "model", log_fn=self._log)
             return battle_shock, reward_delta
 
         if side == "enemy" and manual:
             self.enemyCP += 1
             self.modelCP += 1
             battle_shock = [False] * len(self.enemy_health)
             for i in range(len(self.enemy_health)):
                 playerName = i + 11
                 battleSh = False
+                unit_label = self._format_unit_label("enemy", i, unit_id=playerName)
                 if isBelowHalfStr(self.enemy_data[i], self.enemy_health[i]) is True and self.unit_health[i] > 0:
-                    self._log("This unit is Battle-shocked, starting test...")
-                    self._log("Rolling 2D6...")
+                    self._log(f"{unit_label}: –Ω–∏–∂–µ –ø–æ–ª–æ–≤–∏–Ω—ã —Å–æ—Å—Ç–∞–≤–∞, —Ç–µ—Å—Ç Battle-shock.")
+                    self._log("–ë—Ä–æ—Å–æ–∫ 2D6...", verbose_only=True)
                     diceRoll = player_dice(num=2)
-                    self._log(f"You rolled {diceRoll[0]} {diceRoll[1]}")
+                    self._log(f"–ë—Ä–æ—Å–æ–∫: {diceRoll[0]} {diceRoll[1]}", verbose_only=True)
                     if sum(diceRoll) >= self.enemy_data[i]["Ld"]:
-                        self._log("Battle-shock test passed!")
+                        self._log(f"{unit_label}: —Ç–µ—Å—Ç Battle-shock –ø—Ä–æ–π–¥–µ–Ω.")
                         self.enemyOC[i] = self.enemy_data[i]["OC"]
                     else:
                         battleSh = True
-                        self._log("Battle-shock test failed")
+                        self._log(f"{unit_label}: —Ç–µ—Å—Ç Battle-shock –ø—Ä–æ–≤–∞–ª–µ–Ω.")
                         self.enemyOC[i] = 0
                         if self.enemyCP - 1 >= 0:
                             strat = self._prompt_yes_no(
-                                f"Would you like to use the Insane Bravery Strategem for Unit {playerName}? (y/n): "
+                                f"{unit_label}. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å—Ç—Ä–∞—Ç–∞–≥–µ–º—É Insane Bravery (1 CP)? (y/n): "
                             )
                             if strat is None:
                                 self.game_over = True
                                 return None
                             if strat:
                                 battleSh = False
                                 self.enemyCP -= 1
                                 self.enemyOC[i] = self.enemy_data[i]["OC"]
                 battle_shock[i] = battleSh
                 if battleSh:
                     continue
             self._manual_enemy_battle_shock = battle_shock
             dice_fn = player_dice if os.getenv("MANUAL_DICE", "0") == "1" and side == "enemy" else auto_dice
             apply_end_of_command_phase(self, side="enemy", dice_fn=dice_fn, log_fn=self._log)
             score_end_of_command_phase(self, "enemy", log_fn=self._log)
             return battle_shock
 
         if side == "enemy":
             self.enemyCP += 1
             self.modelCP += 1
             battle_shock = [False] * len(self.enemy_health)
             cp_on = np.random.randint(0, len(self.enemy_health))
             use_cp = np.random.randint(0, 5)
             self._enemy_cp_on = cp_on
             self._enemy_use_cp = use_cp
             for i in range(len(self.enemy_health)):
                 battleSh = False
+                unit_label = self._format_unit_label("enemy", i)
                 if isBelowHalfStr(self.enemy_data[i], self.enemy_health[i]) is True and self.unit_health[i] > 0:
                     if self.trunc is False:
-                        self._log("This unit is Below Half Strength, starting test...")
-                        self._log("Rolling 2D6...")
+                        self._log(f"{unit_label}: –Ω–∏–∂–µ –ø–æ–ª–æ–≤–∏–Ω—ã —Å–æ—Å—Ç–∞–≤–∞, —Ç–µ—Å—Ç Battle-shock.")
+                        self._log("–ë—Ä–æ—Å–æ–∫ 2D6...", verbose_only=True)
                     diceRoll = dice(num=2)
                     if self.trunc is False:
-                        self._log(f"Player rolled {diceRoll[0]} {diceRoll[1]}")
+                        self._log(f"–ë—Ä–æ—Å–æ–∫: {diceRoll[0]} {diceRoll[1]}", verbose_only=True)
                     if sum(diceRoll) >= self.enemy_data[i]["Ld"]:
                         if self.trunc is False:
-                            self._log("Battle-shock test passed!")
+                            self._log(f"{unit_label}: —Ç–µ—Å—Ç Battle-shock –ø—Ä–æ–π–¥–µ–Ω.")
                         self.enemyOC[i] = self.enemy_data[i]["OC"]
                     else:
                         battleSh = True
                         self.enemyOC[i] = 0
                         if self.trunc is False:
-                            self._log("Battle-shock test failed")
+                            self._log(f"{unit_label}: —Ç–µ—Å—Ç Battle-shock –ø—Ä–æ–≤–∞–ª–µ–Ω.")
                         if use_cp == 1 and cp_on == i and self.enemyCP - 1 >= 0:
                             battleSh = False
                             self.enemyCP -= 1
                             self.enemyOC[i] = self.enemy_data[i]["OC"]
 
                 battle_shock[i] = battleSh
             dice_fn = player_dice if os.getenv("MANUAL_DICE", "0") == "1" and side == "enemy" else auto_dice
             apply_end_of_command_phase(self, side="enemy", dice_fn=dice_fn, log_fn=self._log)
             score_end_of_command_phase(self, "enemy", log_fn=self._log)
             return battle_shock
 
         return None
 
     def movement_phase(self, side: str, action=None, manual: bool = False, battle_shock=None):
         self.begin_phase(side, "movement")
         if side == "model":
             self._log_phase("MODEL", "movement")
             advanced_flags = [False] * len(self.unit_health)
             reward_delta = 0
             for i in range(len(self.unit_health)):
                 modelName = i + 21
                 battleSh = battle_shock[i] if battle_shock else False
                 pos_before = tuple(self.unit_coords[i])
                 if self.unit_health[i] <= 0:
                     self._log_unit("MODEL", modelName, i, f"–Æ–Ω–∏—Ç –º–µ—Ä—Ç–≤, –¥–≤–∏–∂–µ–Ω–∏–µ –ø—Ä–æ–ø—É—â–µ–Ω–æ. –ü–æ–∑–∏—Ü–∏—è: {pos_before}")
@@ -1380,161 +1435,162 @@ class Warhammer40kEnv(gym.Env):
                     if pos_before != pos_after:
                         self._resolve_overwatch(
                             defender_side="enemy",
                             moving_unit_side="model",
                             moving_idx=i,
                             phase="movement",
                             manual=os.getenv("MANUAL_DICE", "0") == "1",
                         )
 
                     for j in range(len(self.coordsOfOM)):
                         if distance(self.coordsOfOM[j], self.unit_coords[i]) <= 5:
                             reward_delta += 0.5
 
                 elif self.unitInAttack[i][0] == 1 and self.unit_health[i] > 0:
                     idOfE = self.unitInAttack[i][1]
                     if self.enemy_health[idOfE] <= 0:
                         reward_delta += 0.3
                         self.unitInAttack[i][0] = 0
                         self.unitInAttack[i][1] = 0
                         self.enemyInAttack[idOfE][0] = 0
                         self.enemyInAttack[idOfE][1] = 0
                         self._log_unit(
                             "MODEL",
                             modelName,
                             i,
-                            f"–¶–µ–ª—å –≤ –±–ª–∏–∂–Ω–µ–º –±–æ—é –º–µ—Ä—Ç–≤–∞ (Enemy Unit {idOfE + 11}), —é–Ω–∏—Ç –≤—ã—Ö–æ–¥–∏—Ç –∏–∑ –±–æ—è. –ü–æ–∑–∏—Ü–∏—è: {pos_before}",
+                            f"–¶–µ–ª—å –≤ –±–ª–∏–∂–Ω–µ–º –±–æ—é –º–µ—Ä—Ç–≤–∞ ({self._format_unit_label('enemy', idOfE)}), —é–Ω–∏—Ç –≤—ã—Ö–æ–¥–∏—Ç –∏–∑ –±–æ—è. –ü–æ–∑–∏—Ü–∏—è: {pos_before}",
                         )
                     else:
                         if action["attack"] == 0:
                             if self.unit_health[i] * 2 >= self.enemy_health[idOfE]:
                                 reward_delta -= 0.5
                             self._log_unit(
                                 "MODEL",
                                 modelName,
                                 i,
-                                f"–û—Ç—Å—Ç—É–ø–ª–µ–Ω–∏–µ –∏–∑ –±–æ—è —Å Enemy Unit {idOfE + 11}. –ü–æ–∑–∏—Ü–∏—è –¥–æ: {pos_before}",
+                                f"–û—Ç—Å—Ç—É–ø–ª–µ–Ω–∏–µ –∏–∑ –±–æ—è —Å {self._format_unit_label('enemy', idOfE)}. –ü–æ–∑–∏—Ü–∏—è –¥–æ: {pos_before}",
                             )
                             self.unitFellBack[i] = True
                             if battleSh is True:
                                 diceRoll = dice()
                                 if diceRoll < 3:
                                     self.unit_health[i] -= self.unit_data[i]["W"]
                             self.unit_coords[i][0] += self.unit_data[i]["Movement"]
                             self.unitInAttack[i][0] = 0
                             self.unitInAttack[i][1] = 0
                             self.enemyInAttack[idOfE][0] = 0
                             self.enemyInAttack[idOfE][1] = 0
                             pos_after = tuple(self.unit_coords[i])
                             self._log_unit("MODEL", modelName, i, f"–û—Ç—Å—Ç—É–ø–ª–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –ü–æ–∑–∏—Ü–∏—è –ø–æ—Å–ª–µ: {pos_after}")
                             if pos_before != pos_after:
                                 self._resolve_overwatch(
                                     defender_side="enemy",
                                     moving_unit_side="model",
                                     moving_idx=i,
                                     phase="movement",
                                     manual=os.getenv("MANUAL_DICE", "0") == "1",
                                 )
                         else:
                             reward_delta += 0.2
                             self._log_unit(
                                 "MODEL",
                                 modelName,
                                 i,
-                                f"–û—Å—Ç–∞—ë—Ç—Å—è –≤ –±–ª–∏–∂–Ω–µ–º –±–æ—é —Å Enemy Unit {idOfE + 11}, –¥–≤–∏–∂–µ–Ω–∏–µ –ø—Ä–æ–ø—É—â–µ–Ω–æ.",
+                                f"–û—Å—Ç–∞—ë—Ç—Å—è –≤ –±–ª–∏–∂–Ω–µ–º –±–æ—é —Å {self._format_unit_label('enemy', idOfE)}, –¥–≤–∏–∂–µ–Ω–∏–µ –ø—Ä–æ–ø—É—â–µ–Ω–æ.",
                             )
             return advanced_flags, reward_delta
 
         if side == "enemy" and manual:
             direction_map = {"up": "up", "down": "down", "left": "left", "right": "right", "none": "none"}
             normalize = {"u": "up", "d": "down", "l": "left", "r": "right", "n": "none"}
             advanced_flags = [False] * len(self.enemy_health)
             for i in range(len(self.enemy_health)):
                 playerName = i + 11
                 battleSh = battle_shock[i] if battle_shock else False
+                unit_label = self._format_unit_label("enemy", i, unit_id=playerName)
                 pos_before = tuple(self.enemy_coords[i])
                 if self.enemyInAttack[i][0] == 1 and self.enemy_health[i] > 0:
-                    fall_back = self._prompt_yes_no(f"Would you like Unit {playerName} to fallback? (y/n): ")
+                    fall_back = self._prompt_yes_no(f"{unit_label}. –û—Ç—Å—Ç—É–ø–∏—Ç—å (fallback)? (y/n): ")
                     if fall_back is None:
                         self.game_over = True
                         return None
                     if fall_back:
                         idOfE = self.enemyInAttack[i][1]
-                        self._log(f"Player Unit {playerName} fell back from Enemy unit {idOfE + 21}")
+                        self._log(f"{unit_label} –æ—Ç—Å—Ç—É–ø–∏–ª –∏–∑ –±–æ—è —Å {self._format_unit_label('model', idOfE)}")
                         self.enemyFellBack[i] = True
                         if battleSh is True:
                             diceRoll = dice()
                             if diceRoll < 3:
                                 self.enemy_health[i] -= self.enemy_data[i]["W"]
                         self.enemy_coords[i][0] += self.enemy_data[i]["Movement"]
                         self.enemyInAttack[i] = [0, 0]
                         self.unitInAttack[idOfE][0] = 0
                         self.unitInAttack[idOfE][1] = 0
                     else:
                         idOfE = self.enemyInAttack[i][1]
                         self._log(
-                            f"Player Unit {playerName} stays in combat with Model Unit {idOfE + 21} (will fight in Fight Phase)"
+                            f"{unit_label} –æ—Å—Ç–∞—ë—Ç—Å—è –≤ –±–æ—é —Å {self._format_unit_label('model', idOfE)} (–±—É–¥–µ—Ç –¥—Ä–∞—Ç—å—Å—è –≤ —Ñ–∞–∑–µ –±–æ—è)."
                         )
                     continue
 
                 if self.enemyInAttack[i][0] == 0 and self.enemy_health[i] > 0:
                     self.enemy_coords[i] = bounds(self.enemy_coords[i], self.b_len, self.b_hei)
                     for j in range(len(self.enemy_health)):
                         if self.enemy_coords[i] == self.unit_coords[j]:
                             self.enemy_coords[i][0] -= 1
 
                     self.updateBoard()
                     self.showBoard()
 
-                    self._log("Take a look at board.txt or click the Show Board button in the GUI to view the current board")
-                    self._log("If you would like to end the game type 'quit' into the prompt")
+                    self._log("–ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ board.txt –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ Show Board –≤ GUI, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –ø–æ–ª–µ.")
+                    self._log("–ß—Ç–æ–±—ã –∑–∞–≤–µ—Ä—à–∏—Ç—å –∏–≥—Ä—É, –≤–≤–µ–¥–∏—Ç–µ 'quit' –≤ –ª—é–±–æ–º –≤–æ–ø—Ä–æ—Å–µ.")
                     dire = self._prompt_choice(
-                        f"Enter the direction of movement for Unit {playerName} (up, down, left, right, none): ",
+                        f"–•–æ–¥ —é–Ω–∏—Ç–∞: {unit_label}. –í—ã–±–µ—Ä–∏—Ç–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ (up/down/left/right/none): ",
                         direction_map,
                         normalize,
                     )
                     if dire is None:
                         self.game_over = True
                         return None
 
                     advanced = False
                     move_num = 0
                     if dire != "none":
-                        adv = self._prompt_yes_no("Advance? (y/n): ")
+                        adv = self._prompt_yes_no("–°–¥–µ–ª–∞—Ç—å Advance? (y/n): ")
                         if adv is None:
                             self.game_over = True
                             return None
                         if adv:
                             advanced = True
-                            self._log("Rolling 1 D6 for Advance...")
+                            self._log("–ë—Ä–æ—Å–æ–∫ 1D6 –Ω–∞ Advance...", verbose_only=True)
                             roll = player_dice()
-                            self._log(f"You rolled a {roll}")
+                            self._log(f"–ë—Ä–æ—Å–æ–∫: {roll}", verbose_only=True)
                             movement_cap = self.enemy_data[i]["Movement"] + roll
                         else:
                             movement_cap = self.enemy_data[i]["Movement"]
                         move_num = self._prompt_int(
-                            f"How many inches would you like to move (0..{movement_cap}): ",
+                            f"–ù–∞ —Å–∫–æ–ª—å–∫–æ –¥—é–π–º–æ–≤ –¥–≤–∏–≥–∞—Ç—å—Å—è (0..{movement_cap}): ",
                             0,
                             movement_cap,
                         )
                         if move_num is None:
                             self.game_over = True
                             return None
 
                     advanced_flags[i] = advanced
                     if dire == "down":
                         self.enemy_coords[i][0] += move_num
                     elif dire == "up":
                         self.enemy_coords[i][0] -= move_num
                     elif dire == "left":
                         self.enemy_coords[i][1] -= move_num
                     elif dire == "right":
                         self.enemy_coords[i][1] += move_num
 
                     self.enemy_coords[i] = bounds(self.enemy_coords[i], self.b_len, self.b_hei)
                     for j in range(len(self.enemy_health)):
                         if self.enemy_coords[i] == self.unit_coords[j]:
                             self.enemy_coords[i][0] -= 1
 
                     self.updateBoard()
                     self.showBoard()
 
@@ -1637,510 +1693,526 @@ class Warhammer40kEnv(gym.Env):
                 if advanced and not weapon_is_assault(self.unit_weapon[i]):
                     self._log_unit("MODEL", modelName, i, "Advance –±–µ–∑ Assault ‚Äî —Å—Ç—Ä–µ–ª—å–±–∞ –ø—Ä–æ–ø—É—â–µ–Ω–∞.")
                     continue
 
                 shootAbleUnits = []
                 for j in range(len(self.enemy_health)):
                     if (
                         distance(self.unit_coords[i], self.enemy_coords[j]) <= self.unit_weapon[i]["Range"]
                         and self.enemy_health[j] > 0
                         and self.enemyInAttack[j][0] == 0
                     ):
                         shootAbleUnits.append(j)
                 if len(shootAbleUnits) > 0:
                     target_ids = [j + 11 for j in shootAbleUnits]
                     idOfE = action["shoot"]
                     if idOfE in shootAbleUnits:
                         distances = {j: distance(self.unit_coords[i], self.enemy_coords[j]) for j in shootAbleUnits}
                         closest = min(distances, key=distances.get)
                         min_hp = min(shootAbleUnits, key=lambda idx: self.enemy_health[idx])
                         if idOfE == closest:
                             reason = "—Å–∞–º–∞—è –±–ª–∏–∑–∫–∞—è"
                         elif idOfE == min_hp:
                             reason = "—Ü–µ–ª—å —Å –º–µ–Ω—å—à–∏–º HP"
                         else:
                             reason = "–≤—ã–±–æ—Ä –ø–æ–ª–∏—Ç–∏–∫–∏"
+                        target_list = self._format_unit_choices("enemy", shootAbleUnits)
                         self._log_unit(
                             "MODEL",
                             modelName,
                             i,
-                            f"–¶–µ–ª–∏ –≤ –¥–∞–ª—å–Ω–æ—Å—Ç–∏: {target_ids}, –≤—ã–±—Ä–∞–Ω–∞: {idOfE + 11} (–ø—Ä–∏—á–∏–Ω–∞: {reason})",
+                            f"–¶–µ–ª–∏ –≤ –¥–∞–ª—å–Ω–æ—Å—Ç–∏: {target_list}, –≤—ã–±—Ä–∞–Ω–∞: {self._format_unit_label('enemy', idOfE)} (–ø—Ä–∏—á–∏–Ω–∞: {reason})",
                         )
                         effect = self._maybe_use_smokescreen(
                             defender_side="enemy",
                             defender_idx=idOfE,
                             phase="shooting",
                             manual=os.getenv("MANUAL_DICE", "0") == "1",
                         )
                         _logger = None
                         if self.trunc is False and _verbose_logs_enabled():
                             _logger = RollLogger(auto_dice)
                             dmg, modHealth = attack(
                                 self.unit_health[i],
                                 self.unit_weapon[i],
                                 self.unit_data[i],
                                 self.enemy_health[idOfE],
                                 self.enemy_data[idOfE],
                                 effects=effect,
                                 distance_to_target=distance(self.unit_coords[i], self.enemy_coords[idOfE]),
                                 roller=_logger.roll,
                             )
                         else:
                             dmg, modHealth = attack(
                                 self.unit_health[i],
                                 self.unit_weapon[i],
                                 self.unit_data[i],
                                 self.enemy_health[idOfE],
                                 self.enemy_data[idOfE],
                                 effects=effect,
                                 distance_to_target=distance(self.unit_coords[i], self.enemy_coords[idOfE]),
                             )
                         self.enemy_health[idOfE] = modHealth
                         reward_delta += 0.2
                         self._log_unit(
                             "MODEL",
                             modelName,
                             i,
-                            f"–ò—Ç–æ–≥ —É—Ä–æ–Ω–∞ –ø–æ Enemy Unit {idOfE + 11}: {float(np.sum(dmg))}",
+                            f"–ò—Ç–æ–≥ —É—Ä–æ–Ω–∞ –ø–æ {self._format_unit_label('enemy', idOfE)}: {float(np.sum(dmg))}",
                         )
                         if self.trunc is False:
-                            self._log(f"Model Unit {modelName} shoots Enemy Unit {idOfE + 11} {float(np.sum(dmg))} damage")
+                            self._log(
+                                f"{self._format_unit_label('model', i)} —Å—Ç—Ä–µ–ª—è–µ—Ç –ø–æ {self._format_unit_label('enemy', idOfE)}: —É—Ä–æ–Ω {float(np.sum(dmg))}."
+                            )
                         else:
-                            self.modelUpdates += "Model Unit {} shoots Enemy Unit {} {} times\n".format(modelName, idOfE + 11, sum(dmg))
+                            self.modelUpdates += "{} —Å—Ç—Ä–µ–ª—è–µ—Ç –ø–æ {} {} —Ä–∞–∑(–∞)\n".format(
+                                self._format_unit_label("model", i),
+                                self._format_unit_label("enemy", idOfE),
+                                sum(dmg),
+                            )
                         if self.trunc is False and _logger is not None:
                             _logger.print_shoot_report(
                                 weapon=self.unit_weapon[i],
                                 attacker_data=self.unit_data[i],
                                 defender_data=self.enemy_data[idOfE],
                                 dmg_list=dmg,
                                 effect=effect,
                             )
                     else:
                         reward_delta -= 0.5
-                        target_ids = [j + 11 for j in shootAbleUnits]
+                        target_list = self._format_unit_choices("enemy", shootAbleUnits)
                         self._log_unit(
                             "MODEL",
                             modelName,
                             i,
-                            f"–¶–µ–ª–∏ –≤ –¥–∞–ª—å–Ω–æ—Å—Ç–∏: {target_ids}, –≤—ã–±—Ä–∞–Ω–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞—è {idOfE + 11}. –°—Ç—Ä–µ–ª—å–±–∞ –ø—Ä–æ–ø—É—â–µ–Ω–∞.",
+                            f"–¶–µ–ª–∏ –≤ –¥–∞–ª—å–Ω–æ—Å—Ç–∏: {target_list}, –≤—ã–±—Ä–∞–Ω–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞—è —Ü–µ–ª—å {idOfE + 11}. –°—Ç—Ä–µ–ª—å–±–∞ –ø—Ä–æ–ø—É—â–µ–Ω–∞.",
                         )
                         if self.trunc is False:
-                            self._log(f"Model Unit {modelName} fails to shoot an Enemy Unit")
+                            self._log(f"{self._format_unit_label('model', i)} –Ω–µ —Å–º–æ–≥ —Å—Ç—Ä–µ–ª—è—Ç—å: –≤—ã–±—Ä–∞–Ω–Ω–∞—è —Ü–µ–ª—å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞.")
                 else:
                     self._log_unit("MODEL", modelName, i, "–ù–µ—Ç —Ü–µ–ª–µ–π –≤ –¥–∞–ª—å–Ω–æ—Å—Ç–∏, —Å—Ç—Ä–µ–ª—å–±–∞ –ø—Ä–æ–ø—É—â–µ–Ω–∞.")
             return reward_delta
         elif side == "enemy" and manual:
             for i in range(len(self.enemy_health)):
                 playerName = i + 11
+                unit_label = self._format_unit_label("enemy", i, unit_id=playerName)
                 advanced = advanced_flags[i] if advanced_flags else False
                 if self.enemyFellBack[i]:
-                    self._log(f"Unit {playerName} Fell Back this turn ‚Äî skipping shooting")
+                    self._log(f"{unit_label}: –æ—Ç—Å—Ç—É–ø–∏–ª –≤ —ç—Ç–æ–º —Ö–æ–¥—É ‚Äî —Å—Ç—Ä–µ–ª—å–±–∞ –ø—Ä–æ–ø—É—â–µ–Ω–∞.")
                     continue
                 if self.enemy_weapon[i] != "None":
                     if advanced and not weapon_is_assault(self.enemy_weapon[i]):
-                        self._log("You advanced ‚Äî non-Assault weapon, skipping shooting")
+                        self._log(f"{unit_label}: –±—ã–ª Advance –±–µ–∑ Assault ‚Äî —Å—Ç—Ä–µ–ª—å–±–∞ –ø—Ä–æ–ø—É—â–µ–Ω–∞.")
                     else:
                         shootAble = np.array([])
                         for j in range(len(self.unit_health)):
                             if distance(self.enemy_coords[i], self.unit_coords[j]) <= self.enemy_weapon[i]["Range"] and self.unit_health[j] > 0 and self.unitInAttack[j][0] == 0:
                                 shootAble = np.append(shootAble, j)
                         if len(shootAble) > 0:
                             response = False
                             while response is False:
+                                targets_label = self._format_unit_choices("model", shootAble.astype(int).tolist())
                                 shoot = self._get_input(
-                                    "Select which enemy unit you would like to shoot ({}) with Unit {}: ".format(shootAble + 21, playerName)
+                                    f"–í—ã–±–µ—Ä–∏—Ç–µ —Ü–µ–ª—å –¥–ª—è —Å—Ç—Ä–µ–ª—å–±—ã. –°—Ç—Ä–µ–ª—è–µ—Ç: {unit_label}. –î–æ—Å—Ç—É–ø–Ω—ã–µ —Ü–µ–ª–∏: {targets_label}. –í–≤–µ–¥–∏—Ç–µ ID —Ü–µ–ª–∏: "
                                 ).strip()
                                 if shoot.lower() in ("quit", "q"):
                                     self.game_over = True
                                     return None
                                 if is_num(shoot) is True and int(shoot) - 21 in shootAble:
                                     idOfE = int(shoot) - 21
                                     effect = self._maybe_use_smokescreen(
                                         defender_side="model",
                                         defender_idx=idOfE,
                                         phase="shooting",
                                         manual=False,
                                     )
                                     logger = RollLogger(player_dice)
                                     dmg, modHealth = attack(
                                         self.enemy_health[i],
                                         self.enemy_weapon[i],
                                         self.enemy_data[i],
                                         self.unit_health[idOfE],
                                         self.unit_data[idOfE],
                                         effects=effect,
                                         distance_to_target=distance(self.enemy_coords[i], self.unit_coords[idOfE]),
                                         roller=logger.roll,
                                     )
                                     self.unit_health[idOfE] = modHealth
-                                    self._log(f"Player Unit {playerName} –Ω–∞–Ω—ë—Å {sum(dmg)} —É—Ä–æ–Ω–∞ –ø–æ Model Unit {idOfE + 21}")
+                                    self._log(
+                                        f"{unit_label} –Ω–∞–Ω—ë—Å {sum(dmg)} —É—Ä–æ–Ω–∞ –ø–æ {self._format_unit_label('model', idOfE)}"
+                                    )
                                     logger.print_shoot_report(
                                         weapon=self.enemy_weapon[i],
                                         attacker_data=self.enemy_data[i],
                                         defender_data=self.unit_data[idOfE],
                                         dmg_list=dmg,
                                         effect=effect,
                                     )
                                     response = True
                                 else:
-                                    self._log("Not an available unit")
+                                    self._log("–ù–µ–¥–æ—Å—Ç—É–ø–Ω–∞—è —Ü–µ–ª—å, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
                 else:
-                    self._log("No available weapons to shoot")
+                    self._log("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ –æ—Ä—É–∂–∏—è –¥–ª—è —Å—Ç—Ä–µ–ª—å–±—ã.")
         elif side == "enemy":
             for i in range(len(self.enemy_health)):
                 advanced = advanced_flags[i] if advanced_flags else False
                 if self.enemyFellBack[i]:
                     if self.trunc is False:
-                        self._log(f"Enemy Unit {i + 21} Fell Back ‚Äî skipping shooting")
+                        self._log(f"{self._format_unit_label('enemy', i)}: –æ—Ç—Å—Ç—É–ø–∏–ª ‚Äî —Å—Ç—Ä–µ–ª—å–±–∞ –ø—Ä–æ–ø—É—â–µ–Ω–∞.")
                     continue
                 if self.enemy_weapon[i] != "None":
                     if advanced and not weapon_is_assault(self.enemy_weapon[i]):
                         if self.trunc is False:
-                            self._log("Enemy advanced ‚Äî non-Assault weapon, skipping shooting")
+                            self._log(f"{self._format_unit_label('enemy', i)}: Advance –±–µ–∑ Assault ‚Äî —Å—Ç—Ä–µ–ª—å–±–∞ –ø—Ä–æ–ø—É—â–µ–Ω–∞.")
                     else:
                         shootAbleUnits = []
                         for j in range(len(self.unit_health)):
                             if distance(self.enemy_coords[i], self.unit_coords[j]) <= self.enemy_weapon[i]["Range"] and self.unit_health[j] > 0 and self.unitInAttack[j][0] == 0:
                                 shootAbleUnits.append(j)
                         if len(shootAbleUnits) > 0:
                             idOfM = np.random.choice(shootAbleUnits)
                             effect = self._maybe_use_smokescreen(
                                 defender_side="model",
                                 defender_idx=idOfM,
                                 phase="shooting",
                                 manual=False,
                             )
                             dmg, modHealth = attack(
                                 self.enemy_health[i],
                                 self.enemy_weapon[i],
                                 self.enemy_data[i],
                                 self.unit_health[idOfM],
                                 self.unit_data[idOfM],
                                 effects=effect,
                                 distance_to_target=distance(self.enemy_coords[i], self.unit_coords[idOfM]),
                             )
                             self.unit_health[idOfM] = modHealth
                             if self.trunc is False:
-                                self._log(f"Enemy Unit {i + 21} shoots Model Unit {idOfM + 11} {float(np.sum(dmg))} damage")
+                                self._log(
+                                    f"{self._format_unit_label('enemy', i)} —Å—Ç—Ä–µ–ª—è–µ—Ç –ø–æ {self._format_unit_label('model', idOfM)}: —É—Ä–æ–Ω {float(np.sum(dmg))}."
+                                )
         return None
 
     def charge_phase(self, side: str, advanced_flags=None, action=None, manual: bool = False):
         self.begin_phase(side, "charge")
         if side == "model":
             self._log_phase("MODEL", "charge")
             reward_delta = 0
             any_charge_targets = False
             for i in range(len(self.unit_health)):
                 modelName = i + 21
                 advanced = advanced_flags[i] if advanced_flags else False
                 pos_before = tuple(self.unit_coords[i])
                 if self.unit_health[i] <= 0:
                     self._log_unit("MODEL", modelName, i, "–Æ–Ω–∏—Ç –º–µ—Ä—Ç–≤, —á–∞—Ä–¥–∂ –ø—Ä–æ–ø—É—â–µ–Ω.")
                     continue
                 if self.unitFellBack[i]:
                     self._log_unit("MODEL", modelName, i, "Fall Back –≤ —ç—Ç–æ–º —Ö–æ–¥—É ‚Äî —á–∞—Ä–¥–∂ –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω.")
                     continue
                 if self.unitInAttack[i][0] == 1:
                     self._log_unit("MODEL", modelName, i, "–£–∂–µ –≤ –±–ª–∏–∂–Ω–µ–º –±–æ—é, —á–∞—Ä–¥–∂ –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω.")
                     continue
                 if advanced:
                     self._log_unit("MODEL", modelName, i, "Advance ‚Äî —á–∞—Ä–¥–∂ –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω.")
                 else:
                     potential_targets = []
                     for j in range(len(self.enemy_health)):
                         if distance(self.enemy_coords[j], self.unit_coords[i]) <= 12 and self.enemyInAttack[j][0] == 0 and self.enemy_health[j] > 0:
                             potential_targets.append(j)
                     if potential_targets:
                         any_charge_targets = True
                     if action["attack"] != 1:
                         if potential_targets:
-                            target_ids = [j + 11 for j in potential_targets]
+                            target_list = self._format_unit_choices("enemy", potential_targets)
                             self._log_unit(
                                 "MODEL",
                                 modelName,
                                 i,
-                                f"–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ü–µ–ª–∏ –¥–ª—è —á–∞—Ä–¥–∂–∞: {target_ids}. –†–µ—à–µ–Ω–∏–µ: –ø—Ä–æ–ø—É—Å–∫ —á–∞—Ä–¥–∂–∞.",
+                                f"–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ü–µ–ª–∏ –¥–ª—è —á–∞—Ä–¥–∂–∞: {target_list}. –†–µ—à–µ–Ω–∏–µ: –ø—Ä–æ–ø—É—Å–∫ —á–∞—Ä–¥–∂–∞.",
                             )
                         else:
                             self._log_unit("MODEL", modelName, i, "–ù–µ—Ç —Ü–µ–ª–µ–π –≤ 12\", —á–∞—Ä–¥–∂ –ø—Ä–æ–ø—É—â–µ–Ω.")
                         continue
                     chargeAble = []
                     dice_vals = dice(num=2)
                     diceRoll = sum(dice_vals)
                     if action["attack"] == 1:
                         for j in range(len(self.enemy_health)):
                             if distance(self.enemy_coords[j], self.unit_coords[i]) <= 12 and self.enemyInAttack[j][0] == 0 and self.enemy_health[j] > 0:
                                 if distance(self.enemy_coords[j], self.unit_coords[i]) - diceRoll <= 5:
                                     chargeAble.append(j)
                     if len(chargeAble) > 0:
                         idOfE = action["charge"]
-                        target_ids = [j + 11 for j in chargeAble]
+                        target_list = self._format_unit_choices("enemy", chargeAble)
                         dist_to_target = distance(self.enemy_coords[idOfE], self.unit_coords[i]) if idOfE in chargeAble else None
                         if _verbose_logs_enabled():
                             roll_text = f"–±—Ä–æ—Å–æ–∫: {dice_vals[0]} + {dice_vals[1]} = {diceRoll}"
                         else:
                             roll_text = f"–±—Ä–æ—Å–æ–∫ total={diceRoll}"
                         if idOfE in chargeAble:
                             self._log_unit_phase(
                                 "MODEL",
                                 "charge",
                                 modelName,
                                 i,
-                                f"Charge –æ–±—ä—è–≤–ª–µ–Ω –ø–æ —Ü–µ–ª–∏ Enemy Unit {idOfE + 11}. –î–∏—Å—Ç–∞–Ω—Ü–∏—è: {dist_to_target:.1f}. –ë—Ä–æ—Å–æ–∫ 2D6: {dice_vals[0]} + {dice_vals[1]} = {diceRoll}.",
+                                f"Charge –æ–±—ä—è–≤–ª–µ–Ω –ø–æ —Ü–µ–ª–∏ {self._format_unit_label('enemy', idOfE)}. –î–∏—Å—Ç–∞–Ω—Ü–∏—è: {dist_to_target:.1f}. –ë—Ä–æ—Å–æ–∫ 2D6: {dice_vals[0]} + {dice_vals[1]} = {diceRoll}.",
                             )
                             self._log_unit(
                                 "MODEL",
                                 modelName,
                                 i,
-                                f"–ß–∞—Ä–¥–∂ —Ü–µ–ª–∏: {target_ids}, –≤—ã–±—Ä–∞–Ω–∞ {idOfE + 11} (dist={dist_to_target:.1f}). {roll_text}. –†–µ–∑—É–ª—å—Ç–∞—Ç: —É—Å–ø–µ—Ö.",
+                                f"–ß–∞—Ä–¥–∂ —Ü–µ–ª–∏: {target_list}, –≤—ã–±—Ä–∞–Ω–∞ {self._format_unit_label('enemy', idOfE)} (dist={dist_to_target:.1f}). {roll_text}. –†–µ–∑—É–ª—å—Ç–∞—Ç: —É—Å–ø–µ—Ö.",
                             )
                             self.unitInAttack[i][0] = 1
                             self.unitInAttack[i][1] = idOfE
                             self.unit_coords[i][0] = self.enemy_coords[idOfE][0] + 1
                             self.unit_coords[i][1] = self.enemy_coords[idOfE][1] + 1
                             self.unit_coords[i] = bounds(self.unit_coords[i], self.b_len, self.b_hei)
                             self.enemyInAttack[idOfE][0] = 1
                             self.enemyInAttack[idOfE][1] = i
                             self.unitCharged[i] = 1
                             pos_after = tuple(self.unit_coords[i])
                             self._log_unit_phase(
                                 "MODEL",
                                 "charge",
                                 modelName,
                                 i,
-                                f"Charge move: from {pos_before} -> {pos_after}, ended_in_engagement={self.unitInAttack[i][0] == 1}.",
+                                f"–î–≤–∏–∂–µ–Ω–∏–µ —á–∞—Ä–¥–∂–∞: {pos_before} -> {pos_after}, –≤ –∫–æ–Ω—Ç–∞–∫—Ç–µ={self.unitInAttack[i][0] == 1}.",
                             )
                             # 10e: Heroic Intervention –¥–æ—Å—Ç—É–ø–µ–Ω –∑–∞—â–∏—Ç–Ω–∏–∫—É –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ charge move.
                             self._resolve_heroic_intervention(
                                 defender_side="enemy",
                                 charging_side="model",
                                 charging_idx=i,
                                 phase="charge",
                                 manual=os.getenv("MANUAL_DICE", "0") == "1",
                             )
                             reward_delta += 0.5
                         else:
                             reason = "—Ü–µ–ª—å –≤–Ω–µ –¥–æ—Å—è–≥–∞–µ–º–æ—Å—Ç–∏" if idOfE in potential_targets else "—Ü–µ–ª—å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞"
                             if idOfE in potential_targets:
                                 dist_to_target = distance(self.enemy_coords[idOfE], self.unit_coords[i])
                                 self._log_unit_phase(
                                     "MODEL",
                                     "charge",
                                     modelName,
                                     i,
-                                    f"Charge –æ–±—ä—è–≤–ª–µ–Ω –ø–æ —Ü–µ–ª–∏ Enemy Unit {idOfE + 11}. –î–∏—Å—Ç–∞–Ω—Ü–∏—è: {dist_to_target:.1f}. –ë—Ä–æ—Å–æ–∫ 2D6: {dice_vals[0]} + {dice_vals[1]} = {diceRoll}.",
+                                    f"Charge –æ–±—ä—è–≤–ª–µ–Ω –ø–æ —Ü–µ–ª–∏ {self._format_unit_label('enemy', idOfE)}. –î–∏—Å—Ç–∞–Ω—Ü–∏—è: {dist_to_target:.1f}. –ë—Ä–æ—Å–æ–∫ 2D6: {dice_vals[0]} + {dice_vals[1]} = {diceRoll}.",
                                 )
+                            target_list = self._format_unit_choices("enemy", potential_targets)
                             self._log_unit(
                                 "MODEL",
                                 modelName,
                                 i,
-                                f"–ß–∞—Ä–¥–∂ —Ü–µ–ª–∏: {target_ids}, –≤—ã–±—Ä–∞–Ω–∞ {idOfE + 11}. {roll_text}. –†–µ–∑—É–ª—å—Ç–∞—Ç: –ø—Ä–æ–≤–∞–ª ({reason}).",
+                                f"–ß–∞—Ä–¥–∂ —Ü–µ–ª–∏: {target_list}, –≤—ã–±—Ä–∞–Ω–∞ {self._format_unit_label('enemy', idOfE)}. {roll_text}. –†–µ–∑—É–ª—å—Ç–∞—Ç: –ø—Ä–æ–≤–∞–ª ({reason}).",
                             )
                             reward_delta -= 0.5
                     else:
                         if potential_targets:
-                            target_ids = [j + 11 for j in potential_targets]
+                            target_list = self._format_unit_choices("enemy", potential_targets)
                             if _verbose_logs_enabled():
                                 roll_text = f"–±—Ä–æ—Å–æ–∫: {dice_vals[0]} + {dice_vals[1]} = {diceRoll}"
                             else:
                                 roll_text = f"–±—Ä–æ—Å–æ–∫ total={diceRoll}"
                             self._log_unit(
                                 "MODEL",
                                 modelName,
                                 i,
-                                f"–¶–µ–ª–∏ –≤ 12\": {target_ids}. {roll_text}. –ù–µ—Ç –¥–æ—Å—Ç–∏–∂–∏–º—ã—Ö —Ü–µ–ª–µ–π.",
+                                f"–¶–µ–ª–∏ –≤ 12\": {target_list}. {roll_text}. –ù–µ—Ç –¥–æ—Å—Ç–∏–∂–∏–º—ã—Ö —Ü–µ–ª–µ–π.",
                             )
                         else:
                             self._log_unit("MODEL", modelName, i, "–ù–µ—Ç —Ü–µ–ª–µ–π –≤ 12\", —á–∞—Ä–¥–∂ –ø—Ä–æ–ø—É—â–µ–Ω.")
             if not any_charge_targets:
                 self._log("[MODEL] –ß–∞—Ä–¥–∂: –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ü–µ–ª–µ–π")
             return reward_delta
         elif side == "enemy" and manual:
             any_chargeable = False
             battle_shock = getattr(self, "_manual_enemy_battle_shock", None)
             for i in range(len(self.enemy_health)):
                 playerName = i + 11
+                unit_label = self._format_unit_label("enemy", i, unit_id=playerName)
                 advanced = advanced_flags[i] if advanced_flags else False
                 pos_before = tuple(self.enemy_coords[i])
                 if self.enemyFellBack[i]:
-                    self._log(f"Unit {playerName} Fell Back this turn ‚Äî skipping charge")
+                    self._log(f"{unit_label}: –æ—Ç—Å—Ç—É–ø–∏–ª –≤ —ç—Ç–æ–º —Ö–æ–¥—É ‚Äî —á–∞—Ä–¥–∂ –ø—Ä–æ–ø—É—â–µ–Ω.")
                     continue
                 if advanced:
-                    self._log("You advanced ‚Äî cannot charge, skipping charge")
+                    self._log(f"{unit_label}: –±—ã–ª Advance ‚Äî —á–∞—Ä–¥–∂ –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω.")
                     continue
                 charg = np.array([])
                 for j in range(len(self.unit_health)):
                     if distance(self.unit_coords[j], self.enemy_coords[i]) <= 12 and self.unitInAttack[j][0] == 0 and self.unit_health[j] > 0:
                         charg = np.append(charg, j)
                 if len(charg) > 0:
                     any_chargeable = True
-                    want_charge = self._prompt_yes_no(f"Would you like Unit {playerName} to charge? (y/n): ")
+                    want_charge = self._prompt_yes_no(f"{unit_label}. –û–±—ä—è–≤–∏—Ç—å —á–∞—Ä–¥–∂? (y/n): ")
                     if want_charge is None:
                         self.game_over = True
                         return None
                     if not want_charge:
-                        self._log(f"Player Unit {playerName} decided to skip charge")
+                        self._log(f"{unit_label} —Ä–µ—à–∏–ª –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å —á–∞—Ä–¥–∂.")
                         continue
                     response = False
                     while response is False:
+                        targets_label = self._format_unit_choices("model", charg.astype(int).tolist())
                         attk = self._get_input(
-                            "Select which enemy you would like to charge ({}) with Unit {}: ".format(charg + 21, playerName)
+                            f"–í—ã–±–µ—Ä–∏—Ç–µ —Ü–µ–ª—å –¥–ª—è —á–∞—Ä–¥–∂–∞. –î–æ—Å—Ç—É–ø–Ω—ã–µ —Ü–µ–ª–∏: {targets_label}. –í–≤–µ–¥–∏—Ç–µ ID —Ü–µ–ª–∏: "
                         ).strip()
                         if attk.lower() in ("quit", "q"):
                             self.game_over = True
                             return None
                         if is_num(attk) is True and int(attk) - 21 in charg:
                             response = True
                             j = int(attk) - 21
-                            self._log("Rolling 2 D6...")
+                            self._log("–ë—Ä–æ—Å–æ–∫ 2D6...", verbose_only=True)
                             roll = player_dice(num=2)
-                            self._log(f"You rolled a {roll[0]} and {roll[1]}")
+                            self._log(f"–ë—Ä–æ—Å–æ–∫: {roll[0]} –∏ {roll[1]}", verbose_only=True)
                             dist_to_target = distance(self.enemy_coords[i], self.unit_coords[j])
                             self._log_unit_phase(
                                 self._side_label("enemy", manual=True),
                                 "charge",
                                 playerName,
                                 i,
-                                f"Charge –æ–±—ä—è–≤–ª–µ–Ω –ø–æ —Ü–µ–ª–∏ Model Unit {j + 21}. –î–∏—Å—Ç–∞–Ω—Ü–∏—è: {dist_to_target:.1f}. –ë—Ä–æ—Å–æ–∫ 2D6: {roll[0]} + {roll[1]} = {sum(roll)}.",
+                                f"Charge –æ–±—ä—è–≤–ª–µ–Ω –ø–æ —Ü–µ–ª–∏ {self._format_unit_label('model', j)}. –î–∏—Å—Ç–∞–Ω—Ü–∏—è: {dist_to_target:.1f}. –ë—Ä–æ—Å–æ–∫ 2D6: {roll[0]} + {roll[1]} = {sum(roll)}.",
                             )
                             if distance(self.enemy_coords[i], self.unit_coords[j]) - sum(roll) <= 5:
-                                self._log(f"Player Unit {playerName} Successfully charged Model Unit {j + 21}")
+                                self._log(f"{unit_label} —É—Å–ø–µ—à–Ω–æ –∑–∞—á–∞—Ä–¥–∂–∏–ª {self._format_unit_label('model', j)}")
                                 self.enemyInAttack[i][0] = 1
                                 self.enemyInAttack[i][1] = j
                                 self.enemy_coords[i][0] = self.unit_coords[j][0] + 1
                                 self.enemy_coords[i][1] = self.unit_coords[j][1] + 1
                                 self.enemy_coords[i] = bounds(self.enemy_coords[i], self.b_len, self.b_hei)
                                 self.enemyCharged[i] = 1
                                 self.updateBoard()
                                 self.unitInAttack[j][0] = 1
                                 self.unitInAttack[j][1] = i
                                 pos_after = tuple(self.enemy_coords[i])
                                 self._log_unit_phase(
                                     self._side_label("enemy", manual=True),
                                     "charge",
                                     playerName,
                                     i,
-                                    f"Charge move: from {pos_before} -> {pos_after}, ended_in_engagement={self.enemyInAttack[i][0] == 1}.",
+                                    f"–î–≤–∏–∂–µ–Ω–∏–µ —á–∞—Ä–¥–∂–∞: {pos_before} -> {pos_after}, –≤ –∫–æ–Ω—Ç–∞–∫—Ç–µ={self.enemyInAttack[i][0] == 1}.",
                                 )
                                 # 10e: Heroic Intervention –¥–æ—Å—Ç—É–ø–µ–Ω –∑–∞—â–∏—Ç–Ω–∏–∫—É –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ charge move.
                                 self._resolve_heroic_intervention(
                                     defender_side="model",
                                     charging_side="enemy",
                                     charging_idx=i,
                                     phase="charge",
                                     manual=False,
                                 )
                             else:
-                                self._log(f"Player Unit {playerName} Failed to charge Model Unit {j + 21}")
+                                self._log(f"{unit_label} –Ω–µ —Å–º–æ–≥ –∑–∞—á–∞—Ä–¥–∂–∏—Ç—å {self._format_unit_label('model', j)}")
                         else:
-                            self._log("Not an available unit")
+                            self._log("–ù–µ–¥–æ—Å—Ç—É–ø–Ω–∞—è —Ü–µ–ª—å.")
             if not any_chargeable:
-                self._log("No available units to charge")
+                self._log("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ü–µ–ª–µ–π –¥–ª—è —á–∞—Ä–¥–∂–∞.")
         elif side == "enemy":
             for i in range(len(self.enemy_health)):
                 advanced = advanced_flags[i] if advanced_flags else False
                 pos_before = tuple(self.enemy_coords[i])
                 if self.enemyFellBack[i]:
                     if self.trunc is False:
-                        self._log("Enemy Fell Back ‚Äî cannot charge, skipping charge")
+                        self._log(f"{self._format_unit_label('enemy', i)}: –æ—Ç—Å—Ç—É–ø–∏–ª ‚Äî —á–∞—Ä–¥–∂ –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω.")
                     continue
                 if advanced:
                     if self.trunc is False:
-                        self._log("Enemy advanced ‚Äî cannot charge, skipping charge")
+                        self._log(f"{self._format_unit_label('enemy', i)}: –±—ã–ª Advance ‚Äî —á–∞—Ä–¥–∂ –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω.")
                 else:
                     chargeAble = []
                     diceRoll = sum(dice(num=2))
                     for j in range(len(self.unit_health)):
                         if distance(self.enemy_coords[i], self.unit_coords[j]) <= 12 and self.unitInAttack[j][0] == 0:
                             if distance(self.enemy_coords[i], self.unit_coords[j]) - diceRoll <= 5:
                                 chargeAble.append(j)
                     if len(chargeAble) > 0:
                         idOfM = int(np.random.choice(chargeAble))
                         dist = distance(self.enemy_coords[i], self.unit_coords[idOfM])
                         required = max(0, dist - 1)
                         self._log_unit_phase(
                             "ENEMY",
                             "charge",
                             i + 21,
                             i,
-                            f"Charge –æ–±—ä—è–≤–ª–µ–Ω –ø–æ —Ü–µ–ª–∏ Model Unit {idOfM + 11}. –î–∏—Å—Ç–∞–Ω—Ü–∏—è: {dist:.1f}. –ë—Ä–æ—Å–æ–∫ 2D6: {diceRoll}.",
+                            f"Charge –æ–±—ä—è–≤–ª–µ–Ω –ø–æ —Ü–µ–ª–∏ {self._format_unit_label('model', idOfM)}. –î–∏—Å—Ç–∞–Ω—Ü–∏—è: {dist:.1f}. –ë—Ä–æ—Å–æ–∫ 2D6: {diceRoll}.",
                         )
                         if diceRoll >= required:
                             if self.trunc is False:
                                 self._log(
-                                    f"Enemy unit {i + 21} successfully charged Model unit {idOfM + 11} (roll {diceRoll} vs need {required:.1f})"
+                                    f"{self._format_unit_label('enemy', i)} —É—Å–ø–µ—à–Ω–æ –∑–∞—á–∞—Ä–¥–∂–∏–ª {self._format_unit_label('model', idOfM)} (–±—Ä–æ—Å–æ–∫ {diceRoll} vs –Ω—É–∂–Ω–æ {required:.1f})"
                                 )
                             self.enemy_coords[i][0] = self.unit_coords[idOfM][0] + 1
                             self.enemy_coords[i][1] = self.unit_coords[idOfM][1]
                             self.enemy_coords[i] = bounds(self.enemy_coords[i], self.b_len, self.b_hei)
                             self.enemyInAttack[i][0] = 1
                             self.enemyInAttack[i][1] = idOfM
                             self.unitInAttack[idOfM][0] = 1
                             self.unitInAttack[idOfM][1] = i
                             self.enemyCharged[i] = 1
                             pos_after = tuple(self.enemy_coords[i])
                             self._log_unit_phase(
                                 "ENEMY",
                                 "charge",
                                 i + 21,
                                 i,
                                 f"Charge move: from {pos_before} -> {pos_after}, ended_in_engagement={self.enemyInAttack[i][0] == 1}.",
                             )
                             # 10e: Heroic Intervention –¥–æ—Å—Ç—É–ø–µ–Ω –∑–∞—â–∏—Ç–Ω–∏–∫—É –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ charge move.
                             self._resolve_heroic_intervention(
                                 defender_side="model",
                                 charging_side="enemy",
                                 charging_idx=i,
                                 phase="charge",
                                 manual=False,
                             )
                         elif self.trunc is False:
                             self._log(
-                                f"Enemy unit {i + 21} failed charge vs Model unit {idOfM + 11} (roll {diceRoll} vs need {required:.1f})"
+                                f"{self._format_unit_label('enemy', i)} –Ω–µ —Å–º–æ–≥ –∑–∞—á–∞—Ä–¥–∂–∏—Ç—å {self._format_unit_label('model', idOfM)} (–±—Ä–æ—Å–æ–∫ {diceRoll} vs –Ω—É–∂–Ω–æ {required:.1f})"
                             )
         return None
 
     def fight_phase(self, side: str):
         self.begin_phase(side, "fight")
         if side == "model":
             self._log_phase("MODEL", "fight")
             engaged_model = [i for i in range(len(self.unit_health)) if self.unit_health[i] > 0 and self.unitInAttack[i][0] == 1]
             engaged_enemy = [i for i in range(len(self.enemy_health)) if self.enemy_health[i] > 0 and self.enemyInAttack[i][0] == 1]
             if not engaged_model and not engaged_enemy:
                 self._log("[MODEL] –ë–ª–∏–∂–Ω–∏–π –±–æ–π: –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∞—Ç–∞–∫")
             else:
-                model_ids = [i + 21 for i in engaged_model]
-                enemy_ids = [i + 11 for i in engaged_enemy]
-                self._log(f"[MODEL] –ë–ª–∏–∂–Ω–∏–π –±–æ–π: —É—á–∞—Å—Ç–≤—É—é—Ç Model units {model_ids}, Enemy units {enemy_ids}")
+                model_list = self._format_unit_choices("model", engaged_model)
+                enemy_list = self._format_unit_choices("enemy", engaged_enemy)
+                self._log(f"[MODEL] –ë–ª–∏–∂–Ω–∏–π –±–æ–π: —É—á–∞—Å—Ç–≤—É—é—Ç {model_list}; –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∏ {enemy_list}")
                 for idx in engaged_model:
                     def_idx = self.unitInAttack[idx][1]
                     if 0 <= def_idx < len(self.enemy_health):
                         self._log_unit(
                             "MODEL",
                             idx + 21,
                             idx,
-                            f"–í –±–æ—é —Å Enemy Unit {def_idx + 11}",
+                            f"–í –±–æ—é —Å {self._format_unit_label('enemy', def_idx)}",
                         )
         self.resolve_fight_phase(active_side=side, trunc=self.trunc)
 
     def refresh_objective_control(self):
         self.model_obj_oc = np.zeros(len(self.coordsOfOM), dtype=int)
         self.enemy_obj_oc = np.zeros(len(self.coordsOfOM), dtype=int)
 
         for i in range(len(self.unit_health)):
             if self.unit_health[i] <= 0:
                 continue
             wounds = self.unit_data[i]["W"]
             remaining_models = (self.unit_health[i] + wounds - 1) // wounds
             effective_oc = self.modelOC[i] * remaining_models
             if effective_oc <= 0:
                 continue
             for j in range(len(self.coordsOfOM)):
                 if distance(self.coordsOfOM[j], self.unit_coords[i]) <= 5:
                     self.model_obj_oc[j] += effective_oc
 
         for i in range(len(self.enemy_health)):
             if self.enemy_health[i] <= 0:
                 continue
             wounds = self.enemy_data[i]["W"]
             remaining_models = (self.enemy_health[i] + wounds - 1) // wounds
             effective_oc = self.enemyOC[i] * remaining_models
@@ -2254,158 +2326,162 @@ class Warhammer40kEnv(gym.Env):
         dice_fn = player_dice if os.getenv("MANUAL_DICE", "0") == "1" else auto_dice
 
         def _log(msg: str):
             if quiet is False:
                 self._log(msg)
 
         def _do_melee(att_side: str, att_idx: int):
             """
             att_side: "model" (self.unit_*) or "enemy" (self.enemy_*)
             att_idx: index in corresponding arrays
             """
             # –ø—Ä–æ–≤–µ—Ä–∫–∞ –∂–∏–≤/–≤ –±–æ—é
             if att_side == "model":
                 if self.unit_health[att_idx] <= 0 or self.unitInAttack[att_idx][0] != 1:
                     return False
                 def_idx = self.unitInAttack[att_idx][1]
                 if def_idx < 0 or def_idx >= len(self.enemy_health) or self.enemy_health[def_idx] <= 0:
                     # —Ü–µ–ª—å –º–µ—Ä—Ç–≤–∞/–Ω–µ–≤–∞–ª–∏–¥–Ω–∞ ‚Äî —Å–Ω–∏–º–∞–µ–º –±–æ–π
                     self.unitInAttack[att_idx] = [0, 0]
                     return False
                 self._log_unit_phase(
                     "MODEL",
                     "fight",
                     att_idx + 21,
                     att_idx,
-                    f"–í—ã–±—Ä–∞–Ω –¥–ª—è –∞—Ç–∞–∫–∏. –¶–µ–ª—å: Enemy Unit {def_idx + 11}.",
+                    f"–í—ã–±—Ä–∞–Ω –¥–ª—è –∞—Ç–∞–∫–∏. –¶–µ–ª—å: {self._format_unit_label('enemy', def_idx)}.",
                 )
 
                 weapon = self.unit_melee[att_idx]
                 attacker_data = self.unit_data[att_idx]
                 defender_data = self.enemy_data[def_idx]
                 hp_before = self.enemy_health[def_idx]
 
                 _logger = None
                 if quiet is False and _verbose_logs_enabled():
                     _logger = RollLogger(auto_dice)
                     _logger.configure_for_weapon(weapon)
                     dmg, modHealth = attack(
                         self.unit_health[att_idx],
                         weapon,
                         attacker_data,
                         self.enemy_health[def_idx],
                         defender_data,
                         rangeOfComb="Melee",
                         roller=_logger.roll,
                     )
                 else:
                     dmg, modHealth = attack(
                         self.unit_health[att_idx],
                         weapon,
                         attacker_data,
                         self.enemy_health[def_idx],
                         defender_data,
                         rangeOfComb="Melee",
                     )
 
                 self.enemy_health[def_idx] = modHealth
 
                 wname = weapon.get("Name", "Melee") if isinstance(weapon, dict) else str(weapon)
-                _log(f"‚öîÔ∏è Model Unit {att_idx + 21} fights Enemy Unit {def_idx + 11} with {wname}: dmg {float(np.sum(dmg))} | HP {hp_before} -> {modHealth}")
+                _log(
+                    f"‚öîÔ∏è {self._format_unit_label('model', att_idx)} –∞—Ç–∞–∫—É–µ—Ç {self._format_unit_label('enemy', def_idx)} –æ—Ä—É–∂–∏–µ–º {wname}: —É—Ä–æ–Ω {float(np.sum(dmg))} | HP {hp_before} -> {modHealth}"
+                )
                 self._log_unit_phase(
                     "MODEL",
                     "fight",
                     att_idx + 21,
                     att_idx,
                     f"–ò—Ç–æ–≥ –∞—Ç–∞–∫–∏: —É—Ä–æ–Ω {float(np.sum(dmg))}, HP —Ü–µ–ª–∏ {hp_before} -> {modHealth}.",
                 )
 
                 # –µ—Å–ª–∏ —É —Ç–µ–±—è —É–∂–µ –µ—Å—Ç—å print_melee_report ‚Äî –º–æ–∂–Ω–æ –≤–∫–ª—é—á–∏—Ç—å:
                 if quiet is False and _logger is not None and hasattr(_logger, "print_melee_report"):
                     _logger.print_melee_report(
                         weapon=weapon,
                         attacker_data=attacker_data,
                         defender_data=defender_data,
                         dmg_list=dmg,
                         effect=None,
                     )
 
                 # –µ—Å–ª–∏ —Ü–µ–ª—å —É–º–µ—Ä–ª–∞ ‚Äî —Å–Ω–∏–º–∞–µ–º ‚Äú–≤ –±–æ—é‚Äù —Å –æ–±–µ–∏—Ö —Å—Ç–æ—Ä–æ–Ω
                 if self.enemy_health[def_idx] <= 0:
                     self.enemyInAttack[def_idx] = [0, 0]
                     self.unitInAttack[att_idx] = [0, 0]
 
                 return True
 
             else:  # att_side == "enemy"
                 if self.enemy_health[att_idx] <= 0 or self.enemyInAttack[att_idx][0] != 1:
                     return False
                 def_idx = self.enemyInAttack[att_idx][1]
                 if def_idx < 0 or def_idx >= len(self.unit_health) or self.unit_health[def_idx] <= 0:
                     self.enemyInAttack[att_idx] = [0, 0]
                     return False
                 enemy_label = self._side_label("enemy", manual=os.getenv("MANUAL_DICE", "0") == "1")
                 self._log_unit_phase(
                     enemy_label,
                     "fight",
                     att_idx + 11,
                     att_idx,
-                    f"–í—ã–±—Ä–∞–Ω –¥–ª—è –∞—Ç–∞–∫–∏. –¶–µ–ª—å: Model Unit {def_idx + 21}.",
+                    f"–í—ã–±—Ä–∞–Ω –¥–ª—è –∞—Ç–∞–∫–∏. –¶–µ–ª—å: {self._format_unit_label('model', def_idx)}.",
                 )
 
                 weapon = self.enemy_melee[att_idx]
                 attacker_data = self.enemy_data[att_idx]
                 defender_data = self.unit_data[def_idx]
                 hp_before = self.unit_health[def_idx]
 
                 _logger = None
                 if quiet is False and _verbose_logs_enabled():
                     _logger = RollLogger(dice_fn)
                     _logger.configure_for_weapon(weapon)
                     dmg, modHealth = attack(
                         self.enemy_health[att_idx],
                         weapon,
                         attacker_data,
                         self.unit_health[def_idx],
                         defender_data,
                         rangeOfComb="Melee",
                         roller=_logger.roll,
                     )
                 else:
                     dmg, modHealth = attack(
                         self.enemy_health[att_idx],
                         weapon,
                         attacker_data,
                         self.unit_health[def_idx],
                         defender_data,
                         rangeOfComb="Melee",
                     )
 
                 self.unit_health[def_idx] = modHealth
 
                 wname = weapon.get("Name", "Melee") if isinstance(weapon, dict) else str(weapon)
-                _log(f"‚öîÔ∏è Enemy Unit {att_idx + 11} fights Model Unit {def_idx + 21} with {wname}: dmg {float(np.sum(dmg))} | HP {hp_before} -> {modHealth}")
+                _log(
+                    f"‚öîÔ∏è {self._format_unit_label('enemy', att_idx)} –∞—Ç–∞–∫—É–µ—Ç {self._format_unit_label('model', def_idx)} –æ—Ä—É–∂–∏–µ–º {wname}: —É—Ä–æ–Ω {float(np.sum(dmg))} | HP {hp_before} -> {modHealth}"
+                )
                 self._log_unit_phase(
                     enemy_label,
                     "fight",
                     att_idx + 11,
                     att_idx,
                     f"–ò—Ç–æ–≥ –∞—Ç–∞–∫–∏: —É—Ä–æ–Ω {float(np.sum(dmg))}, HP —Ü–µ–ª–∏ {hp_before} -> {modHealth}.",
                 )
 
                 if quiet is False and _logger is not None and hasattr(_logger, "print_melee_report"):
                     _logger.print_melee_report(
                         weapon=weapon,
                         attacker_data=attacker_data,
                         defender_data=defender_data,
                         dmg_list=dmg,
                         effect=None,
                     )
 
                 if self.unit_health[def_idx] <= 0:
                     self.unitInAttack[def_idx] = [0, 0]
                     self.enemyInAttack[att_idx] = [0, 0]
 
                 return True
 
         # –µ—Å—Ç—å –ª–∏ –≤–æ–æ–±—â–µ –∫–æ–º—É –¥—Ä–∞—Ç—å—Å—è?
         any_fight = any(x[0] == 1 for x in self.unitInAttack) or any(x[0] == 1 for x in self.enemyInAttack)
@@ -2502,558 +2578,593 @@ class Warhammer40kEnv(gym.Env):
 
         if game_over:
             res = 4
             if winner == "model":
                 reward += 2
             elif winner == "enemy":
                 reward -= 2
 
         self._advance_turn_order()
         if self.game_over and res == 0:
             res = 4
 
         self.iter += 1
         info = self.get_info()
         return self._get_observation(), reward, self.game_over, res, info
 
     # for a real person playing
     def player(self):
         self.enemyCP += 1
         self.modelCP += 1
 
         if self.playType is False:
             print(self.get_info())
         else:
             info = self.get_info()
-            moreInfo = "Model Unit Health: {}, Player Unit Health: {}\nModel CP: {}, Player CP: {}\nModel VP: {}, Player VP: {}\n".format(
-                info["model health"], info["player health"], info["modelCP"], info["playerCP"], info["model VP"], info["player VP"]
+            moreInfo = "–ó–¥–æ—Ä–æ–≤—å–µ MODEL: {}, –∑–¥–æ—Ä–æ–≤—å–µ PLAYER: {}\nCP MODEL: {}, CP PLAYER: {}\nVP MODEL: {}, VP PLAYER: {}\n".format(
+                info["model health"],
+                info["player health"],
+                info["modelCP"],
+                info["playerCP"],
+                info["model VP"],
+                info["player VP"],
             )
 
         if self.playType is not False:
             if self.modelUpdates != "":
-                sendToGUI(moreInfo + self.modelUpdates + "\nWould you like to continue: ")
+                sendToGUI(moreInfo + self.modelUpdates + "\n–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å? (y/n): ")
             else:
-                sendToGUI(moreInfo + "\nWould you like to continue: ")
+                sendToGUI(moreInfo + "\n–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å? (y/n): ")
             ans = recieveGUI()
             response = False
             while response is False:
                 if ans.lower() in ("y", "yes"):
                     response = True
                     self.modelUpdates = ""
                 elif ans.lower() in ("n", "no"):
                     self.game_over = True
                     info = self.get_info
                     return self.game_over, info
                 else:
-                    sendToGUI("Its a yes or no question dude...: ")
+                    sendToGUI("–í–≤–µ–¥–∏—Ç–µ y/yes –∏–ª–∏ n/no: ")
                     ans = recieveGUI()
 
         for i in range(len(self.enemy_health)):
             playerName = i + 11
+            unit_label = self._format_unit_label("enemy", i, unit_id=playerName)
             pos_before = tuple(self.enemy_coords[i])
             if self.playType is False:
-                print("For unit", playerName)
+                print("–Æ–Ω–∏—Ç:", unit_label)
             else:
-                sendToGUI("For unit {}".format(playerName))
+                sendToGUI("–Æ–Ω–∏—Ç: {}".format(unit_label))
 
             battleSh = False
             if isBelowHalfStr(self.enemy_data[i], self.enemy_health[i]) is True and self.unit_health[i] > 0:
                 if self.playType is False:
-                    print("This unit is Battle-shocked, starting test...")
-                    print("Rolling 2D6...")
+                    print(f"{unit_label}: –Ω–∏–∂–µ –ø–æ–ª–æ–≤–∏–Ω—ã —Å–æ—Å—Ç–∞–≤–∞, —Ç–µ—Å—Ç Battle-shock.")
+                    print("–ë—Ä–æ—Å–æ–∫ 2D6...")
                     diceRoll = player_dice(num=2)
-                    print("You rolled", diceRoll[0], diceRoll[1])
+                    print("–ë—Ä–æ—Å–æ–∫:", diceRoll[0], diceRoll[1])
                 else:
                     diceRoll = player_dice(num=2)
-                    sendToGUI("This unit is Battle-shocked, starting test...\nRolling 2D6...\nYou rolled: {} and {}".format(diceRoll[0], diceRoll[1]))
+                    sendToGUI(
+                        f"{unit_label}: –Ω–∏–∂–µ –ø–æ–ª–æ–≤–∏–Ω—ã —Å–æ—Å—Ç–∞–≤–∞, —Ç–µ—Å—Ç Battle-shock.\n–ë—Ä–æ—Å–æ–∫ 2D6...\n–†–µ–∑—É–ª—å—Ç–∞—Ç: {diceRoll[0]} –∏ {diceRoll[1]}"
+                    )
 
                 if sum(diceRoll) >= self.enemy_data[i]["Ld"]:
                     if self.playType is False:
-                        print("Battle-shock test passed!")
+                        print("–¢–µ—Å—Ç Battle-shock –ø—Ä–æ–π–¥–µ–Ω.")
                     else:
-                        sendToGUI("Battle-shock test passed!")
+                        sendToGUI("–¢–µ—Å—Ç Battle-shock –ø—Ä–æ–π–¥–µ–Ω.")
                     self.enemyOC[i] = self.enemy_data[i]["OC"]
                 else:
                     battleSh = True
                     if self.playType is False:
-                        print("Battle-shock test failed")
+                        print("–¢–µ—Å—Ç Battle-shock –ø—Ä–æ–≤–∞–ª–µ–Ω.")
                     else:
-                        sendToGUI("Battle-shock test failed")
+                        sendToGUI("–¢–µ—Å—Ç Battle-shock –ø—Ä–æ–≤–∞–ª–µ–Ω.")
 
                     response = False
                     self.enemyOC[i] = 0
                     if self.enemyCP - 1 >= 0:
                         if self.playType is False:
-                            strat = input("Would you like to use the Insane Bravery Strategem? (y/n): ")
+                            strat = input("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å—Ç—Ä–∞—Ç–∞–≥–µ–º—É Insane Bravery (1 CP)? (y/n): ")
                         else:
-                            sendToGUI("Would you like to use the Insane Bravery Strategem for Unit {}? (y/n): ".format(playerName))
+                            sendToGUI(f"{unit_label}. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å—Ç—Ä–∞—Ç–∞–≥–µ–º—É Insane Bravery (1 CP)? (y/n): ")
                             strat = recieveGUI()
 
                         while response is False:
                             if strat.lower() in ("y", "yes"):
                                 response = True
                                 battleSh = False
                                 self.enemyCP -= 1
                                 self.enemyOC[i] = self.enemy_data[i]["OC"]
                             elif strat.lower() in ("n", "no"):
                                 response = True
                             elif strat.lower() == "quit":
                                 self.game_over = True
                                 info = self.get_info()
                                 return self.game_over, info
                             elif strat.lower() in ("?", "help"):
                                 if self.playType is False:
-                                    print("The Insane Bravery Stratagem costs 1 CP and is used when a unit fails a Battle-Shock Test. If used it treats the unit as if it passed.")
-                                    strat = input("Would you like to use the Insane Bravery Stratagem? (y/n): ")
+                                    print(
+                                        "Insane Bravery —Å—Ç–æ–∏—Ç 1 CP –∏ –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è, –∫–æ–≥–¥–∞ —é–Ω–∏—Ç –ø—Ä–æ–≤–∞–ª–∏–ª —Ç–µ—Å—Ç Battle-shock. –ü—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ —Ç–µ—Å—Ç —Å—á–∏—Ç–∞–µ—Ç—Å—è –ø—Ä–æ–π–¥–µ–Ω–Ω—ã–º."
+                                    )
+                                    strat = input("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å—Ç—Ä–∞—Ç–∞–≥–µ–º—É Insane Bravery? (y/n): ")
                                 else:
-                                    sendToGUI("The Insane Bravery Stratagem costs 1 CP and is used when a unit fails a Battle-Shock Test. If used it treats the unit as if it passed.\nWould you like to use the Insane Bravery Stratagem? (y/n): ")
+                                    sendToGUI(
+                                        "Insane Bravery —Å—Ç–æ–∏—Ç 1 CP –∏ –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è, –∫–æ–≥–¥–∞ —é–Ω–∏—Ç –ø—Ä–æ–≤–∞–ª–∏–ª —Ç–µ—Å—Ç Battle-shock. –ü—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ —Ç–µ—Å—Ç —Å—á–∏—Ç–∞–µ—Ç—Å—è –ø—Ä–æ–π–¥–µ–Ω–Ω—ã–º.\n–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å—Ç—Ä–∞—Ç–∞–≥–µ–º—É Insane Bravery? (y/n): "
+                                    )
                                     strat = recieveGUI()
                             else:
                                 if self.playType is False:
-                                    strat = input("Valid answers are: y, yes, n, and no: ")
+                                    strat = input("–î–æ–ø—É—Å—Ç–∏–º—ã–µ –æ—Ç–≤–µ—Ç—ã: y/yes/n/no: ")
                                 else:
-                                    sendToGUI("Valid answers are: y, yes, n, and no: ")
+                                    sendToGUI("–î–æ–ø—É—Å—Ç–∏–º—ã–µ –æ—Ç–≤–µ—Ç—ã: y/yes/n/no: ")
                                     strat = recieveGUI()
 
             if self.enemyInAttack[i][0] == 0 and self.enemy_health[i] > 0:
                 self.enemy_coords[i] = bounds(self.enemy_coords[i], self.b_len, self.b_hei)
                 for j in range(len(self.enemy_health)):
                     if self.enemy_coords[i] == self.unit_coords[j]:
                         self.enemy_coords[i][0] -= 1
 
                 self.updateBoard()
                 self.showBoard()
 
                 if self.playType is False:
-                    print("Take a look at board.txt or click the Show Board button in the GUI to view the current board")
-                    print("If you would like to end the game type 'quit' into the prompt")
-                    dire = input("Enter the direction of movement (up, down, left, right, none (no move)): ")
+                    print("–ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ board.txt –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ Show Board –≤ GUI, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –ø–æ–ª–µ.")
+                    print("–ß—Ç–æ–±—ã –∑–∞–≤–µ—Ä—à–∏—Ç—å –∏–≥—Ä—É, –≤–≤–µ–¥–∏—Ç–µ 'quit' –≤ –ª—é–±–æ–º –≤–æ–ø—Ä–æ—Å–µ.")
+                    dire = input(f"–•–æ–¥ —é–Ω–∏—Ç–∞: {unit_label}. –í—ã–±–µ—Ä–∏—Ç–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ (up/down/left/right/none): ")
                 else:
                     sendToGUI(
-                        "Take a look at board.txt or click the Show Board button in the GUI to view the current board\n"
-                        "If you would like to end the game type 'quit' into the prompt\n"
-                        "Enter the direction of movement for Unit {} (up, down, left, right, none (no move)): ".format(playerName)
+                        "–ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ board.txt –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ Show Board –≤ GUI, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –ø–æ–ª–µ.\n"
+                        "–ß—Ç–æ–±—ã –∑–∞–≤–µ—Ä—à–∏—Ç—å –∏–≥—Ä—É, –≤–≤–µ–¥–∏—Ç–µ 'quit' –≤ –ª—é–±–æ–º –≤–æ–ø—Ä–æ—Å–µ.\n"
+                        f"–•–æ–¥ —é–Ω–∏—Ç–∞: {unit_label}. –í—ã–±–µ—Ä–∏—Ç–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ (up/down/left/right/none): "
                     )
                     dire = recieveGUI()
 
                 if dire.lower() == "quit":
                     self.game_over = True
                     info = self.get_info()
                     return self.game_over, info
 
                 # ======= FIX: Advance is optional, move distance is exactly what you choose =======
                 advanced = False
                 move_num = 0
 
                 if dire.lower() != "none":
                     if self.playType is False:
-                        adv = input("Advance? (y/n): ").strip().lower()
+                        adv = input("–°–¥–µ–ª–∞—Ç—å Advance? (y/n): ").strip().lower()
                         if adv in ("y", "yes"):
                             advanced = True
-                            print("Rolling 1 D6 for Advance...")
+                            print("–ë—Ä–æ—Å–æ–∫ 1D6 –Ω–∞ Advance...")
                             roll = player_dice()
-                            print("You rolled a", roll)
+                            print("–ë—Ä–æ—Å–æ–∫:", roll)
                             movement_cap = self.enemy_data[i]["Movement"] + roll
                         else:
                             movement_cap = self.enemy_data[i]["Movement"]
 
-                        move_len = input(f"How many inches would you like to move (0..{movement_cap}): ")
+                        move_len = input(f"–ù–∞ —Å–∫–æ–ª—å–∫–æ –¥—é–π–º–æ–≤ –¥–≤–∏–≥–∞—Ç—å—Å—è (0..{movement_cap}): ")
                     else:
                         # GUI branch –æ—Å—Ç–∞–≤–ª—è–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –ø–æ—Ö–æ–∂–∏–º –Ω–∞ —Å—Ç–∞—Ä—É—é –ª–æ–≥–∏–∫—É
                         adv = "y"
                         advanced = True
                         roll = player_dice()
                         movement_cap = self.enemy_data[i]["Movement"] + roll
-                        sendToGUI("How many inches would you like to move your unit (Max: {}): ".format(movement_cap))
+                        sendToGUI(f"–ù–∞ —Å–∫–æ–ª—å–∫–æ –¥—é–π–º–æ–≤ –¥–≤–∏–≥–∞—Ç—å—Å—è (0..{movement_cap}): ")
                         move_len = recieveGUI()
 
                     response = False
                     while response is False:
                         if is_num(move_len) is True:
                             if int(move_len) <= movement_cap:
                                 move_num = int(move_len)
                                 response = True
                             else:
                                 if self.playType is False:
-                                    move_len = input("Not in range, try again: ")
+                                    move_len = input("–í–Ω–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞: ")
                                 else:
-                                    sendToGUI("Not in range, try again: ")
+                                    sendToGUI("–í–Ω–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞: ")
                                     move_len = recieveGUI()
                         elif move_len.lower() in ("quit", "q"):
                             self.game_over = True
                             info = self.get_info()
                             return self.game_over, info
                         else:
                             if self.playType is False:
-                                move_len = input("Not a number, try again: ")
+                                move_len = input("–≠—Ç–æ –Ω–µ —á–∏—Å–ª–æ, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞: ")
                             else:
-                                sendToGUI("Not a number, try again: ")
+                                sendToGUI("–≠—Ç–æ –Ω–µ —á–∏—Å–ª–æ, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞: ")
                                 move_len = recieveGUI()
 
                 # apply movement using move_num (NOT cap)
                 response = False
                 while response is False:
                     if dire.lower() == "down":
                         self.enemy_coords[i][0] += move_num
                         response = True
                     elif dire.lower() == "up":
                         self.enemy_coords[i][0] -= move_num
                         response = True
                     elif dire.lower() == "left":
                         self.enemy_coords[i][1] -= move_num
                         response = True
                     elif dire.lower() == "right":
                         self.enemy_coords[i][1] += move_num
                         response = True
                     elif dire.lower() == "none":
                         response = True
                     elif dire.lower() == "quit":
                         self.game_over = True
                         info = self.get_info()
                         return self.game_over, info
                     else:
                         if self.playType is False:
-                            dire = input("Not a valid response (up, down, left, right): ")
+                            dire = input("–ù–µ–≤–µ—Ä–Ω—ã–π –≤–≤–æ–¥ (up/down/left/right): ")
                         else:
-                            sendToGUI("Not a valid response (up, down, left, right): ")
+                            sendToGUI("–ù–µ–≤–µ—Ä–Ω—ã–π –≤–≤–æ–¥ (up/down/left/right): ")
                             dire = recieveGUI()
                         response = False
 
                 # bounds + collision
                 self.enemy_coords[i] = bounds(self.enemy_coords[i], self.b_len, self.b_hei)
                 for j in range(len(self.enemy_health)):
                     if self.enemy_coords[i] == self.unit_coords[j]:
                         self.enemy_coords[i][0] -= 1
 
                 self.updateBoard()
                 self.showBoard()
 
                 pos_after = tuple(self.enemy_coords[i])
                 if pos_before != pos_after:
                     self._resolve_overwatch(
                         defender_side="model",
                         moving_unit_side="enemy",
                         moving_idx=i,
                         phase="movement",
                         manual=False,
                     )
 
                 self.updateBoard()
                 self.showBoard()
 
                 # ======= Shooting phase (Assault rule after Advance) =======
                 if self.enemy_weapon[i] != "None":
                     if self.playType is False:
-                        print("Beginning shooting phase!")
+                        print("–ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Ñ–∞–∑–∞ —Å—Ç—Ä–µ–ª—å–±—ã!")
                     else:
-                        sendToGUI("Beginning shooting phase!")
+                        sendToGUI("–ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Ñ–∞–∑–∞ —Å—Ç—Ä–µ–ª—å–±—ã!")
 
                     if advanced and not weapon_is_assault(self.enemy_weapon[i]):
                         if self.playType is False:
-                            print("You advanced ‚Äî non-Assault weapon, skipping shooting")
+                            print("Advance –±–µ–∑ Assault ‚Äî —Å—Ç—Ä–µ–ª—å–±–∞ –ø—Ä–æ–ø—É—â–µ–Ω–∞.")
                         else:
-                            sendToGUI("You advanced ‚Äî non-Assault weapon, skipping shooting")
+                            sendToGUI("Advance –±–µ–∑ Assault ‚Äî —Å—Ç—Ä–µ–ª—å–±–∞ –ø—Ä–æ–ø—É—â–µ–Ω–∞.")
                     else:
                         shootAble = np.array([])
                         for j in range(len(self.unit_health)):
                             if distance(self.enemy_coords[i], self.unit_coords[j]) <= self.enemy_weapon[i]["Range"] and self.unit_health[j] > 0 and self.unitInAttack[j][0] == 0:
                                 shootAble = np.append(shootAble, j)
 
                         if len(shootAble) > 0:
                             response = False
                             while response is False:
                                 if self.playType is False:
-                                    shoot = input("Select which enemy unit you would like to shoot ({}): ".format(shootAble + 21))
+                                    targets_label = self._format_unit_choices("model", shootAble.astype(int).tolist())
+                                    shoot = input(f"–í—ã–±–µ—Ä–∏—Ç–µ —Ü–µ–ª—å –¥–ª—è —Å—Ç—Ä–µ–ª—å–±—ã. –î–æ—Å—Ç—É–ø–Ω—ã–µ —Ü–µ–ª–∏: {targets_label}. –í–≤–µ–¥–∏—Ç–µ ID —Ü–µ–ª–∏: ")
                                 else:
-                                    sendToGUI("Select which enemy unit you would like to shoot ({}) with Unit {}: ".format(shootAble + 21, playerName))
+                                    targets_label = self._format_unit_choices("model", shootAble.astype(int).tolist())
+                                    sendToGUI(f"–í—ã–±–µ—Ä–∏—Ç–µ —Ü–µ–ª—å –¥–ª—è —Å—Ç—Ä–µ–ª—å–±—ã. –°—Ç—Ä–µ–ª—è–µ—Ç: {unit_label}. –î–æ—Å—Ç—É–ø–Ω—ã–µ —Ü–µ–ª–∏: {targets_label}. –í–≤–µ–¥–∏—Ç–µ ID —Ü–µ–ª–∏: ")
                                     shoot = recieveGUI()
 
                                 if is_num(shoot) is True and int(shoot) - 21 in shootAble:
                                     idOfE = int(shoot) - 21
                                     effect = self._maybe_use_smokescreen(
                                         defender_side="model",
                                         defender_idx=idOfE,
                                         phase="shooting",
                                         manual=False,
                                     )
 
                                     logger = RollLogger(player_dice)
 
                                     dmg, modHealth = attack(
                                         self.enemy_health[i],
                                         self.enemy_weapon[i],
                                         self.enemy_data[i],
                                         self.unit_health[idOfE],
                                         self.unit_data[idOfE],
                                         effects=effect,
                                         distance_to_target=distance(self.enemy_coords[i], self.unit_coords[idOfE]),
                                         roller=logger.roll,
                                     )
 
                                     self.unit_health[idOfE] = modHealth
                                     if self.playType is False:
-                                        print(f"Player Unit {playerName} –Ω–∞–Ω—ë—Å {sum(dmg)} —É—Ä–æ–Ω–∞ –ø–æ Model Unit {idOfE + 21}")
+                                        print(
+                                            f"{unit_label} –Ω–∞–Ω—ë—Å {sum(dmg)} —É—Ä–æ–Ω–∞ –ø–æ {self._format_unit_label('model', idOfE)}"
+                                        )
                                     else:
-                                        sendToGUI("Player Unit {} –Ω–∞–Ω—ë—Å {} —É—Ä–æ–Ω–∞ –ø–æ Model Unit {}".format(playerName, sum(dmg), idOfE + 21))
+                                        sendToGUI(
+                                            f"{unit_label} –Ω–∞–Ω—ë—Å {sum(dmg)} —É—Ä–æ–Ω–∞ –ø–æ {self._format_unit_label('model', idOfE)}"
+                                        )
 
                                     logger.print_shoot_report(
                                         weapon=self.enemy_weapon[i],
                                         attacker_data=self.enemy_data[i],
                                         defender_data=self.unit_data[idOfE],
                                         dmg_list=dmg,
                                         effect=effect,
                                     )
                                     response = True
                                 elif shoot == "quit":
                                     self.game_over = True
                                     info = self.get_info()
                                     return self.game_over, info
                                 else:
                                     if self.playType is False:
-                                        print("Not an available unit")
+                                        print("–ù–µ–¥–æ—Å—Ç—É–ø–Ω–∞—è —Ü–µ–ª—å.")
                                     else:
-                                        sendToGUI("Not an available unit")
+                                        sendToGUI("–ù–µ–¥–æ—Å—Ç—É–ø–Ω–∞—è —Ü–µ–ª—å.")
                 else:
                     if self.playType is False:
-                        print("No available weapons to shoot")
+                        print("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ –æ—Ä—É–∂–∏—è –¥–ª—è —Å—Ç—Ä–µ–ª—å–±—ã.")
                     else:
-                        sendToGUI("No available weapons to shoot")
+                        sendToGUI("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ –æ—Ä—É–∂–∏—è –¥–ª—è —Å—Ç—Ä–µ–ª—å–±—ã.")
 
                 # ======= Charge phase (no charge after Advance) =======
                 if self.playType is False:
-                    print("Beginning Charge phase!")
+                    print("–ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Ñ–∞–∑–∞ —á–∞—Ä–¥–∂–∞!")
                 else:
-                    sendToGUI("Beginning Charge phase!")
+                    sendToGUI("–ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Ñ–∞–∑–∞ —á–∞—Ä–¥–∂–∞!")
 
                 if advanced:
                     if self.playType is False:
-                        print("You advanced ‚Äî cannot charge, skipping charge")
+                        print("Advance ‚Äî —á–∞—Ä–¥–∂ –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω.")
                     else:
-                        sendToGUI("You advanced ‚Äî cannot charge, skipping charge")
+                        sendToGUI("Advance ‚Äî —á–∞—Ä–¥–∂ –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω.")
                 else:
                     charg = np.array([])
                     for j in range(len(self.unit_health)):
                         if distance(self.unit_coords[j], self.enemy_coords[i]) <= 12 and self.unitInAttack[j][0] == 0 and self.unit_health[j] > 0:
                             charg = np.append(charg, j)
 
                     if len(charg) > 0:
                         response = False
                         while response is False:
                             if self.playType is False:
-                                attk = input("Select which enemy you would like to charge ({}): ".format(charg + 21))
+                                targets_label = self._format_unit_choices("model", charg.astype(int).tolist())
+                                attk = input(f"–í—ã–±–µ—Ä–∏—Ç–µ —Ü–µ–ª—å –¥–ª—è —á–∞—Ä–¥–∂–∞. –î–æ—Å—Ç—É–ø–Ω—ã–µ —Ü–µ–ª–∏: {targets_label}. –í–≤–µ–¥–∏—Ç–µ ID —Ü–µ–ª–∏: ")
                             else:
-                                sendToGUI("Select which enemy you would like to charge ({}) with Unit {}: ".format(charg + 21, playerName))
+                                targets_label = self._format_unit_choices("model", charg.astype(int).tolist())
+                                sendToGUI(f"–í—ã–±–µ—Ä–∏—Ç–µ —Ü–µ–ª—å –¥–ª—è —á–∞—Ä–¥–∂–∞. –°—Ç—Ä–µ–ª—è–µ—Ç: {unit_label}. –î–æ—Å—Ç—É–ø–Ω—ã–µ —Ü–µ–ª–∏: {targets_label}. –í–≤–µ–¥–∏—Ç–µ ID —Ü–µ–ª–∏: ")
                                 attk = recieveGUI()
 
                             if is_num(attk) is True and int(attk) - 21 in charg:
                                 response = True
                                 j = int(attk) - 21
                                 if self.playType is False:
-                                    print("Rolling 2 D6...")
+                                    print("–ë—Ä–æ—Å–æ–∫ 2D6...")
                                     roll = player_dice(num=2)
-                                    print("You rolled a", roll[0], "and", roll[1])
+                                    print("–ë—Ä–æ—Å–æ–∫:", roll[0], "–∏", roll[1])
                                 else:
-                                    sendToGUI("Rolling 2 D6...")
+                                    sendToGUI("–ë—Ä–æ—Å–æ–∫ 2D6...")
                                     roll = player_dice(num=2)
-                                    sendToGUI("You rolled a {} and {}".format(roll[0], roll[1]))
+                                    sendToGUI("–ë—Ä–æ—Å–æ–∫: {} –∏ {}".format(roll[0], roll[1]))
 
                                 dist_to_target = distance(self.enemy_coords[i], self.unit_coords[j])
                                 self._log_unit_phase(
                                     self._side_label("enemy", manual=True),
                                     "charge",
                                     playerName,
                                     i,
-                                    f"Charge –æ–±—ä—è–≤–ª–µ–Ω –ø–æ —Ü–µ–ª–∏ Model Unit {j + 21}. –î–∏—Å—Ç–∞–Ω—Ü–∏—è: {dist_to_target:.1f}. –ë—Ä–æ—Å–æ–∫ 2D6: {roll[0]} + {roll[1]} = {sum(roll)}.",
+                                    f"Charge –æ–±—ä—è–≤–ª–µ–Ω –ø–æ —Ü–µ–ª–∏ {self._format_unit_label('model', j)}. –î–∏—Å—Ç–∞–Ω—Ü–∏—è: {dist_to_target:.1f}. –ë—Ä–æ—Å–æ–∫ 2D6: {roll[0]} + {roll[1]} = {sum(roll)}.",
                                 )
                                 if distance(self.enemy_coords[i], self.unit_coords[j]) - sum(roll) <= 5:
                                     if self.playType is False:
-                                        print("Player Unit", playerName, "Successfully charged Model Unit", j + 21)
+                                        print(f"{unit_label} —É—Å–ø–µ—à–Ω–æ –∑–∞—á–∞—Ä–¥–∂–∏–ª {self._format_unit_label('model', j)}")
                                     else:
-                                        sendToGUI("Player Unit {} Successfully charged Model Unit {}".format(playerName, j + 21))
+                                        sendToGUI(
+                                            f"{unit_label} —É—Å–ø–µ—à–Ω–æ –∑–∞—á–∞—Ä–¥–∂–∏–ª {self._format_unit_label('model', j)}"
+                                        )
 
                                     self.enemyInAttack[i][0] = 1
                                     self.enemyInAttack[i][1] = j
 
                                     self.enemy_coords[i][0] = self.unit_coords[j][0] + 1
                                     self.enemy_coords[i][1] = self.unit_coords[j][1] + 1
                                     self.enemy_coords[i] = bounds(self.enemy_coords[i], self.b_len, self.b_hei)
 
                                     # 10e: Charge –Ω–µ –Ω–∞–Ω–æ—Å–∏—Ç —É—Ä–æ–Ω. –£—Ä–æ–Ω ‚Äî –≤ Fight Phase
                                     self.enemyCharged[i] = 1
                                     self.updateBoard()
 
                                     self.unitInAttack[j][0] = 1
                                     self.unitInAttack[j][1] = i
                                     pos_after = tuple(self.enemy_coords[i])
                                     self._log_unit_phase(
                                         self._side_label("enemy", manual=True),
                                         "charge",
                                         playerName,
                                         i,
-                                        f"Charge move: from {pos_before} -> {pos_after}, ended_in_engagement={self.enemyInAttack[i][0] == 1}.",
+                                        f"–î–≤–∏–∂–µ–Ω–∏–µ —á–∞—Ä–¥–∂–∞: {pos_before} -> {pos_after}, –≤ –∫–æ–Ω—Ç–∞–∫—Ç–µ={self.enemyInAttack[i][0] == 1}.",
                                     )
                                     # 10e: Heroic Intervention –¥–æ—Å—Ç—É–ø–µ–Ω –∑–∞—â–∏—Ç–Ω–∏–∫—É –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ charge move.
                                     self._resolve_heroic_intervention(
                                         defender_side="model",
                                         charging_side="enemy",
                                         charging_idx=i,
                                         phase="charge",
                                         manual=False,
                                     )
                                 else:
                                     if self.playType is False:
-                                        print("Player Unit {} Failed to charge Model Unit {}".format(playerName, j + 21))
+                                        print(
+                                            f"{unit_label} –Ω–µ —Å–º–æ–≥ –∑–∞—á–∞—Ä–¥–∂–∏—Ç—å {self._format_unit_label('model', j)}"
+                                        )
                                     else:
-                                        sendToGUI("Player Unit {} Failed to charge Model Unit {}".format(playerName, j + 21))
+                                        sendToGUI(
+                                            f"{unit_label} –Ω–µ —Å–º–æ–≥ –∑–∞—á–∞—Ä–¥–∂–∏—Ç—å {self._format_unit_label('model', j)}"
+                                        )
 
                             elif attk == "quit":
                                 self.game_over = True
                                 info = self.get_info()
                                 return self.game_over, info
                             else:
                                 if self.playType is False:
-                                    print("Not an available unit")
+                                    print("–ù–µ–¥–æ—Å—Ç—É–ø–Ω–∞—è —Ü–µ–ª—å.")
                                 else:
-                                    sendToGUI("Not an available unit")
+                                    sendToGUI("–ù–µ–¥–æ—Å—Ç—É–ø–Ω–∞—è —Ü–µ–ª—å.")
                     else:
                         if self.playType is False:
-                            print("No available units to charge")
+                            print("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ü–µ–ª–µ–π –¥–ª—è —á–∞—Ä–¥–∂–∞.")
                         else:
-                            sendToGUI("No available units to charge")
+                            sendToGUI("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ü–µ–ª–µ–π –¥–ª—è —á–∞—Ä–¥–∂–∞.")
 
             elif self.enemyInAttack[i][0] == 1 and self.enemy_health[i] > 0:
                 idOfE = self.enemyInAttack[i][1]
                 response = False
                 while response is False:
                     if self.playType is False:
-                        fallB = input("Would you like Unit {} to fallback? (y/n): ".format(playerName))
+                        fallB = input(f"{unit_label}. –û—Ç—Å—Ç—É–ø–∏—Ç—å (fallback)? (y/n): ")
                     else:
-                        sendToGUI("Would you like Unit {} to fallback? (y/n): ".format(playerName))
+                        sendToGUI(f"{unit_label}. –û—Ç—Å—Ç—É–ø–∏—Ç—å (fallback)? (y/n): ")
                         fallB = recieveGUI()
 
                     if fallB.lower() in ("n", "no"):
                         response = True
 
                         # 10e: –∑–¥–µ—Å—å –ù–ï –∞—Ç–∞–∫—É–µ–º. –ê—Ç–∞–∫–∏ –ø—Ä–æ–∏—Å—Ö–æ–¥—è—Ç –≤ Fight Phase.
                         if self.playType is False:
-                            print("Player Unit", playerName, "stays in combat with Model Unit", idOfE + 21, "(will fight in Fight Phase)")
+                            print(
+                                f"{unit_label} –æ—Å—Ç–∞—ë—Ç—Å—è –≤ –±–æ—é —Å {self._format_unit_label('model', idOfE)} (–±—É–¥–µ—Ç –¥—Ä–∞—Ç—å—Å—è –≤ —Ñ–∞–∑–µ –±–æ—è)"
+                            )
                         else:
-                            sendToGUI("Player Unit {} stays in combat with Model Unit {} (will fight in Fight Phase)".format(playerName, idOfE + 21))
+                            sendToGUI(
+                                f"{unit_label} –æ—Å—Ç–∞—ë—Ç—Å—è –≤ –±–æ—é —Å {self._format_unit_label('model', idOfE)} (–±—É–¥–µ—Ç –¥—Ä–∞—Ç—å—Å—è –≤ —Ñ–∞–∑–µ –±–æ—è)"
+                            )
 
                         # –ù–∏—á–µ–≥–æ –Ω–µ –º–µ–Ω—è–µ–º: –æ–Ω–∏ –æ—Å—Ç–∞—é—Ç—Å—è –≤ –±–æ—é
                         # self.enemyInAttack / self.unitInAttack –æ—Å—Ç–∞—é—Ç—Å—è –∫–∞–∫ –µ—Å—Ç—å
                         continue
 
                         if self.unit_health[idOfE] <= 0:
 
                             if self.playType is False:
-                                print("Model Unit", idOfE + 21, "has been killed")
+                                print(f"{self._format_unit_label('model', idOfE)} —É–Ω–∏—á—Ç–æ–∂–µ–Ω")
                             else:
-                                sendToGUI("Model Unit {} has been killed".format(idOfE + 21))
+                                sendToGUI(f"{self._format_unit_label('model', idOfE)} —É–Ω–∏—á—Ç–æ–∂–µ–Ω")
 
                             self.enemyInAttack[i][0] = 0
                             self.enemyInAttack[i][1] = 0
                             self.unitInAttack[idOfE][0] = 0
                             self.unitInAttack[idOfE][1] = 0
 
                     elif fallB.lower() in ("y", "yes"):
                         response = True
                         if self.playType is False:
-                            print("Player Unit", playerName, "fell back from Enemy unit", idOfE + 21)
+                            print(f"{unit_label} –æ—Ç—Å—Ç—É–ø–∏–ª –∏–∑ –±–æ—è —Å {self._format_unit_label('model', idOfE)}")
                         else:
-                            sendToGUI("Player Unit {} fell back from Enemy unit {}".format(playerName, idOfE + 21))
+                            sendToGUI(f"{unit_label} –æ—Ç—Å—Ç—É–ø–∏–ª –∏–∑ –±–æ—è —Å {self._format_unit_label('model', idOfE)}")
 
                         if battleSh is True:
                             diceRoll = dice()
                             if diceRoll < 3:
                                 self.enemy_health[i] -= self.enemy_data[i]["W"]
 
                         self.enemy_coords[i][0] += self.enemy_data[i]["Movement"]
                         self.enemyInAttack[i][0] = 0
                         self.enemyInAttack[i][1] = 0
 
                         self.unitInAttack[idOfE][0] = 0
                         self.unitInAttack[idOfE][1] = 0
 
                     elif fallB.lower() == "quit":
                         self.game_over = True
                         info = self.get_info()
                         return self.game_over, info
                     else:
                         if self.playType is False:
-                            fallB = input("It's a yes or no question dude: ")
+                            fallB = input("–í–≤–µ–¥–∏—Ç–µ y/yes –∏–ª–∏ n/no: ")
                         else:
-                            sendToGUI("It's a yes or no question dude: ")
+                            sendToGUI("–í–≤–µ–¥–∏—Ç–µ y/yes –∏–ª–∏ n/no: ")
                             fallB = recieveGUI()
 
             elif self.enemy_health[i] == 0:
                 if self.playType is False:
-                    print("Unit", playerName, "is dead")
+                    print(f"{unit_label} —É–Ω–∏—á—Ç–æ–∂–µ–Ω")
                 else:
-                    sendToGUI("Unit {} is dead".format(playerName))
+                    sendToGUI(f"{unit_label} —É–Ω–∏—á—Ç–æ–∂–µ–Ω")
 
         if self.modelStrat["overwatch"] != -1:
             self.modelStrat["overwatch"] = -1
         if self.modelStrat["smokescreen"] != -1:
             self.modelStrat["smokescreen"] = -1
 
         apply_end_of_battle(self, log_fn=self._log)
 
         for k in range(len(self.enemy_health)):
             if self.enemy_health[k] < 0:
                 self.enemy_health[k] = 0
 
         self.iter += 1
         info = self.get_info()
         return self.game_over, info
 
     def player(self):
         self.active_side = "enemy"
 
         info = self.get_info()
         if self.playType is False:
             self._log(str(info))
         else:
-            moreInfo = "Model Unit Health: {}, Player Unit Health: {}\nModel CP: {}, Player CP: {}\nModel VP: {}, Player VP: {}\n".format(
-                info["model health"], info["player health"], info["modelCP"], info["playerCP"], info["model VP"], info["player VP"]
+            moreInfo = "–ó–¥–æ—Ä–æ–≤—å–µ MODEL: {}, –∑–¥–æ—Ä–æ–≤—å–µ PLAYER: {}\nCP MODEL: {}, CP PLAYER: {}\nVP MODEL: {}, VP PLAYER: {}\n".format(
+                info["model health"],
+                info["player health"],
+                info["modelCP"],
+                info["playerCP"],
+                info["model VP"],
+                info["player VP"],
             )
             if self.modelUpdates != "":
-                sendToGUI(moreInfo + self.modelUpdates + "\nWould you like to continue: ")
+                sendToGUI(moreInfo + self.modelUpdates + "\n–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å? (y/n): ")
             else:
-                sendToGUI(moreInfo + "\nWould you like to continue: ")
+                sendToGUI(moreInfo + "\n–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å? (y/n): ")
             ans = recieveGUI()
             response = False
             while response is False:
                 if ans.lower() in ("y", "yes"):
                     response = True
                     self.modelUpdates = ""
                 elif ans.lower() in ("n", "no"):
                     self.game_over = True
                     info = self.get_info()
                     return self.game_over, info
                 else:
-                    sendToGUI("Its a yes or no question dude...: ")
+                    sendToGUI("–í–≤–µ–¥–∏—Ç–µ y/yes –∏–ª–∏ n/no: ")
                     ans = recieveGUI()
 
         battle_shock = self.command_phase("enemy", manual=True)
         if self.game_over:
             info = self.get_info()
             return self.game_over, info
 
         advanced_flags = self.movement_phase("enemy", manual=True, battle_shock=battle_shock)
         if self.game_over:
             info = self.get_info()
             return self.game_over, info
 
         self.shooting_phase("enemy", advanced_flags=advanced_flags, manual=True)
         if self.game_over:
             info = self.get_info()
             return self.game_over, info
 
         self.charge_phase("enemy", advanced_flags=advanced_flags, manual=True)
         if self.game_over:
             info = self.get_info()
             return self.game_over, info
 
         self.fight_phase("enemy")
         apply_end_of_battle(self, log_fn=self._log)
 
@@ -3081,52 +3192,56 @@ class Warhammer40kEnv(gym.Env):
             self.unit_coords[i] = bounds(self.unit_coords[i], self.b_len, self.b_hei)
             self.board[self.unit_coords[i][0]][self.unit_coords[i][1]] = 20 + i + 1
 
         for i in range(len(self.enemy_health)):
             self.enemy_coords[i] = bounds(self.enemy_coords[i], self.b_len, self.b_hei)
             self.board[self.enemy_coords[i][0]][self.enemy_coords[i][1]] = 10 + i + 1
 
         for i in range(len(self.coordsOfOM)):
             self.board[int(self.coordsOfOM[i][0])][int(self.coordsOfOM[i][1])] = 3
 
     def returnBoard(self):
         return self.board
 
     def render(self, mode='train'):
         fig = plt.figure()
         ax = fig.add_subplot()
         fig.subplots_adjust(top=0.85)
 
         if mode == 'train':
             title = "Turn " + str(self.iter) + " Lifetime " + str(self.restarts)
         else:
             title = "Turn " + str(self.iter)
 
         fig.suptitle(title)
 
-        health = "Model Unit health: {}, CP: {}; Enemy Unit health: {}, CP {}\nVP {}".format(
-            self.unit_health, self.modelCP, self.enemy_health, self.enemyCP, [self.modelVP, self.enemyVP]
+        health = "–ó–¥–æ—Ä–æ–≤—å–µ MODEL: {}, CP: {}; –∑–¥–æ—Ä–æ–≤—å–µ ENEMY: {}, CP {}\nVP {}".format(
+            self.unit_health,
+            self.modelCP,
+            self.enemy_health,
+            self.enemyCP,
+            [self.modelVP, self.enemyVP],
         )
         ax.set_title(health)
 
         x1 = np.linspace(0, self.b_len, 10)
         y1 = np.zeros(10)
         x2 = np.zeros(10)
         y2 = np.linspace(0, self.b_hei, 10)
 
         ax.set_ylim(-5, self.b_len + 5)
         ax.set_xlim(-3, self.b_hei * 1.65)
         ax.plot(y1, x1, color="black")
         ax.plot(y2, x2, color="black")
         ax.plot(y1 + self.b_hei, x1, color="black")
         ax.plot(y2, x2 + self.b_len, color="black")
 
         for i in range(len(self.unit_health)):
             if i == 0:
                 ax.plot(self.unit_coords[i][1], self.unit_coords[i][0], 'bo', label="Model Unit")
             else:
                 ax.plot(self.unit_coords[i][1], self.unit_coords[i][0], 'bo')
 
         for i in range(len(self.enemy_coords)):
             if i == 0:
                 ax.plot(self.enemy_coords[i][1], self.enemy_coords[i][0], 'go', label="Player Unit")
             else:

