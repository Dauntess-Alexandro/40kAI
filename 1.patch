diff --git a/eval.py b/eval.py
new file mode 100644
index 0000000000000000000000000000000000000000..8174794f63c4a284f988ae88c07ad0d3072cf3ed
--- /dev/null
+++ b/eval.py
@@ -0,0 +1,237 @@
+import argparse
+import os
+import pickle
+import sys
+from collections import Counter
+from typing import Optional
+
+import torch
+
+from gym_mod.engine.deployment import deploy_only_war, post_deploy_setup
+from gym_mod.engine.mission import check_end_of_battle
+from gym_mod.envs.warhamEnv import roll_off_attacker_defender
+from model.DQN import DQN
+from model.utils import build_shoot_action_mask, convertToDict
+
+
+def log(message: str) -> None:
+    if message.startswith("["):
+        print(f"[EVAL]{message}", flush=True)
+    else:
+        print(f"[EVAL] {message}", flush=True)
+
+
+def load_latest_model(model_path: Optional[str] = None):
+    if model_path and model_path != "None":
+        pickle_path = model_path
+        checkpoint_path = model_path[:-len("pickle")] + "pth"
+    else:
+        save_path = "models/"
+        folders = os.listdir(save_path) if os.path.isdir(save_path) else []
+        envs = []
+        modelpth = []
+
+        for folder in folders:
+            full = os.path.join(save_path, folder)
+            if os.path.isdir(full):
+                files = os.listdir(full)
+                for filename in files:
+                    if filename.endswith(".pickle"):
+                        envs.append(os.path.join(full, filename))
+                    elif filename.endswith(".pth"):
+                        modelpth.append(os.path.join(full, filename))
+
+        if not envs or not modelpth:
+            return None, None, None, None
+
+        envs.sort(key=lambda x: os.path.getmtime(x))
+        modelpth.sort()
+        pickle_path = envs[-1]
+        checkpoint_path = modelpth[-1]
+
+    with open(pickle_path, "rb") as handle:
+        env, model, enemy = pickle.load(handle)
+
+    checkpoint = torch.load(checkpoint_path, map_location="cpu")
+    return env, model, enemy, checkpoint
+
+
+def select_action_with_epsilon(env, state, policy_net, epsilon, len_model, shoot_mask=None):
+    if epsilon <= 0:
+        with torch.no_grad():
+            decision = policy_net(state)
+            action = []
+            for head_idx, head in enumerate(decision):
+                head = head.squeeze(0)
+                if head_idx == 2 and shoot_mask is not None:
+                    mask = torch.as_tensor(shoot_mask, dtype=torch.bool, device=head.device)
+                    if mask.numel() == head.numel() and mask.any():
+                        masked_head = head.clone()
+                        masked_head[~mask] = -1e9
+                        action.append(int(masked_head.argmax().item()))
+                        continue
+                action.append(int(head.argmax().item()))
+            return torch.tensor([action], device="cpu")
+
+    sampled_action = env.action_space.sample()
+    shoot_choice = sampled_action["shoot"]
+    if shoot_mask is not None:
+        mask = torch.as_tensor(shoot_mask, dtype=torch.bool)
+        valid_indices = torch.where(mask)[0].tolist()
+        if valid_indices:
+            shoot_choice = valid_indices[torch.randint(0, len(valid_indices), (1,)).item()]
+    action_list = [
+        sampled_action["move"],
+        sampled_action["attack"],
+        shoot_choice,
+        sampled_action["charge"],
+        sampled_action["use_cp"],
+        sampled_action["cp_on"],
+    ]
+    for i in range(len_model):
+        label = "move_num_" + str(i)
+        action_list.append(sampled_action[label])
+    return torch.tensor([action_list], device="cpu")
+
+
+def run_episode(env, model_units, enemy_units, policy_net, epsilon, device):
+    attacker_side, defender_side = roll_off_attacker_defender(
+        manual_roll_allowed=False,
+        log_fn=None,
+    )
+
+    deploy_only_war(
+        model_units=model_units,
+        enemy_units=enemy_units,
+        b_len=env.unwrapped.b_len,
+        b_hei=env.unwrapped.b_hei,
+        attacker_side=attacker_side,
+        log_fn=None,
+    )
+    post_deploy_setup(log_fn=None)
+
+    env.attacker_side = attacker_side
+    env.defender_side = defender_side
+
+    state, info = env.reset(m=model_units, e=enemy_units, Type="big", trunc=True)
+
+    done = False
+    while not done:
+        env.enemyTurn(trunc=True)
+        if env.game_over:
+            info = env.get_info()
+            break
+
+        state_tensor = torch.tensor(state, dtype=torch.float32, device=device).unsqueeze(0)
+        shoot_mask = build_shoot_action_mask(env)
+        action = select_action_with_epsilon(
+            env,
+            state_tensor,
+            policy_net,
+            epsilon,
+            len(model_units),
+            shoot_mask=shoot_mask,
+        )
+        action_dict = convertToDict(action)
+        next_observation, _, done, _, info = env.step(action_dict)
+        state = next_observation
+
+    end_reason = info.get("end reason", "")
+    winner = info.get("winner")
+    if not end_reason or winner is None:
+        _, fallback_reason, fallback_winner = check_end_of_battle(env)
+        if not end_reason:
+            end_reason = fallback_reason
+        if winner is None:
+            winner = fallback_winner
+    vp_diff = info.get("model VP", 0) - info.get("player VP", 0)
+    return winner, end_reason or "unknown", vp_diff
+
+
+def main():
+    parser = argparse.ArgumentParser()
+    parser.add_argument("--games", type=int, default=50)
+    parser.add_argument("--model", type=str, default=None)
+    args = parser.parse_args()
+
+    games = args.games
+    if games < 1:
+        log("Некорректное значение N. Укажите число >= 1.")
+        return 0
+
+    if os.getenv("FORCE_GREEDY", "0") == "1":
+        epsilon = 0.0
+    else:
+        epsilon_raw = os.getenv("EVAL_EPSILON", "0")
+        epsilon = float(epsilon_raw) if epsilon_raw else 0.0
+
+    os.environ.setdefault("MANUAL_DICE", "0")
+
+    env, model_units, enemy_units, checkpoint = load_latest_model(args.model)
+    if env is None:
+        log("Модель не найдена. Проверьте папку models/ и наличие файлов .pickle/.pth.")
+        return 0
+
+    attacker_side, defender_side = roll_off_attacker_defender(
+        manual_roll_allowed=False,
+        log_fn=None,
+    )
+    deploy_only_war(
+        model_units=model_units,
+        enemy_units=enemy_units,
+        b_len=env.unwrapped.b_len,
+        b_hei=env.unwrapped.b_hei,
+        attacker_side=attacker_side,
+        log_fn=None,
+    )
+    post_deploy_setup(log_fn=None)
+    env.attacker_side = attacker_side
+    env.defender_side = defender_side
+
+    state, info = env.reset(m=model_units, e=enemy_units, Type="big", trunc=True)
+    n_actions = [5, 2, len(info["player health"]), len(info["player health"]), 5, len(info["model health"])]
+    for _ in range(len(model_units)):
+        n_actions.append(12)
+    n_observations = len(state)
+
+    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
+
+    policy_net = DQN(n_observations, n_actions).to(device)
+    target_net = DQN(n_observations, n_actions).to(device)
+    optimizer = torch.optim.Adam(policy_net.parameters())
+
+    policy_net.load_state_dict(checkpoint["policy_net"])
+    target_net.load_state_dict(checkpoint["target_net"])
+    optimizer.load_state_dict(checkpoint["optimizer"])
+
+    policy_net.eval()
+    target_net.eval()
+
+    log(f"Старт оценки: игр={games}, epsilon={epsilon:.3f}.")
+
+    wins = 0
+    vp_diffs = []
+    end_reasons = Counter()
+
+    for idx in range(1, games + 1):
+        winner, end_reason, vp_diff = run_episode(
+            env, model_units, enemy_units, policy_net, epsilon, device
+        )
+        vp_diffs.append(vp_diff)
+        end_reasons[end_reason] += 1
+        if winner == "model":
+            wins += 1
+        log(f"Игра {idx}/{games}: winner={winner} vp_diff={vp_diff} end_reason={end_reason}")
+
+    winrate = wins / games if games else 0.0
+    avg_vp_diff = sum(vp_diffs) / len(vp_diffs) if vp_diffs else 0.0
+    log(
+        "[SUMMARY] "
+        f"winrate={winrate:.3f} avg_vp_diff={avg_vp_diff:.3f} "
+        f"end_reasons={dict(end_reasons)}"
+    )
+    return 0
+
+
+if __name__ == "__main__":
+    sys.exit(main())
diff --git a/gui/Application.cpp b/gui/Application.cpp
index 7b2cf7f0b4b4d1b1c93de66b04289acacf27d91e..f767e5ce2ba5d26e59cdbbc1e0099686e9ee3562 100644
--- a/gui/Application.cpp
+++ b/gui/Application.cpp
@@ -93,50 +93,51 @@ int findDefaultModelsCount(const std::string& faction, const std::string& name)
 
 std::string gifpth = "img/model_train.gif";
 std::string rewpth = "img/reward.png";
 std::string losspth = "img/loss.png";
 std::string eplenpth = "img/epLen.png";
 std::string winratepth = "img/winrate.png";
 std::string vpdiffpth = "img/vpdiff.png";
 std::string endreasonpth = "img/endreasons.png";
 std::string imgpth = "img/icon.png";
 
 Form :: Form() {
 
   modelClass = " Necrons";
   enemyClass = " Necrons";
   path = " ";
   open = false;
   x = 60;
   y = 40;
   training = false;
   playing = false;
   loadingRoster = false;
   trainEnvPrefix = "";
   trainingStartLabel = "обучения";
   trainingStatusLabel = "Обучение";
   trainingLogTag = "TRAIN";
+  evaluating = false;
 
   bar.set_show_close_button(true);
   bar.set_title("40kAI GUI");
   set_titlebar(bar);
 
   set_default_size(kDefaultWidth, kDefaultHeight);
   set_size_request(kMinimumWidth, kMinimumHeight);
 
   rootBox.set_orientation(Gtk::ORIENTATION_VERTICAL);
   topBarBox.set_orientation(Gtk::ORIENTATION_HORIZONTAL);
   topBarBox.set_spacing(8);
   leftBox.set_orientation(Gtk::ORIENTATION_VERTICAL);
   mainSplit.set_orientation(Gtk::ORIENTATION_HORIZONTAL);
   rightSplit.set_orientation(Gtk::ORIENTATION_VERTICAL);
 
   rootBox.set_hexpand(true);
   rootBox.set_vexpand(true);
   topBarBox.set_hexpand(true);
   leftBox.set_hexpand(true);
   leftBox.set_vexpand(true);
   mainSplit.set_hexpand(true);
   mainSplit.set_vexpand(true);
   rightSplit.set_hexpand(true);
   rightSplit.set_vexpand(true);
 
@@ -169,93 +170,138 @@ Form :: Form() {
   boardFrame.set_vexpand(true);
   pictureBox1.set_hexpand(true);
   pictureBox1.set_vexpand(true);
   boardFrame.add(pictureBox1);
 
   logView.set_hexpand(true);
   logView.set_vexpand(true);
   logView.set_editable(false);
   logView.set_wrap_mode(Gtk::WRAP_WORD_CHAR);
   auto logBuffer = Gtk::TextBuffer::create();
   logView.set_buffer(logBuffer);
 
   logScroll.set_hexpand(true);
   logScroll.set_vexpand(true);
   logScroll.set_policy(PolicyType::POLICY_AUTOMATIC, PolicyType::POLICY_AUTOMATIC);
   logScroll.add(logView);
 
   rightSplit.add1(boardFrame);
   rightSplit.add2(logScroll);
 
   tabControl1.insert_page(tabPage2, "Train", 0);
   tabControl1.insert_page(tabPage3, "Show Trained Model", 1);
   tabControl1.insert_page(tabPage5, "Metrics", 2);
   tabControl1.insert_page(tabPage4, "Play", 3);
   tabControl1.insert_page(tabPage1, "Settings", 4);
+  tabControl1.insert_page(tabPage6, "Оценка", 5);
 
     // settings tab
 
   labelPage1.set_label("Settings");
   tabControl1.set_tab_label(tabPage1, labelPage1);
   tabPage1.add(fixedTabPage1);
 
   textbox.set_text("Change Tab Location:");
   fixedTabPage1.add(textbox);
   fixedTabPage1.move(textbox, 10, 10);
 
   fixedTabPage1.add(radioTop);
   fixedTabPage1.move(radioTop, 10, 40);
   radioTop.set_label("Top");
   radioTop.set_group(radioButtonGroup);
   radioTop.signal_toggled().connect([this]() {
     tabControl1.set_tab_pos(PositionType::POS_TOP);
   });
 
   fixedTabPage1.add(radioLeft);
   fixedTabPage1.move(radioLeft, 10, 70);
   radioLeft.set_label("Left");
   radioLeft.set_group(radioButtonGroup);
   radioLeft.signal_toggled().connect([this]() {
     tabControl1.set_tab_pos(PositionType::POS_LEFT);
   });
 
   fixedTabPage1.add(radioRight);
   fixedTabPage1.move(radioRight, 10, 100);
   radioRight.set_label("Right");
   radioRight.set_group(radioButtonGroup);
   radioRight.signal_toggled().connect([this]() {
     tabControl1.set_tab_pos(PositionType::POS_RIGHT);
   });
 
   fixedTabPage1.add(radioBottom);
   fixedTabPage1.move(radioBottom, 10, 130);
   radioBottom.set_label("Bottom");
   radioBottom.set_group(radioButtonGroup);
   radioBottom.signal_toggled().connect([this]() {
     tabControl1.set_tab_pos(PositionType::POS_BOTTOM);
   });
 
+    // eval tab
+
+  labelPage6.set_label("Оценка");
+  tabControl1.set_tab_label(tabPage6, labelPage6);
+  tabPage6.add(fixedTabPage6);
+
+  evalTitle.set_text("Симуляция: модель против эвристики");
+  fixedTabPage6.add(evalTitle);
+  fixedTabPage6.move(evalTitle, 10, 10);
+
+  evalGamesLabel.set_text("Количество игр:");
+  fixedTabPage6.add(evalGamesLabel);
+  fixedTabPage6.move(evalGamesLabel, 10, 45);
+
+  evalGamesAdjustment = Gtk::Adjustment::create(50, 1, 10000, 1, 10, 0);
+  evalGamesSpin.set_adjustment(evalGamesAdjustment);
+  evalGamesSpin.set_numeric(true);
+  evalGamesSpin.set_digits(0);
+  evalGamesSpin.set_value(50);
+  evalGamesSpin.set_size_request(120, -1);
+  fixedTabPage6.add(evalGamesSpin);
+  fixedTabPage6.move(evalGamesSpin, 150, 40);
+
+  evalRunButton.set_label("Запустить симуляцию");
+  evalRunButton.signal_button_release_event().connect([this](GdkEventButton*) {
+    startEvalInBackground();
+    return true;
+  });
+  fixedTabPage6.add(evalRunButton);
+  fixedTabPage6.move(evalRunButton, 300, 40);
+
+  evalLogView.set_editable(false);
+  evalLogView.set_wrap_mode(Gtk::WRAP_WORD_CHAR);
+  auto evalBuffer = Gtk::TextBuffer::create();
+  evalLogView.set_buffer(evalBuffer);
+
+  evalLogScroll.set_hexpand(true);
+  evalLogScroll.set_vexpand(true);
+  evalLogScroll.set_policy(PolicyType::POLICY_AUTOMATIC, PolicyType::POLICY_AUTOMATIC);
+  evalLogScroll.set_size_request(900, 600);
+  evalLogScroll.add(evalLogView);
+  fixedTabPage6.add(evalLogScroll);
+  fixedTabPage6.move(evalLogScroll, 10, 90);
+
     // train tab
 
   savetoTxt(enemyUnits, modelUnits);
 
   labelPage2.set_label("Train");
   tabControl1.set_tab_label(tabPage2, labelPage2);
   tabPage2.add(fixedTabPage2);
 
   textbox1.set_text("Train Model:");
   setStatusMessage("Press the Train button to train a model");
     
   button1.set_label("Train");
   button1.signal_button_release_event().connect([&](GdkEventButton*) {
     saveLastRoster();
     syncEnemyUnitsFromRoster();
     updateInits(modelClass, enemyClass);
     if (exists_test("data.json") && training == false) {
       setStatusMessage("Training...");
       trainEnvPrefix = "";
       trainingStartLabel = "обучения";
       trainingStatusLabel = "Обучение";
       trainingLogTag = "TRAIN";
       startTrainInBackground();
     }
     return true;
@@ -789,69 +835,143 @@ Form :: Form() {
     syncEnemyUnitsFromRoster();
     saveLastRoster();
   }
   signal_hide().connect([this]() {
     saveLastRoster();
     saveWindowGeometry();
   });
   show_all();
 }
 
 void Form :: setStatusMessage(const std::string& message) {
   status.set_text(message);
   appendLogLine(message);
 }
 
 void Form :: appendLogLine(const std::string& message) {
   auto logBuffer = logView.get_buffer();
   if (!logBuffer) {
     return;
   }
   logBuffer->insert(logBuffer->end(), message + "\n");
   auto endIter = logBuffer->end();
   logView.scroll_to(endIter);
 }
 
+void Form :: appendEvalLogLine(const std::string& message) {
+  auto logBuffer = evalLogView.get_buffer();
+  if (!logBuffer) {
+    return;
+  }
+  logBuffer->insert(logBuffer->end(), message + "\n");
+  auto endIter = logBuffer->end();
+  evalLogView.scroll_to(endIter);
+}
+
 void Form :: appendTrainingLogToFile(const std::string& message, const std::string& tag) {
   fs::path logPath = fs::current_path() / "LOGS_FOR_AGENTS.md";
   if (!fs::exists(logPath)) {
     fs::path parentPath = fs::current_path().parent_path() / "LOGS_FOR_AGENTS.md";
     if (fs::exists(parentPath)) {
       logPath = parentPath;
     }
   }
   std::ofstream outfile(logPath, std::ios::app);
   if (!outfile) {
     Glib::signal_idle().connect_once([this]() {
       appendLogLine(
           "Ошибка записи в LOGS_FOR_AGENTS.md (gui/Application.cpp): проверьте путь и права доступа.");
     });
     return;
   }
   outfile << nowTimestamp() << " | [GUI][" << tag << "] " << message << "\n";
 }
 
+void Form :: startEvalInBackground() {
+  if (evaluating) {
+    appendEvalLogLine("Симуляция уже запущена. Дождитесь завершения.");
+    return;
+  }
+  int games = static_cast<int>(evalGamesSpin.get_value());
+  if (games < 1 || games > 10000) {
+    appendEvalLogLine("Некорректное значение N. Укажите число от 1 до 10000.");
+    return;
+  }
+  std::thread t(&Form::startEval, this, games);
+  t.detach();
+}
+
+void Form :: startEval(int games) {
+  evaluating = true;
+  Glib::signal_idle().connect_once([this, games]() {
+    appendEvalLogLine("Старт симуляции: игр=" + std::to_string(games));
+  });
+
+  std::string command = "cd .. ; FORCE_GREEDY=1 EVAL_EPSILON=0 python3 -u eval.py --games ";
+  command.append(std::to_string(games));
+  command.append(" 2>&1");
+
+  FILE* pipe = popen(command.c_str(), "r");
+  if (!pipe) {
+    std::string errorMessage = "Ошибка запуска симуляции (gui/Application.cpp): "
+        "проверьте, что eval.py доступен.";
+    Glib::signal_idle().connect_once([this, errorMessage]() {
+      appendEvalLogLine(errorMessage);
+    });
+    evaluating = false;
+    return;
+  }
+
+  std::array<char, 512> buffer{};
+  while (fgets(buffer.data(), static_cast<int>(buffer.size()), pipe)) {
+    std::string line(buffer.data());
+    while (!line.empty() && (line.back() == '\n' || line.back() == '\r')) {
+      line.pop_back();
+    }
+    if (line.empty()) {
+      continue;
+    }
+    Glib::signal_idle().connect_once([this, line]() {
+      appendEvalLogLine(line);
+    });
+  }
+
+  int exitCode = pclose(pipe);
+  if (exitCode == 0) {
+    Glib::signal_idle().connect_once([this]() {
+      appendEvalLogLine("Симуляция завершена.");
+    });
+  } else {
+    std::string errLine = "Симуляция завершена с ошибкой. Код выхода: "
+        + std::to_string(exitCode);
+    Glib::signal_idle().connect_once([this, errLine]() {
+      appendEvalLogLine(errLine);
+    });
+  }
+  evaluating = false;
+}
+
 bool Form :: loadWindowGeometry() {
   std::ifstream infile(geometryPath());
   if (!infile) {
     return false;
   }
   int width = 0;
   int height = 0;
   if (!(infile >> width >> height)) {
     return false;
   }
   set_default_size(width, height);
   return true;
 }
 
 void Form :: saveWindowGeometry() {
   std::string path = geometryPath();
   fs::create_directories(fs::path(path).parent_path());
   int width = 0;
   int height = 0;
   get_size(width, height);
   std::ofstream outfile(path);
   if (!outfile) {
     return;
   }
   outfile << width << " " << height;
diff --git a/gui/include/Application.h b/gui/include/Application.h
index be899d2e5ffbe2356d29afcd51280208946740af..eddc20caba486afa6cf357ce10699a93245c46f8 100644
--- a/gui/include/Application.h
+++ b/gui/include/Application.h
@@ -24,102 +24,108 @@ public :
   void update_picture();
   void update_metrics();
   void updateInits(std::string model, std::string enemy);
   void startTrainInBackground();
   void startTrain();
   void runPlayAgainstModelInBackground();
   void playAgainstModel();
   inline bool exists_test (const std::string& name);
   void on_dropdown_changed();
   void savetoTxt(const std::vector<RosterEntry>& enemyUnits, const std::vector<RosterEntry>& modelUnits);
   bool isValidUnit(int id, std::string name);
   int openArmyView();
   int openWarnMenu(std::string mess, int comm);
   int openHelpMenu();
   int openPlayGUI();
   void changeMetrics(std::string path);
   void recentMetrics();
   std::string toLower(std::string data);
   void mirrorRoster();
   void saveLastRoster();
   void loadLastRoster();
   void syncEnemyUnitsFromRoster();
   bool addEnemyUnitFromEntry(const std::string& entryText);
   void resetLayout();
   void appendLogLine(const std::string& message);
+  void appendEvalLogLine(const std::string& message);
   void appendTrainingLogToFile(const std::string& message, const std::string& tag = "TRAIN");
+  void startEvalInBackground();
+  void startEval(int games);
 
 private:
   void setStatusMessage(const std::string& message);
   void applyFactionToModel(const std::string& faction);
   void applyFactionToEnemy(const std::string& faction);
   bool loadWindowGeometry();
   void saveWindowGeometry();
   void ensureMinimumSize();
   Window* boardShow;
   Window* armyView;
   Window* warn;
   Window* play;
   Window* helpMenu;
   Image pictureBox1;
   Image metricBox;
   Image metricBox2;
   Image metricBox3;
 Image metricBox4;
 Image metricBox5;
 Image metricBox6;
   Box rootBox;
   Box topBarBox;
   Box leftBox;
   Paned mainSplit;
   Paned rightSplit;
   Frame boardFrame;
   ScrolledWindow logScroll;
   TextView logView;
   Label showModelHint;
   Notebook tabControl1;
   Label labelPage1;
   Label labelPage2;
   Label labelPage3;
   Label labelPage4;
   Label labelPage5;
+  Label labelPage6;
   Label label1;
   Frame tabPage1;
   Frame tabPage2;
   Frame tabPage3;
   Frame tabPage4;
   Frame tabPage5;
+  Frame tabPage6;
   RadioButtonGroup radioButtonGroup;
   RadioButton radioTop;
   RadioButton radioLeft;
   RadioButton radioRight;
   RadioButton radioBottom;
   Fixed fixedTabPage1;
   Fixed fixedTabPage2;
   Fixed fixedTabPage3;
   Fixed fixedTabPage4;
   Fixed fixedTabPage5;
+  Fixed fixedTabPage6;
   Button button1;
   Button buttonTrain6;
   Button button2;
   Button button3;
   Button button4;
   Button button5;
   Button button6;
   Button buttonSelfPlay;
   Button showBoard;
   Button showBoardImg;
   Button playGraphicsView;
   Label textbox;
   Label textbox2;
   Label textbox1;
   Label enemyFact;
   Label modelFact;
   Label status;
   Entry setIters;
   Entry setModelFile;
   RadioButtonGroup factionModel;
   RadioButton orksModel;
   RadioButton spmModel;
   RadioButton sobModel;
   RadioButton adcModel;
   RadioButton tyrModel;
@@ -157,28 +163,36 @@ Image metricBox6;
   Entry enterEnemyUnit;
   Button clearAllModel;
   Button clearAllEnemy;
   int x;
   int y;
   bool open;
   bool training;
   bool playing;
   bool loadingRoster;
   Label error;
   Label modelUnitLabel;
   Label enemyUnitLabel;
   std::vector<RosterEntry> modelUnits;
   std::vector<RosterEntry> enemyUnits;
   RosterModel rosterModel;
   HeaderBar bar;
   Button help;
   Button resetLayoutButton;
   Button chooseMetrics;
   Button playGUI;
   std::string playInGUI;
   std::string trainEnvPrefix;
   std::string trainingStartLabel;
   std::string trainingStatusLabel;
   std::string trainingLogTag;
+  Label evalTitle;
+  Label evalGamesLabel;
+  Glib::RefPtr<Gtk::Adjustment> evalGamesAdjustment;
+  SpinButton evalGamesSpin;
+  Button evalRunButton;
+  ScrolledWindow evalLogScroll;
+  TextView evalLogView;
+  bool evaluating;
 };
 
 #endif

