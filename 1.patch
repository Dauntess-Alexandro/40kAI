diff --git a/gui/Application.cpp b/gui/Application.cpp
index e7d03436191b7e6da7e1b6770b3a937abd98554b..5f21efd4ef19cfac42c0c54ab471e1b59d498344 100644
--- a/gui/Application.cpp
+++ b/gui/Application.cpp
@@ -182,147 +182,129 @@ std::string formatDuration(std::chrono::seconds duration) {
   } else {
     oss << std::setfill('0') << std::setw(2) << minutes << ":"
         << std::setw(2) << seconds;
   }
   return oss.str();
 }
 
 std::string buildTrainingStatsLine(double itPerSec,
                                    std::chrono::seconds elapsed,
                                    bool showEta,
                                    std::chrono::seconds eta) {
   std::ostringstream oss;
   if (itPerSec > 0.0) {
     oss << std::fixed << std::setprecision(1) << itPerSec << " it/s";
   } else {
     oss << "— it/s";
   }
   oss << " • elapsed " << formatDuration(elapsed);
   if (showEta) {
     oss << " • ETA " << formatDuration(eta);
   }
   return oss.str();
 }
 }  // namespace
 
-std::string gifpth = "img/model_train.gif";
 std::string rewpth = "img/reward.png";
 std::string losspth = "img/loss.png";
 std::string eplenpth = "img/epLen.png";
 std::string winratepth = "img/winrate.png";
 std::string vpdiffpth = "img/vpdiff.png";
 std::string endreasonpth = "img/endreasons.png";
 std::string imgpth = "img/icon.png";
 
 Form :: Form() {
 
   modelClass = " Necrons";
   enemyClass = " Necrons";
   path = " ";
   open = false;
   x = 60;
   y = 40;
   training = false;
   playing = false;
   loadingRoster = false;
   hideTrainingLogs = true;
   trainingTotalEpisodes = 0;
   trainEnvPrefix = "";
   trainingStartLabel = "обучения";
   trainingStatusLabel = "Обучение";
   trainingLogTag = "TRAIN";
   evaluating = false;
 
   bar.set_show_close_button(true);
   bar.set_title("40kAI GUI");
   set_titlebar(bar);
 
   set_default_size(kDefaultWidth, kDefaultHeight);
   set_size_request(kMinimumWidth, kMinimumHeight);
 
   rootBox.set_orientation(Gtk::ORIENTATION_VERTICAL);
   topBarBox.set_orientation(Gtk::ORIENTATION_HORIZONTAL);
   topBarBox.set_spacing(8);
   leftBox.set_orientation(Gtk::ORIENTATION_VERTICAL);
-  mainSplit.set_orientation(Gtk::ORIENTATION_HORIZONTAL);
-  rightSplit.set_orientation(Gtk::ORIENTATION_VERTICAL);
 
   rootBox.set_hexpand(true);
   rootBox.set_vexpand(true);
   topBarBox.set_hexpand(true);
   leftBox.set_hexpand(true);
   leftBox.set_vexpand(true);
-  mainSplit.set_hexpand(true);
-  mainSplit.set_vexpand(true);
-  rightSplit.set_hexpand(true);
-  rightSplit.set_vexpand(true);
 
   help.set_image_from_icon_name("help-about");
   help.signal_button_release_event().connect([&](GdkEventButton*){
     openHelpMenu();
     return true;
   });
   resetLayoutButton.set_label("Reset Layout");
   resetLayoutButton.signal_button_release_event().connect([&](GdkEventButton*) {
     resetLayout();
     return true;
   });
   topBarBox.pack_start(resetLayoutButton, Gtk::PACK_SHRINK);
   topBarBox.pack_start(help, Gtk::PACK_SHRINK);
 
   add(rootBox);
   rootBox.pack_start(topBarBox, Gtk::PACK_SHRINK);
-  rootBox.pack_start(mainSplit, Gtk::PACK_EXPAND_WIDGET);
+  rootBox.pack_start(leftBox, Gtk::PACK_EXPAND_WIDGET);
 
   tabControl1.set_hexpand(true);
   tabControl1.set_vexpand(true);
   leftBox.pack_start(tabControl1, Gtk::PACK_EXPAND_WIDGET);
 
-  mainSplit.add1(leftBox);
-  mainSplit.add2(rightSplit);
-
-  boardFrame.set_label("Board / Preview");
-  boardFrame.set_hexpand(true);
-  boardFrame.set_vexpand(true);
-  pictureBox1.set_hexpand(true);
-  pictureBox1.set_vexpand(true);
-  boardFrame.add(pictureBox1);
-
   logView.set_hexpand(true);
   logView.set_vexpand(true);
   logView.set_editable(false);
   logView.set_wrap_mode(Gtk::WRAP_WORD_CHAR);
   auto logBuffer = Gtk::TextBuffer::create();
   logView.set_buffer(logBuffer);
 
   logScroll.set_hexpand(true);
   logScroll.set_vexpand(true);
   logScroll.set_policy(PolicyType::POLICY_AUTOMATIC, PolicyType::POLICY_AUTOMATIC);
   logScroll.add(logView);
 
-  rightSplit.add1(boardFrame);
-  rightSplit.add2(logScroll);
+  leftBox.pack_start(logScroll, Gtk::PACK_EXPAND_WIDGET);
 
   tabControl1.insert_page(tabPage2, "Train", 0);
   tabControl1.insert_page(tabPage3, "Show Trained Model", 1);
   tabControl1.insert_page(tabPage5, "Metrics", 2);
   tabControl1.insert_page(tabPage4, "Play", 3);
   tabControl1.insert_page(tabPage1, "Settings", 4);
   tabControl1.insert_page(tabPage6, "Оценка", 5);
 
     // settings tab
 
   labelPage1.set_label("Settings");
   tabControl1.set_tab_label(tabPage1, labelPage1);
   tabPage1.add(fixedTabPage1);
 
   textbox.set_text("Change Tab Location:");
   fixedTabPage1.add(textbox);
   fixedTabPage1.move(textbox, 10, 10);
 
   fixedTabPage1.add(radioTop);
   fixedTabPage1.move(radioTop, 10, 40);
   radioTop.set_label("Top");
   radioTop.set_group(radioButtonGroup);
   radioTop.signal_toggled().connect([this]() {
     tabControl1.set_tab_pos(PositionType::POS_TOP);
   });
@@ -804,55 +786,51 @@ Form :: Form() {
   fixedTabPage2.add(button1);
   fixedTabPage2.move(button1, 380, 300);
   fixedTabPage2.add(buttonTrain6);
   fixedTabPage2.move(buttonTrain6, 470, 300);
   fixedTabPage2.add(setIters);
   fixedTabPage2.move(setIters, 160, 40);
   fixedTabPage2.add(button3);
   fixedTabPage2.move(button3, 10, 300);
   fixedTabPage2.add(buttonSelfPlay);
   fixedTabPage2.move(buttonSelfPlay, 200, 300);
   fixedTabPage2.add(status);
   fixedTabPage2.move(status, 10, 350);
   fixedTabPage2.add(trainingProgressLabel);
   fixedTabPage2.move(trainingProgressLabel, 10, 380);
   fixedTabPage2.add(trainingProgress);
   fixedTabPage2.move(trainingProgress, 10, 400);
   fixedTabPage2.add(trainingProgressStatsLabel);
   fixedTabPage2.move(trainingProgressStatsLabel, 10, 430);
 
     // show trained model tab
 
   labelPage3.set_label("Show Trained Model");
   tabControl1.set_tab_label(tabPage3, labelPage3);
   tabPage3.add(fixedTabPage3);
 
-  showModelHint.set_text("Preview shown in the right panel.");
-  fixedTabPage3.add(showModelHint);
-  fixedTabPage3.move(showModelHint, 10, 10);
-  pictureBox1.set_size_request(280, 280);
-  update_picture();
+  // no preview panel
 
   // show metrics tab
   labelPage5.set_label("Model Metrics");
   tabControl1.set_tab_label(tabPage5, labelPage5);
   tabPage5.add(fixedTabPage5);
   
   chooseMetrics.set_label("Choose");
   chooseMetrics.signal_button_release_event().connect([&](GdkEventButton * event){
 	FileChooserDialog folderBrowserDialog("", FILE_CHOOSER_ACTION_OPEN);
     folderBrowserDialog.add_button("Cancel", RESPONSE_CANCEL);
     folderBrowserDialog.add_button("Open", RESPONSE_OK);
 	system("clear");
     char resolved_path[PATH_MAX];
     realpath("../../40kAI", resolved_path);
     strcat(resolved_path, "/models");
     folderBrowserDialog.set_current_folder(resolved_path);
     folderBrowserDialog.set_transient_for(*this);
 
     auto filter_text = Gtk::FileFilter::create();
     filter_text->set_name("Pickle Files");
     filter_text->add_pattern("*.pickle");
     folderBrowserDialog.add_filter(filter_text);
 
     if (folderBrowserDialog.run() == RESPONSE_OK) {
       path = folderBrowserDialog.get_file()->get_path();
@@ -903,73 +881,65 @@ Form :: Form() {
     system("clear");
     char resolved_path[PATH_MAX];
     realpath("../../40kAI", resolved_path);
     strcat(resolved_path, "/models");
     folderBrowserDialog.set_current_folder(resolved_path);
     folderBrowserDialog.set_transient_for(*this);
 
     auto filter_text = Gtk::FileFilter::create();
     filter_text->set_name("Pickle Files");
     filter_text->add_pattern("*.pickle");
     folderBrowserDialog.add_filter(filter_text);
 
     if (folderBrowserDialog.run() == RESPONSE_OK) {
       path = folderBrowserDialog.get_file()->get_path();
       setModelFile.set_text(path);
     }
     return true;
   });
   
   showBoard.set_label("Show Board (Ascii Mode)");
   showBoard.signal_button_release_event().connect([&](GdkEventButton* event) {
     openPopUp(true);
     return true;
   });
 
-  showBoardImg.set_label("Show Board (Image Mode)");
-  showBoardImg.signal_button_release_event().connect([&](GdkEventButton* event) {
-	openPopUp(false);
-	return true;
-  });
-
   playGraphicsView.set_label("Играть в GUI");
   playGraphicsView.signal_button_release_event().connect([&](GdkEventButton* event) {
     system("cd .. && scripts/viewer.sh &");
     return true;
   });
 
   fixedTabPage4.add(textbox2);
   fixedTabPage4.add(button2);
   fixedTabPage4.add(showBoard);
-  fixedTabPage4.add(showBoardImg);
   fixedTabPage4.add(playGraphicsView);
   fixedTabPage4.add(button5);
   fixedTabPage4.add(setModelFile);
   fixedTabPage4.move(textbox2, 10, 10);
   fixedTabPage4.move(playGraphicsView, 130, 80);
   fixedTabPage4.move(showBoard, 395, 80);
-  fixedTabPage4.move(showBoardImg, 570, 80);
   fixedTabPage4.move(button2, 10, 80);
   fixedTabPage4.move(button5, 10, 40);
   fixedTabPage4.move(setModelFile, 80, 40);
 
   loadWindowGeometry();
   loadLastRoster();
   if (modelUnits.empty()) {
     modelUnits.push_back({"Apothecary", "Space_Marine", findDefaultModelsCount("Space_Marine", "Apothecary"),
                           RosterModel::generateInstanceId()});
     modelUnits.push_back({"Eliminator Squad", "Space_Marine",
                           findDefaultModelsCount("Space_Marine", "Eliminator Squad"),
                           RosterModel::generateInstanceId()});
   }
   if (enemyUnits.empty()) {
     rosterModel.addUnit("Apothecary", 1, enemyClass.substr(1));
     rosterModel.addUnit("Eliminator Squad", 1, enemyClass.substr(1));
     syncEnemyUnitsFromRoster();
     saveLastRoster();
   }
   signal_hide().connect([this]() {
     saveLastRoster();
     saveWindowGeometry();
   });
   show_all();
 }
@@ -1405,54 +1375,50 @@ bool Form :: isValidUnit(int id, std::string name) {
   return false;
 }
 
 void Form :: savetoTxt(const std::vector<RosterEntry>& enemyUnits, const std::vector<RosterEntry>& modelUnits) {
 
   std::ofstream outfile("units.txt");
   outfile << "Player Units\n";
   for (const auto& entry : enemyUnits) {
     outfile << entry.name << "|" << entry.modelsCount;
     if (!entry.instanceId.empty()) {
       outfile << "|" << entry.instanceId;
     }
     outfile << std::endl;
   }
   outfile << "Model Units\n";
   for (const auto& entry : modelUnits) {
     outfile << entry.name << "|" << entry.modelsCount;
     if (!entry.instanceId.empty()) {
       outfile << "|" << entry.instanceId;
     }
     outfile << std::endl;
   }
   outfile.close();
 }
 
-void Form :: update_picture() {
-  pictureBox1.set(gifpth);
-}
-
 void Form :: update_metrics() {
 
   const int IMG_W = 330;
   const int IMG_H = 160;
 
   auto load_scaled = [&](const std::string& rel) -> Glib::RefPtr<Gdk::Pixbuf> {
     std::string path = "../gui/" + rel;
     if (!fs::exists(path)) {
       return Glib::RefPtr<Gdk::Pixbuf>();
     }
     auto pix = Gdk::Pixbuf::create_from_file(path);
     return pix->scale_simple(IMG_W, IMG_H, Gdk::INTERP_BILINEAR);
   };
 
   if (auto p = load_scaled(rewpth)) metricBox.set(p);
   if (auto p = load_scaled(losspth)) metricBox2.set(p);
   if (auto p = load_scaled(winratepth)) metricBox4.set(p);
   if (auto p = load_scaled(vpdiffpth)) metricBox5.set(p);
   if (auto p = load_scaled(eplenpth)) metricBox3.set(p);
   if (auto p = load_scaled(endreasonpth)) metricBox6.set(p);
 
 }
 
 void Form :: updateInits(std::string model, std::string enemy) {
   std::string command = "cd .. ; ./data.sh ";
@@ -1577,51 +1543,50 @@ void Form :: startTrain() {
     });
     appendTrainingLogToFile(doneMessage, trainingLogTag);
     auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(
         std::chrono::steady_clock::now() - trainingStartTime);
     std::string finalStats = trainingStatusLabel + " завершено • elapsed "
         + formatDuration(elapsed);
     Glib::signal_idle().connect_once([this, finalStats]() {
       trainingProgressStatsLabel.set_text(finalStats);
     });
   } else {
     std::string errLine = trainingStatusLabel + " завершено с ошибкой. Код выхода: "
         + std::to_string(exitCode);
     Glib::signal_idle().connect_once([this, errLine]() {
       setStatusMessage(errLine);
     });
     appendTrainingLogToFile(errLine, trainingLogTag);
     auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(
         std::chrono::steady_clock::now() - trainingStartTime);
     std::string finalStats = trainingStatusLabel + " завершено с ошибкой • elapsed "
         + formatDuration(elapsed);
     Glib::signal_idle().connect_once([this, finalStats]() {
       trainingProgressStatsLabel.set_text(finalStats);
     });
   }
   Glib::signal_idle().connect_once([this]() {
-    update_picture();
     update_metrics();
   });
 }
 
 void Form :: runPlayAgainstModelInBackground() {
   std::thread t(&Form::playAgainstModel, this);
   t.detach();
 }
   
 void Form :: playAgainstModel() {
   path = setModelFile.get_text();
 
   std::string envPrefix;
 
   std::string command;
 
   if (playInGUI == "True") {
     envPrefix = "PLAY_NO_EXPLORATION=1 FIGHT_REPORT=1 ";
     command = "cd .. ; " + envPrefix + "./play.sh ";
     if (strlen(path.data()) < 2) {
       command.append("None");
     } else {
       command.append("\"");
       command.append(path);
       command.append("\"");
diff --git a/gui/include/Application.h b/gui/include/Application.h
index a970b605e49e1c917c85de5ad57e530a3086a0b8..0cd6afea1ceb9ca18178407786f23a32a94c7147 100644
--- a/gui/include/Application.h
+++ b/gui/include/Application.h
@@ -1,146 +1,139 @@
 #ifndef APP_H
 #define APP_H
 
 #include <iostream>
 #include <gtkmm.h>
 #include <cstdlib>
 #include <stdlib.h>
 #include <string>
 #include <fstream>
 #include <thread>
 #include <chrono>
 #include <filesystem>
 #include <deque>
 #include "RosterModel.h"
 #include "popup.h"
 #include "units.h"
 #include "warn.h"
 #include "help.h"
 
 class Form : public Window {
 
 public : 
   Form();
   int openPopUp(bool textMode);
-  void update_picture();
   void update_metrics();
   void updateInits(std::string model, std::string enemy);
   void startTrainInBackground();
   void startTrain();
   void runPlayAgainstModelInBackground();
   void playAgainstModel();
   inline bool exists_test (const std::string& name);
   void on_dropdown_changed();
   void savetoTxt(const std::vector<RosterEntry>& enemyUnits, const std::vector<RosterEntry>& modelUnits);
   bool isValidUnit(int id, std::string name);
   int openArmyView();
   int openWarnMenu(std::string mess, int comm);
   int openHelpMenu();
   int openPlayGUI();
   void changeMetrics(std::string path);
   void recentMetrics();
   std::string toLower(std::string data);
   void mirrorRoster();
   void saveLastRoster();
   void loadLastRoster();
   void syncEnemyUnitsFromRoster();
   bool addEnemyUnitFromEntry(const std::string& entryText);
   void resetLayout();
   void appendLogLine(const std::string& message);
   void appendEvalLogLine(const std::string& message);
   void appendTrainingLogToFile(const std::string& message, const std::string& tag = "TRAIN");
   void startEvalInBackground();
   void startEval(int games);
 
 private:
   void setStatusMessage(const std::string& message);
   void updateTrainingProgress(int current, int total);
   void resetTrainingProgressStats();
   void recordTrainingSample(int episode, std::chrono::steady_clock::time_point now);
   double calculateTrainingRate() const;
   void applyFactionToModel(const std::string& faction);
   void applyFactionToEnemy(const std::string& faction);
   bool loadWindowGeometry();
   void saveWindowGeometry();
   void ensureMinimumSize();
   Window* boardShow;
   Window* armyView;
   Window* warn;
   Window* play;
   Window* helpMenu;
-  Image pictureBox1;
   Image metricBox;
   Image metricBox2;
   Image metricBox3;
 Image metricBox4;
 Image metricBox5;
 Image metricBox6;
   Box rootBox;
   Box topBarBox;
   Box leftBox;
-  Paned mainSplit;
-  Paned rightSplit;
-  Frame boardFrame;
   ScrolledWindow logScroll;
   TextView logView;
-  Label showModelHint;
   Notebook tabControl1;
   Label labelPage1;
   Label labelPage2;
   Label labelPage3;
   Label labelPage4;
   Label labelPage5;
   Label labelPage6;
   Label label1;
   Frame tabPage1;
   Frame tabPage2;
   Frame tabPage3;
   Frame tabPage4;
   Frame tabPage5;
   Frame tabPage6;
   RadioButtonGroup radioButtonGroup;
   RadioButton radioTop;
   RadioButton radioLeft;
   RadioButton radioRight;
   RadioButton radioBottom;
   Fixed fixedTabPage1;
   Fixed fixedTabPage2;
   Fixed fixedTabPage3;
   Fixed fixedTabPage4;
   Fixed fixedTabPage5;
   Fixed fixedTabPage6;
   Button button1;
   Button buttonTrain6;
   Button button2;
   Button button3;
   Button button4;
   Button button5;
   Button button6;
   Button buttonSelfPlay;
   Button showBoard;
-  Button showBoardImg;
   Button playGraphicsView;
   Label textbox;
   Label textbox2;
   Label textbox1;
   Label enemyFact;
   Label modelFact;
   Label status;
   Label trainingProgressLabel;
   Label trainingProgressStatsLabel;
   ProgressBar trainingProgress;
   Entry setIters;
   Entry setModelFile;
   RadioButtonGroup factionModel;
   RadioButton orksModel;
   RadioButton spmModel;
   RadioButton sobModel;
   RadioButton adcModel;
   RadioButton tyrModel;
   RadioButton milModel;
   RadioButton tauModel;
   RadioButton necModel;
   RadioButtonGroup factionEnemy;
   RadioButton orksEnemy;
   RadioButton spmEnemy;
   RadioButton sobEnemy;

