 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/gui/Application.cpp b/gui/Application.cpp
index ecbaed27d908db74a28526b293afcb223ba3e887..638917de3d7ecfb094b6fa2cf31e820748f72216 100644
--- a/gui/Application.cpp
+++ b/gui/Application.cpp
@@ -2,50 +2,61 @@
 #include <gtkmm.h>
 #include <cstdlib>
 #include <stdlib.h>
 #include <string>
 #include <fstream>
 #include <thread>
 #include <chrono>
 #include <fstream>
 #include <filesystem>
 #include <vector>
 #include <algorithm>
 #include <nlohmann/json.hpp>
 #include "include/Application.h"
 #include "include/popup.h"
 #include "include/units.h"
 #include "include/warn.h"
 #include "include/help.h"
 #include "include/play.h"
 
 using namespace Glib;
 using namespace Gtk;
 namespace fs = std::filesystem;
 using json = nlohmann::json;
 
 namespace {
+constexpr int kDefaultWidth = 1400;
+constexpr int kDefaultHeight = 900;
+constexpr int kMinimumWidth = 1100;
+constexpr int kMinimumHeight = 700;
+
+std::string geometryPath() {
+  const char* home = std::getenv("HOME");
+  std::string base = home ? home : ".";
+  return base + "/.config/40kAI/gui_layout.conf";
+}
+
 std::string toLowerCopy(std::string data) {
   std::transform(data.begin(), data.end(), data.begin(),
                  [](unsigned char c) { return static_cast<char>(std::tolower(c)); });
   return data;
 }
 
 int findDefaultModelsCount(const std::string& faction, const std::string& name) {
   std::ifstream infile("../gym_mod/gym_mod/engine/unitData.json");
   if (!infile) {
     return 1;
   }
   json j;
   infile >> j;
   if (!j.contains("UnitData") || !j.at("UnitData").is_array()) {
     return 1;
   }
   std::string factionLower = toLowerCopy(faction);
   std::string nameLower = toLowerCopy(name);
   for (const auto& unit : j.at("UnitData")) {
     if (!unit.contains("Name") || !unit.contains("Army")) {
       continue;
     }
     if (toLowerCopy(unit.at("Name").get<std::string>()) != nameLower) {
       continue;
     }
@@ -66,55 +77,61 @@ std::string rewpth = "img/reward.png";
 std::string losspth = "img/loss.png";
 std::string eplenpth = "img/epLen.png";
 std::string winratepth = "img/winrate.png";
 std::string vpdiffpth = "img/vpdiff.png";
 std::string endreasonpth = "img/endreasons.png";
 std::string imgpth = "img/icon.png";
 
 Form :: Form() {
 
   modelClass = " Necrons";
   enemyClass = " Necrons";
   path = " ";
   open = false;
   x = 60;
   y = 40;
   training = false;
   playing = false;
   loadingRoster = false;
 
   bar.set_show_close_button(true);
   help.set_image_from_icon_name("help-about");
   help.signal_button_release_event().connect([&](GdkEventButton*){
     openHelpMenu();
     return true;
   });
+  resetLayoutButton.set_label("Reset Layout");
+  resetLayoutButton.signal_button_release_event().connect([&](GdkEventButton*) {
+    resetLayout();
+    return true;
+  });
   bar.pack_end(help);
+  bar.pack_start(resetLayoutButton);
   set_titlebar(bar);
 
-  set_default_size(1200, 900);
-  set_size_request(1000, 700);
+  set_default_size(kDefaultWidth, kDefaultHeight);
+  set_size_request(kMinimumWidth, kMinimumHeight);
   scrolledWindow.set_policy(PolicyType::POLICY_AUTOMATIC, PolicyType::POLICY_AUTOMATIC);
 
   add(scrolledWindow);
   scrolledWindow.add(fixed);
 
   fixed.add(tabControl1);
   fixed.move(tabControl1, 10, 10);
 
   tabControl1.insert_page(tabPage2, "Train", 0);
   tabControl1.insert_page(tabPage3, "Show Trained Model", 1);
   tabControl1.insert_page(tabPage5, "Metrics", 2);
   tabControl1.insert_page(tabPage4, "Play", 3);
   tabControl1.insert_page(tabPage1, "Settings", 4);
 
     // settings tab
 
   labelPage1.set_label("Settings");
   tabControl1.set_tab_label(tabPage1, labelPage1);
   tabPage1.add(fixedTabPage1);
 
   textbox.set_text("Change Tab Location:");
   fixedTabPage1.add(textbox);
   fixedTabPage1.move(textbox, 10, 10);
 
   fixedTabPage1.add(radioTop);
@@ -632,71 +649,118 @@ Form :: Form() {
 		saveLastRoster();
 		syncEnemyUnitsFromRoster();
 		openPlayGUI();
 		playInGUI = "True";
 		runPlayAgainstModelInBackground();
 	}
 	return true;
   });
 
   fixedTabPage4.add(textbox2);
   fixedTabPage4.add(button2);
   fixedTabPage4.add(showBoard);
   fixedTabPage4.add(showBoardImg);
   fixedTabPage4.add(playGUI);
   fixedTabPage4.add(button5);
   fixedTabPage4.add(setModelFile);
   fixedTabPage4.move(textbox2, 10, 10);
   fixedTabPage4.move(playGUI, 130, 80);
   fixedTabPage4.move(showBoard, 220, 80);
   fixedTabPage4.move(showBoardImg, 395, 80);  
   fixedTabPage4.move(button2, 10, 80);
   fixedTabPage4.move(button5, 10, 40);
   fixedTabPage4.move(setModelFile, 80, 40);
 
   bar.set_title("40kAI GUI");
-  resize(700, 600);
+  if (!loadWindowGeometry()) {
+    resize(kDefaultWidth, kDefaultHeight);
+  }
+  ensureMinimumSize();
   loadLastRoster();
   if (modelUnits.empty()) {
     modelUnits.push_back({"Apothecary", "Space_Marine", findDefaultModelsCount("Space_Marine", "Apothecary"),
                           RosterModel::generateInstanceId()});
     modelUnits.push_back({"Eliminator Squad", "Space_Marine",
                           findDefaultModelsCount("Space_Marine", "Eliminator Squad"),
                           RosterModel::generateInstanceId()});
   }
   if (enemyUnits.empty()) {
     rosterModel.addUnit("Apothecary", 1, enemyClass.substr(1));
     rosterModel.addUnit("Eliminator Squad", 1, enemyClass.substr(1));
     syncEnemyUnitsFromRoster();
     saveLastRoster();
   }
   signal_hide().connect([this]() {
     saveLastRoster();
+    saveWindowGeometry();
   });
   show_all();
 }
 
+bool Form :: loadWindowGeometry() {
+  std::ifstream infile(geometryPath());
+  if (!infile) {
+    return false;
+  }
+  int width = 0;
+  int height = 0;
+  if (!(infile >> width >> height)) {
+    return false;
+  }
+  resize(width, height);
+  return true;
+}
+
+void Form :: saveWindowGeometry() {
+  std::string path = geometryPath();
+  fs::create_directories(fs::path(path).parent_path());
+  int width = 0;
+  int height = 0;
+  get_size(width, height);
+  std::ofstream outfile(path);
+  if (!outfile) {
+    return;
+  }
+  outfile << width << " " << height;
+}
+
+void Form :: ensureMinimumSize() {
+  int width = 0;
+  int height = 0;
+  get_size(width, height);
+  if (width < kMinimumWidth || height < kMinimumHeight) {
+    resize(std::max(width, kMinimumWidth), std::max(height, kMinimumHeight));
+  }
+}
+
+void Form :: resetLayout() {
+  std::error_code ec;
+  fs::remove(geometryPath(), ec);
+  resize(kDefaultWidth, kDefaultHeight);
+  ensureMinimumSize();
+}
+
 void Form :: changeMetrics(std::string path) {
     std::string jsonID = path.substr(path.length()-16,9);
 
 	if (jsonID[0] == '-') {
 		jsonID = path.substr(path.length()-15,8);
 	} 
 
 	std::ifstream infile("../models/data_"+jsonID+".json");
 	json j;
 	infile >> j;
 
 	losspth = j.value("loss", losspth);
 	rewpth = j.value("reward", rewpth);
 	eplenpth = j.value("epLen", eplenpth);
 
 	// optional extra metrics (backwards compatible with older models)
 	winratepth = j.value("winrate", winratepth);
 	vpdiffpth = j.value("vpdiff", vpdiffpth);
 	endreasonpth = j.value("endreasons", endreasonpth);
 
 	update_metrics();
 }
 
 int Form :: openPopUp(bool textMode) {
   boardShow = new PopUp(textMode);
diff --git a/gui/include/Application.h b/gui/include/Application.h
index 3b90c0f0aac55b7c604c81d991581812014efba8..24854b2fb1b005374b81d4450390ddf146213a37 100644
--- a/gui/include/Application.h
+++ b/gui/include/Application.h
@@ -22,54 +22,58 @@ public :
   Form();
   int openPopUp(bool textMode);
   void update_picture();
   void update_metrics();
   void updateInits(std::string model, std::string enemy);
   void startTrainInBackground();
   void startTrain();
   void runPlayAgainstModelInBackground();
   void playAgainstModel();
   inline bool exists_test (const std::string& name);
   void on_dropdown_changed();
   void savetoTxt(const std::vector<RosterEntry>& enemyUnits, const std::vector<RosterEntry>& modelUnits);
   bool isValidUnit(int id, std::string name);
   int openArmyView();
   int openWarnMenu(std::string mess, int comm);
   int openHelpMenu();
   int openPlayGUI();
   void changeMetrics(std::string path);
   void recentMetrics();
   std::string toLower(std::string data);
   void mirrorRoster();
   void saveLastRoster();
   void loadLastRoster();
   void syncEnemyUnitsFromRoster();
   bool addEnemyUnitFromEntry(const std::string& entryText);
+  void resetLayout();
 
 private:
   void applyFactionToModel(const std::string& faction);
   void applyFactionToEnemy(const std::string& faction);
+  bool loadWindowGeometry();
+  void saveWindowGeometry();
+  void ensureMinimumSize();
   Window* boardShow;
   Window* armyView;
   Window* warn;
   Window* play;
   Window* helpMenu;
   Image pictureBox1;
   Image metricBox;
   Image metricBox2;
   Image metricBox3;
 Image metricBox4;
 Image metricBox5;
 Image metricBox6;
   Fixed fixed;
   ScrolledWindow scrolledWindow;
   Notebook tabControl1;
   Label labelPage1;
   Label labelPage2;
   Label labelPage3;
   Label labelPage4;
   Label labelPage5;
   Label label1;
   Frame tabPage1;
   Frame tabPage2;
   Frame tabPage3;
   Frame tabPage4;
@@ -132,31 +136,32 @@ Image metricBox6;
   Button downX;
   Button upY;
   Button downY;
   Button modelEnter;
   Button enemyEnter;
   Button mirrorRosterButton;
   Button openArmyPopup;
   Entry enterModelUnit;
   Entry enterEnemyUnit;
   Button clearAllModel;
   Button clearAllEnemy;
   int x;
   int y;
   bool open;
   bool training;
   bool playing;
   bool loadingRoster;
   Label error;
   Label modelUnitLabel;
   Label enemyUnitLabel;
   std::vector<RosterEntry> modelUnits;
   std::vector<RosterEntry> enemyUnits;
   RosterModel rosterModel;
   HeaderBar bar;
   Button help;
+  Button resetLayoutButton;
   Button chooseMetrics;
   Button playGUI;
   std::string playInGUI;
 };
 
 #endif
diff --git a/gui/include/play.h b/gui/include/play.h
index a1b3c7ea1b92c1b1b715b04350a8b30e8137d90e..f1a95e4a35231eccd77daa99bd0db2264f056cd8 100644
--- a/gui/include/play.h
+++ b/gui/include/play.h
@@ -1,40 +1,49 @@
 #ifndef PLAY_H
 #define PLAY_H
 
 #include <iostream>
 #include <gtkmm.h>
 #include <cstdlib>
 #include <stdlib.h>
 #include <string>
 
 using namespace Glib;
 using namespace Gtk;
 using namespace std;
 
 class Play : public Gtk::Window {
     public:
         Play();
         void update();
         void keepUpdating();
         void backgroundUpdate();
         void update_text_view();
         bool file_exists(char * fileName);
+        std::string openBoardFile(const std::string& board);
     private:
-        Fixed fixed;
-        ScrolledWindow scrolledWindow;
-        ScrolledWindow innerWindow;
+        Box rootBox;
+        Paned mainSplit;
+        Paned rightSplit;
+        Box leftControls;
+        ScrolledWindow boardScroll;
+        ScrolledWindow logScroll;
+        TextView boardView;
+        TextView logView;
+        CheckButton autoScrollToggle;
+        Button clearLogButton;
         HeaderBar bar;
 		Button enter;
         Button plus;
         Button minus;
 		RadioButtonGroup yesOrNoRadio;
   		RadioButton radioYes;
   		RadioButton radioNo;
   		Entry numBox;
-  		Label text;
+        Label responseLabel;
   		bool takeInput;
   		std::string response;
+        std::string boardText;
   		Dispatcher dispatcher;
 };
 
 #endif
diff --git a/gui/play.cpp b/gui/play.cpp
index ab5832603ffbb1b652ed9af04d310a4f693c350a..c0a6fb9efdeb5ce78d722a917bd60cb4e50b8e10 100644
--- a/gui/play.cpp
+++ b/gui/play.cpp
@@ -1,93 +1,196 @@
 #include <iostream>
 #include <gtkmm.h>
 #include <cstdlib>
 #include <stdlib.h>
 #include <string>
 #include <fstream>
 #include <thread>
 #include "include/play.h"
 
 using namespace Glib;
 using namespace Gtk;
 using namespace std;
 
+namespace {
+bool is_board_num(char num) {
+	string nums= "0123456789";
+	for (char n : nums) {
+		if (n == num) {
+			return true;
+		}
+	}
+	return false;
+}
+}
+
 bool Play :: file_exists(char * fileName) {
 	ifstream infile(fileName);
 	return infile.good();
 }
 
 void Play :: update() {
+	bool updated = false;
 	if (file_exists("response.txt")) {
 		ifstream file("response.txt");
 		string line;
 		while(getline(file, line)) {
 			for (int i = 0; line.length() > i; i++) {
 				response += line[i];
 			}
 			response += "\n";
 		}
 		file.close();
+		updated = true;
+	}
+
+	string nextBoard = openBoardFile("../board.txt");
+	if (!nextBoard.empty() && nextBoard != boardText) {
+		boardText = nextBoard;
+		updated = true;
+	}
+
+	if (updated) {
 		dispatcher.emit();
 	}
 }
 
 void Play :: update_text_view() {
-	text.set_text(response);
-	system("rm response.txt");
+	auto logBuffer = logView.get_buffer();
+	if (logBuffer) {
+		logBuffer->set_text(response);
+		if (autoScrollToggle.get_active()) {
+			auto endIter = logBuffer->end();
+			logBuffer->place_cursor(endIter);
+			logView.scroll_to(endIter);
+		}
+	}
+	auto boardBuffer = boardView.get_buffer();
+	if (boardBuffer) {
+		boardBuffer->set_text(boardText);
+	}
+	char responseFile[] = "response.txt";
+	if (file_exists(responseFile)) {
+		system("rm response.txt");
+	}
 }
 
 void Play :: keepUpdating() {
 	while (true) {
     	update();
     	std::this_thread::sleep_for(std::chrono::seconds(1));
 	}
 }
 
 void Play :: backgroundUpdate() {
 	std::thread t(&Play::keepUpdating, this);
 	t.detach();
 }
 
 Play :: Play() {
 	bar.set_show_close_button(true);
 	set_titlebar(bar);
 
-	set_default_size(600, 500);
-	set_size_request(500, 400);
-
-	add(scrolledWindow);
-	scrolledWindow.add(fixed);
-	scrolledWindow.set_policy(PolicyType::POLICY_AUTOMATIC, PolicyType::POLICY_AUTOMATIC);
+	set_default_size(1000, 700);
+	set_size_request(800, 600);
 
 	bar.set_title("Playing Against the Model");
 
-	numBox.set_text("Enter Response Here");
+	rootBox.set_orientation(Gtk::ORIENTATION_VERTICAL);
+	mainSplit.set_orientation(Gtk::ORIENTATION_HORIZONTAL);
+	rightSplit.set_orientation(Gtk::ORIENTATION_VERTICAL);
+	leftControls.set_orientation(Gtk::ORIENTATION_VERTICAL);
+
+	add(rootBox);
+	rootBox.pack_start(mainSplit, Gtk::PACK_EXPAND_WIDGET);
+
+	mainSplit.add1(leftControls);
+	mainSplit.add2(rightSplit);
+	mainSplit.set_position(260);
+
+	rightSplit.add1(boardScroll);
+	rightSplit.add2(logScroll);
+	rightSplit.set_position(350);
+
+	responseLabel.set_text("Enter Response Here");
+	numBox.set_text("");
 
 	enter.set_label("Enter");
 	enter.signal_button_release_event().connect([&](GdkEventButton*) {	
 		ofstream file("response.txt", ios::out | ios::trunc);
 		file << numBox.get_text();
 		file.close();
 		numBox.set_text("");
 		return true;
 	});
 
-	text.set_text("When the game starts, text will appear here");
-	text.set_line_wrap(true);
+	clearLogButton.set_label("Clear Logs");
+	clearLogButton.signal_clicked().connect([this]() {
+		response.clear();
+		auto logBuffer = logView.get_buffer();
+		if (logBuffer) {
+			logBuffer->set_text("");
+		}
+	});
+	autoScrollToggle.set_label("Auto-scroll logs");
+	autoScrollToggle.set_active(true);
+
+	auto logBuffer = Gtk::TextBuffer::create();
+	logView.set_buffer(logBuffer);
+	logView.set_editable(false);
+	logView.set_wrap_mode(Gtk::WRAP_WORD_CHAR);
+
+	auto boardBuffer = Gtk::TextBuffer::create();
+	boardView.set_buffer(boardBuffer);
+	boardView.set_editable(false);
+	boardView.set_monospace(true);
+	boardView.set_wrap_mode(Gtk::WRAP_NONE);
+
 	dispatcher.connect(sigc::mem_fun(*this, &Play::update_text_view));
 	backgroundUpdate();
-	innerWindow.add(text);
-	innerWindow.set_size_request(520,260);
-	innerWindow.set_policy(PolicyType::POLICY_AUTOMATIC, PolicyType::POLICY_AUTOMATIC);
-	
-	
-	fixed.add(numBox);
-	fixed.add(enter);
-	fixed.add(innerWindow);
-	fixed.move(innerWindow, 10, 10);
-	fixed.move(numBox, 10, 120);
-	fixed.move(enter, 10, 170);
-
-    resize(600,500);
+
+	boardScroll.add(boardView);
+	boardScroll.set_policy(PolicyType::POLICY_AUTOMATIC, PolicyType::POLICY_AUTOMATIC);
+	logScroll.add(logView);
+	logScroll.set_policy(PolicyType::POLICY_AUTOMATIC, PolicyType::POLICY_AUTOMATIC);
+
+	leftControls.pack_start(responseLabel, Gtk::PACK_SHRINK);
+	leftControls.pack_start(numBox, Gtk::PACK_SHRINK);
+	leftControls.pack_start(enter, Gtk::PACK_SHRINK);
+	leftControls.pack_start(clearLogButton, Gtk::PACK_SHRINK);
+	leftControls.pack_start(autoScrollToggle, Gtk::PACK_SHRINK);
+
     show_all();
 }
+
+std::string Play :: openBoardFile(const std::string& board) {
+	std::fstream file;
+	file.open(board, std::ios::in);
+	std::string fullFile;
+	char last = '\0';
+	if (!file) {
+		return "";
+	}
+	char ch;
+	while (1) {
+		file >> ch;
+		if (file.eof()) {
+			break;
+		}
+		if (last == '0' && ch != ',') {
+			fullFile += '\n';
+		} else if (ch == '0' && is_board_num(last)) {
+			fullFile += '\n';
+		} else if (is_board_num(ch) && ch != '0' && ch != '3') {
+			fullFile += ch;
+		} else if (is_board_num(ch) && ch == '3') {
+			fullFile += '0';
+			fullFile += '\x20';
+		} else {
+			fullFile += '_';
+			fullFile += '\x20';
+		}
+		last = ch;
+	}
+	file.close();
+	return fullFile;
+}
 
EOF
)
