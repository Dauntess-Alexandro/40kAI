diff --git a/gym_mod/gym_mod/envs/warhamEnv.py b/gym_mod/gym_mod/envs/warhamEnv.py
index 264e34aa47cd70d87eeb99a7fbb3079796aab255..f8aa4f76f812c1954a15aa52550e9c648ffca28c 100644
--- a/gym_mod/gym_mod/envs/warhamEnv.py
+++ b/gym_mod/gym_mod/envs/warhamEnv.py
@@ -1741,63 +1741,64 @@ class Warhammer40kEnv(gym.Env):
                 if self.unit_health[i] <= 0:
                     self._log_unit("MODEL", modelName, i, "Юнит мертв, стрельба пропущена.")
                     continue
                 if self.unitFellBack[i]:
                     self._log_unit("MODEL", modelName, i, "Fall Back в этом ходу — стрельба недоступна.")
                     continue
                 if self.unitInAttack[i][0] == 1:
                     self._log_unit("MODEL", modelName, i, "Юнит в ближнем бою, стрельба недоступна.")
                     continue
                 if self.unit_weapon[i] == "None":
                     self._log_unit("MODEL", modelName, i, "Нет дальнобойного оружия, стрельба пропущена.")
                     continue
                 if advanced and not weapon_is_assault(self.unit_weapon[i]):
                     self._log_unit("MODEL", modelName, i, "Advance без Assault — стрельба пропущена.")
                     continue
 
                 shootAbleUnits = []
                 for j in range(len(self.enemy_health)):
                     if (
                         distance(self.unit_coords[i], self.enemy_coords[j]) <= self.unit_weapon[i]["Range"]
                         and self.enemy_health[j] > 0
                         and self.enemyInAttack[j][0] == 0
                     ):
                         shootAbleUnits.append(j)
                 if len(shootAbleUnits) > 0:
-                    target_ids = [j + 11 for j in shootAbleUnits]
-                    idOfE = action["shoot"]
-                    if idOfE in shootAbleUnits:
-                        distances = {j: distance(self.unit_coords[i], self.enemy_coords[j]) for j in shootAbleUnits}
+                    valid_target_ids = shootAbleUnits
+                    raw = action["shoot"]
+                    if 0 <= raw < len(valid_target_ids):
+                        idOfE = valid_target_ids[raw]
+                        distances = {j: distance(self.unit_coords[i], self.enemy_coords[j]) for j in valid_target_ids}
                         closest = min(distances, key=distances.get)
-                        min_hp = min(shootAbleUnits, key=lambda idx: self.enemy_health[idx])
+                        min_hp = min(valid_target_ids, key=lambda idx: self.enemy_health[idx])
                         if idOfE == closest:
                             reason = "самая близкая"
                         elif idOfE == min_hp:
                             reason = "цель с меньшим HP"
                         else:
                             reason = "выбор политики"
-                        target_list = self._format_unit_choices("enemy", shootAbleUnits)
+                        target_list = self._format_unit_choices("enemy", valid_target_ids)
                         self._log_unit(
                             "MODEL",
                             modelName,
                             i,
                             f"Цели в дальности: {target_list}, выбрана: {self._format_unit_label('enemy', idOfE)} (причина: {reason})",
                         )
                         effect = self._maybe_use_smokescreen(
                             defender_side="enemy",
                             defender_idx=idOfE,
                             phase="shooting",
                             manual=os.getenv("MANUAL_DICE", "0") == "1",
                         )
                         _logger = None
                         if self.trunc is False and _verbose_logs_enabled():
                             _logger = RollLogger(auto_dice)
                             dmg, modHealth = attack(
                                 self.unit_health[i],
                                 self.unit_weapon[i],
                                 self.unit_data[i],
                                 self.enemy_health[idOfE],
                                 self.enemy_data[idOfE],
                                 effects=effect,
                                 distance_to_target=distance(self.unit_coords[i], self.enemy_coords[idOfE]),
                                 roller=_logger.roll,
                             )
@@ -1817,57 +1818,61 @@ class Warhammer40kEnv(gym.Env):
                             "MODEL",
                             modelName,
                             i,
                             f"Итог урона по {self._format_unit_label('enemy', idOfE)}: {float(np.sum(dmg))}",
                         )
                         if self.trunc is False:
                             self._log(
                                 f"{self._format_unit_label('model', i)} стреляет по {self._format_unit_label('enemy', idOfE)}: урон {float(np.sum(dmg))}."
                             )
                         else:
                             self.modelUpdates += "{} стреляет по {} {} раз(а)\n".format(
                                 self._format_unit_label("model", i),
                                 self._format_unit_label("enemy", idOfE),
                                 sum(dmg),
                             )
                         if self.trunc is False and _logger is not None:
                             _logger.print_shoot_report(
                                 weapon=self.unit_weapon[i],
                                 attacker_data=self.unit_data[i],
                                 defender_data=self.enemy_data[idOfE],
                                 dmg_list=dmg,
                                 effect=effect,
                             )
                     else:
                         reward_delta -= 0.5
-                        target_list = self._format_unit_choices("enemy", shootAbleUnits)
+                        target_list = self._format_unit_choices("enemy", valid_target_ids)
                         self._log_unit(
                             "MODEL",
                             modelName,
                             i,
-                            f"Цели в дальности: {target_list}, выбрана недоступная цель {idOfE + 11}. Стрельба пропущена.",
+                            f"Цели в дальности: {target_list}, выбрана недоступная цель (raw={raw}). Стрельба пропущена.",
                         )
+                        if _verbose_logs_enabled():
+                            self._log(
+                                f"[MODEL][SHOOT] Невалидный выбор цели: raw={raw}, доступные={valid_target_ids} (ожидался индекс 0..{len(valid_target_ids) - 1}). Стрельба пропущена."
+                            )
                         if self.trunc is False:
                             self._log(f"{self._format_unit_label('model', i)} не смог стрелять: выбранная цель недоступна.")
                 else:
                     self._log_unit("MODEL", modelName, i, "Нет целей в дальности, стрельба пропущена.")
             return reward_delta
         elif side == "enemy" and manual:
             for i in range(len(self.enemy_health)):
                 playerName = i + 11
                 unit_label = self._format_unit_label("enemy", i, unit_id=playerName)
                 advanced = advanced_flags[i] if advanced_flags else False
                 if self.enemyFellBack[i]:
                     self._log(f"{unit_label}: отступил в этом ходу — стрельба пропущена.")
                     continue
                 if self.enemy_weapon[i] != "None":
                     if advanced and not weapon_is_assault(self.enemy_weapon[i]):
                         self._log(f"{unit_label}: был Advance без Assault — стрельба пропущена.")
                     else:
                         shootAble = np.array([])
                         for j in range(len(self.unit_health)):
                             if distance(self.enemy_coords[i], self.unit_coords[j]) <= self.enemy_weapon[i]["Range"] and self.unit_health[j] > 0 and self.unitInAttack[j][0] == 0:
                                 shootAble = np.append(shootAble, j)
                         if len(shootAble) > 0:
                             response = False
                             while response is False:
                                 targets_label = self._format_unit_choices("model", shootAble.astype(int).tolist())

