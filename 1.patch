diff --git a/gym_mod/gym_mod/envs/warhamEnv.py b/gym_mod/gym_mod/envs/warhamEnv.py
index c30e21d77ca401b64d33849be7f1e283022adb8c..cd92d1dc194a6267e0d705f93155df764d4e7b26 100644
--- a/gym_mod/gym_mod/envs/warhamEnv.py
+++ b/gym_mod/gym_mod/envs/warhamEnv.py
@@ -2515,233 +2515,203 @@ class Warhammer40kEnv(gym.Env):
 
                 return True
 
             else:  # att_side == "enemy"
                 if self.enemy_health[att_idx] <= 0 or self.enemyInAttack[att_idx][0] != 1:
                     return False
                 def_idx = self.enemyInAttack[att_idx][1]
                 if def_idx < 0 or def_idx >= len(self.unit_health) or self.unit_health[def_idx] <= 0:
                     self.enemyInAttack[att_idx] = [0, 0]
                     return False
                 enemy_label = self._side_label("enemy", manual=os.getenv("MANUAL_DICE", "0") == "1")
                 self._log_unit_phase(
                     enemy_label,
                     "fight",
                     att_idx + 11,
                     att_idx,
                     f"Выбран для атаки. Цель: {self._format_unit_label('model', def_idx)}.",
                 )
 
                 weapon = self.enemy_melee[att_idx]
                 attacker_data = self.enemy_data[att_idx]
                 defender_data = self.unit_data[def_idx]
                 hp_before = self.unit_health[def_idx]
 
                 _logger = None
+                manual_dice = os.getenv("MANUAL_DICE", "0") == "1"
                 if quiet is False and _verbose_logs_enabled():
                     _logger = RollLogger(dice_fn)
                     _logger.configure_for_weapon(weapon)
                     dmg, modHealth = attack(
                         self.enemy_health[att_idx],
                         weapon,
                         attacker_data,
                         self.unit_health[def_idx],
                         defender_data,
                         rangeOfComb="Melee",
                         roller=_logger.roll,
                     )
                 else:
+                    extra_kwargs = {"roller": dice_fn} if manual_dice else {}
                     dmg, modHealth = attack(
                         self.enemy_health[att_idx],
                         weapon,
                         attacker_data,
                         self.unit_health[def_idx],
                         defender_data,
                         rangeOfComb="Melee",
+                        **extra_kwargs,
                     )
 
                 self.unit_health[def_idx] = modHealth
 
                 wname = weapon.get("Name", "Melee") if isinstance(weapon, dict) else str(weapon)
                 _log(
                     f"⚔️ {self._format_unit_label('enemy', att_idx)} атакует {self._format_unit_label('model', def_idx)} оружием {wname}: урон {float(np.sum(dmg))} | HP {hp_before} -> {modHealth}"
                 )
                 self._log_unit_phase(
                     enemy_label,
                     "fight",
                     att_idx + 11,
                     att_idx,
                     f"Итог атаки: урон {float(np.sum(dmg))}, HP цели {hp_before} -> {modHealth}.",
                 )
 
                 if quiet is False and _logger is not None and hasattr(_logger, "print_melee_report"):
                     _logger.print_melee_report(
                         weapon=weapon,
                         attacker_data=attacker_data,
                         defender_data=defender_data,
                         dmg_list=dmg,
                         effect=None,
                     )
 
                 if self.unit_health[def_idx] <= 0:
                     self.unitInAttack[def_idx] = [0, 0]
                     self.enemyInAttack[att_idx] = [0, 0]
 
                 return True
 
         manual_enemy = bool(getattr(self, "playType", False))
 
-        def _prompt_enemy_attacker(eligible_indices: list[int]) -> Optional[int]:
-            if not eligible_indices:
-                return None
-            unit_choices = self._format_unit_choices("enemy", eligible_indices)
-            self._log("ФАЗА БОЯ (Игрок): выберите атакующего юнита")
-            self._log("ФАЗА БОЯ: ожидается выбор атакующего юнита")
-            options = [str(11 + idx) for idx in eligible_indices]
-            while True:
-                choice = self._request_choice(
-                    f"ФАЗА БОЯ: выбери юнита для атаки. Доступные: {unit_choices}. Введите ID юнита: ",
-                    options,
-                )
-                if choice is None:
-                    self.game_over = True
-                    return None
-                choice_value = str(choice).strip()
-                if is_num(choice_value) and int(choice_value) - 11 in eligible_indices:
-                    return int(choice_value) - 11
-                self._log(f"Неверный ввод: выберите юнита из списка {unit_choices}.")
-
         def _prompt_enemy_target(att_idx: int) -> Optional[int]:
             def_idx = self.enemyInAttack[att_idx][1]
             targets = []
             if 0 <= def_idx < len(self.unit_health) and self.unit_health[def_idx] > 0:
                 targets = [def_idx]
             if not targets:
                 self._log("Целей для атаки нет: бой пропущен.")
                 return None
             target_choices = self._format_unit_choices("model", targets)
-            self._log("Выберите цель")
-            self._log("ФАЗА БОЯ: ожидается выбор цели")
             options = [str(21 + idx) for idx in targets]
             while True:
                 choice = self._request_choice(
-                    f"Выберите цель. Доступные цели: {target_choices}. Введите ID цели: ",
+                    f"Выберите цель для атаки. Атакует: {self._format_unit_label('enemy', att_idx)}. "
+                    f"Доступные цели: {target_choices}. Введите ID цели: ",
                     options,
                 )
                 if choice is None:
                     self.game_over = True
                     return None
                 choice_value = str(choice).strip()
                 if is_num(choice_value) and int(choice_value) - 21 in targets:
                     return int(choice_value) - 21
-                self._log(f"Неверный ввод: выберите цель из списка {target_choices}.")
-
-        def _manual_enemy_attack(eligible_indices: list[int]) -> Optional[int]:
-            while True:
-                attacker_idx = _prompt_enemy_attacker(eligible_indices)
-                if attacker_idx is None:
-                    return None
-                target_idx = _prompt_enemy_target(attacker_idx)
-                if target_idx is None:
-                    return None
-                confirm = self._request_bool("Начать атаку? (y/n): ")
-                if confirm is None:
-                    self.game_over = True
-                    return None
-                if confirm:
-                    return attacker_idx
-                self._log("Атака отменена: выберите юнита и цель заново.")
+                self._log("Недоступная цель, попробуйте снова.")
 
         # есть ли вообще кому драться?
         any_fight = any(x[0] == 1 for x in self.unitInAttack) or any(x[0] == 1 for x in self.enemyInAttack)
         if not any_fight:
             return
 
         model_eligible = [i for i in range(len(self.unit_health)) if self.unit_health[i] > 0 and self.unitInAttack[i][0] == 1]
         enemy_eligible = [i for i in range(len(self.enemy_health)) if self.enemy_health[i] > 0 and self.enemyInAttack[i][0] == 1]
         active_label = self._side_label(active_side, manual=os.getenv("MANUAL_DICE", "0") == "1" and active_side == "enemy")
         self._log_phase_msg(
             active_label,
             "fight",
             "Начало Fight phase. Первым выбирает активный игрок. "
             f"Eligible MODEL: {[i + 21 for i in model_eligible]}, "
             f"Eligible {self._display_side('enemy')}: {[i + 11 for i in enemy_eligible]}.",
         )
 
         fought_model = set()
         fought_enemy = set()
 
         # 1) chargers fight first (упрощение: только активная сторона)
         if active_side == "model":
             chargers = [i for i in range(len(self.unit_health))
                         if self.unitCharged[i] == 1 and self.unitInAttack[i][0] == 1 and self.unit_health[i] > 0]
             for i in chargers:
                 if i not in fought_model:
                     if _do_melee("model", i):
                         fought_model.add(i)
         else:
             chargers = [i for i in range(len(self.enemy_health))
                         if self.enemyCharged[i] == 1 and self.enemyInAttack[i][0] == 1 and self.enemy_health[i] > 0]
             if manual_enemy:
                 remaining = [i for i in chargers if i not in fought_enemy]
                 while remaining:
-                    attacker_idx = _manual_enemy_attack(remaining)
-                    if attacker_idx is None:
+                    attacker_idx = remaining[0]
+                    target_idx = _prompt_enemy_target(attacker_idx)
+                    if target_idx is None:
                         return
+                    self.enemyInAttack[attacker_idx][1] = target_idx
                     if _do_melee("enemy", attacker_idx):
                         fought_enemy.add(attacker_idx)
                     remaining = [i for i in chargers if i not in fought_enemy]
             else:
                 for i in chargers:
                     if i not in fought_enemy:
                         if _do_melee("enemy", i):
                             fought_enemy.add(i)
 
         # 2) then alternate, starting with NON-active side
         next_side = "enemy" if active_side == "model" else "model"
 
         while True:
             model_left = [i for i in range(len(self.unit_health))
                           if self.unit_health[i] > 0 and self.unitInAttack[i][0] == 1 and i not in fought_model]
             enemy_left = [i for i in range(len(self.enemy_health))
                           if self.enemy_health[i] > 0 and self.enemyInAttack[i][0] == 1 and i not in fought_enemy]
 
             if not model_left and not enemy_left:
                 break
 
             if next_side == "model":
                 if model_left:
                     i = model_left[0]
                     _do_melee("model", i)
                     fought_model.add(i)
                 next_side = "enemy"
             else:
                 if enemy_left:
                     if manual_enemy:
-                        attacker_idx = _manual_enemy_attack(enemy_left)
-                        if attacker_idx is None:
+                        attacker_idx = enemy_left[0]
+                        target_idx = _prompt_enemy_target(attacker_idx)
+                        if target_idx is None:
                             return
+                        self.enemyInAttack[attacker_idx][1] = target_idx
                         _do_melee("enemy", attacker_idx)
                         fought_enemy.add(attacker_idx)
                     else:
                         i = enemy_left[0]
                         _do_melee("enemy", i)
                         fought_enemy.add(i)
                 next_side = "model"
 
         # после Fight Phase — charged сбрасываем (на всякий)
         self.unitCharged = [0] * len(self.unit_health)
         self.enemyCharged = [0] * len(self.enemy_health)
 
         if quiet is False:
             self._log("⚔️ Combat resolution complete.\n")
 
 
 
     def step(self, action):
         reward = 0
         res = 0
         self.unitCharged = [0] * len(self.unit_health)
         self.enemyCharged = [0] * len(self.enemy_health)
         self.active_side = "model"
         battle_shock, delta = self.command_phase("model", action=action)
         reward += delta

