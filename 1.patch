diff --git a/gym_mod/gym_mod/envs/warhamEnv.py b/gym_mod/gym_mod/envs/warhamEnv.py
index 62c2ecff8fa45493b70a57f7db974db0de243e14..0143e2ce3f36d6f89c5659ac4022c55f629045d0 100644
--- a/gym_mod/gym_mod/envs/warhamEnv.py
+++ b/gym_mod/gym_mod/envs/warhamEnv.py
@@ -785,50 +785,134 @@ class Warhammer40kEnv(gym.Env):
 
         for i in range(len(self.unit_health)):
             if self.unit_health[i] <= 0:
                 continue
             wounds = self.unit_data[i]["W"]
             remaining_models = (self.unit_health[i] + wounds - 1) // wounds
             effective_oc = self.modelOC[i] * remaining_models
             if effective_oc <= 0:
                 continue
             for j in range(len(self.coordsOfOM)):
                 if distance(self.coordsOfOM[j], self.unit_coords[i]) <= 5:
                     self.modelOnOM[j] += effective_oc
 
         for i in range(len(self.enemy_health)):
             if self.enemy_health[i] <= 0:
                 continue
             wounds = self.enemy_data[i]["W"]
             remaining_models = (self.enemy_health[i] + wounds - 1) // wounds
             effective_oc = self.enemyOC[i] * remaining_models
             if effective_oc <= 0:
                 continue
             for j in range(len(self.coordsOfOM)):
                 if distance(self.coordsOfOM[j], self.enemy_coords[i]) <= 5:
                     self.enemyOnOM[j] += effective_oc
 
+    def _vp_log(self, msg: str):
+        if os.getenv("VERBOSE_LOGS", "0") != "1":
+            return
+        if self.trunc is True:
+            return
+        if self.playType is True:
+            sendToGUI(msg)
+        else:
+            print(msg)
+
+    def _mission_name(self) -> str:
+        if self.vicCond == 1:
+            return "Slay and Secure"
+        if self.vicCond == 2:
+            return "Ancient Relic"
+        if self.vicCond == 3:
+            return "Domination"
+        return f"Unknown ({self.vicCond})"
+
+    def _objective_control_status(self, model_oc: int, enemy_oc: int) -> str:
+        if model_oc > enemy_oc:
+            return "model"
+        if enemy_oc > model_oc:
+            return "enemy"
+        if model_oc == 0 and enemy_oc == 0:
+            return "empty"
+        return "contested"
+
+    def _log_objective_state(self):
+        for i in range(len(self.coordsOfOM)):
+            model_oc = max(int(self.modelOnOM[i]), 0)
+            enemy_oc = max(int(self.enemyOnOM[i]), 0)
+            control = self._objective_control_status(model_oc, enemy_oc)
+            self._vp_log(
+                "Objective {} @ {} | modelOC={} enemyOC={} control={}".format(
+                    i,
+                    self.coordsOfOM[i],
+                    model_oc,
+                    enemy_oc,
+                    control,
+                )
+            )
+
+    def _log_vp_scoring(self, side: str, vp_before: int, vp_after: int, relic_note: str = None):
+        delta = vp_after - vp_before
+        self._vp_log(
+            "VP scoring ({}) for {}: {} -> {} (delta {})".format(
+                self._mission_name(),
+                side,
+                vp_before,
+                vp_after,
+                delta,
+            )
+        )
+        self._log_objective_state()
+        if relic_note:
+            self._vp_log(relic_note)
+
+    def _apply_ancient_relic_endgame_bonus(self):
+        self.refresh_objective_control()
+        model_oc = int(self.modelOnOM[self.relic])
+        enemy_oc = int(self.enemyOnOM[self.relic])
+        bonus_note = "Ancient Relic endgame bonus (relic idx {}): ".format(self.relic)
+
+        if model_oc > 0 and enemy_oc <= 0:
+            self.modelVP += 6
+            bonus_note += "model +6 (only model on relic)"
+        elif enemy_oc > 0 and model_oc <= 0:
+            self.enemyVP += 6
+            bonus_note += "enemy +6 (only enemy on relic)"
+        elif model_oc > 0 and enemy_oc > 0:
+            if model_oc > enemy_oc:
+                self.modelVP += 6
+                bonus_note += "model +6 (OC {} > {})".format(model_oc, enemy_oc)
+            elif enemy_oc > model_oc:
+                self.enemyVP += 6
+                bonus_note += "enemy +6 (OC {} > {})".format(enemy_oc, model_oc)
+            else:
+                bonus_note += "no bonus (OC tie {})".format(model_oc)
+        else:
+            bonus_note += "no bonus (relic empty)"
+
+        self._vp_log(bonus_note)
+
     def reset(self, m, e, playType=False, Type="small", trunc=False):
         # keep original references too
         self.model = m
         self.enemy = e
 
         self.iter = 0
         self.trunc = trunc
         self.playType = playType
 
         if Type == "small":
             self.restarts += 1
         elif Type == "big":
             self.restarts = 0
             savePath = "display/"
             if os.path.isdir(savePath):
                 for fil in os.listdir(savePath):
                     try:
                         os.remove(os.path.join(savePath, fil))
                     except Exception:
                         pass
 
         self.board = np.zeros((self.b_len, self.b_hei))
         self.enemy_coords = []
         self.unit_coords = []
         self.enemy_health = []
@@ -1114,54 +1198,56 @@ class Warhammer40kEnv(gym.Env):
                     self.enemyInAttack[i][0] = 0
                     self.enemyInAttack[i][1] = 0
                 else:
                     if self.unit_health[idOfM] > 0:
                         dmg, modHealth = attack(
                             self.enemy_health[i],
                             self.enemy_melee[i],
                             self.enemy_data[i],
                             self.unit_health[idOfM],
                             self.unit_data[idOfM],
                             rangeOfComb="Melee",
                         )
                         self.unit_health[idOfM] = modHealth
                     else:
                         self.unitInAttack[idOfM][0] = 0
                         self.unitInAttack[idOfM][1] = 0
 
                         self.enemyInAttack[i][0] = 0
                         self.enemyInAttack[i][1] = 0
 
         if self.modelStrat["overwatch"] != -1:
             self.modelStrat["overwatch"] = -1
         if self.modelStrat["smokescreen"] != -1:
             self.modelStrat["smokescreen"] = -1
 
+        vp_before = self.enemyVP
         self.refresh_objective_control()
         for i in range(len(self.enemyOnOM)):
             if self.enemyOnOM[i] > self.modelOnOM[i]:
                 self.enemyVP += 1
+        self._log_vp_scoring("enemy", vp_before, self.enemyVP)
 
     def resolve_fight_phase(self, active_side: str, trunc=None):
         """
         10e simplified Fight Phase:
         1) Chargers (charged this turn) fight first (active side only in this simplified model)
         2) Then alternate fights starting with the NON-active side
         Only units within Engagement (unitInAttack/enemyInAttack) can fight.
         No pile-in/consolidate here (упрощение).
         """
         quiet = self.trunc if trunc is None else trunc
 
         # кто кидает кубы (если MANUAL_DICE=1 — спрашиваем руками)
         dice_fn = player_dice if os.getenv("MANUAL_DICE", "0") == "1" else auto_dice
 
         def _log(msg: str):
             if quiet is False:
                 print(msg)
 
         def _do_melee(att_side: str, att_idx: int):
             """
             att_side: "model" (self.unit_*) or "enemy" (self.enemy_*)
             att_idx: index in corresponding arrays
             """
             # проверка жив/в бою
             if att_side == "model":
@@ -1644,94 +1730,99 @@ class Warhammer40kEnv(gym.Env):
 
                         # Снимаем статусы боя
                         self.unitInAttack[i][0] = 0
                         self.unitInAttack[i][1] = 0
 
                         self.enemyInAttack[idOfE][0] = 0
                         self.enemyInAttack[idOfE][1] = 0
 
                     else:
                         # Остаёмся в бою — урон будет в Fight Phase (позже)
                         reward += 0.2
                         # (можно вообще без print, чтобы не засорять; оставляем тишину)
                         pass
 
 
             elif self.unit_health[i] == 0:
                 reward -= 1
                 if self.trunc is False:
                     print("Model unit", modelName, "is destroyed")
 
         # Fight Phase (10e simplified)
         self.resolve_fight_phase(active_side="model")
         self.enemyStrat["overwatch"] = -1
         self.enemyStrat["smokescreen"] = -1
 
+        vp_before = self.modelVP
         self.refresh_objective_control()
         for i in range(len(self.modelOnOM)):
             if self.modelOnOM[i] > self.enemyOnOM[i]:
                 self.modelVP += 1
+        self._log_vp_scoring("model", vp_before, self.modelVP)
 
         for i in range(len(self.unit_health)):
             if self.unit_health[i] < 0:
                 self.unit_health[i] = 0
 
         for i in range(len(self.enemy_health)):
             if self.enemy_health[i] < 0:
                 self.enemy_health[i] = 0
 
         # Determine winning team
         if sum(self.unit_health) <= 0:
             self.game_over = True
             reward -= 2
             res = 4
         elif sum(self.enemy_health) <= 0:
             self.game_over = True
             reward += 2
             res = 4
 
         # Other victory conditions
         if self.numTurns == 10 and self.game_over is not True:
             self.game_over = True
             res = self.vicCond
             if res == 1:
                 self.modelVP = 0
                 self.enemyVP = 0
                 for i in range(len(self.enemyOnOM)):
                     if self.enemyOnOM[i] > self.modelOnOM[i]:
                         self.enemyVP += 1
                     elif self.modelOnOM[i] > self.enemyOnOM[i]:
                         self.modelVP += 1
                 if self.modelVP > self.enemyVP:
                     reward += 2
                 else:
                     reward -= 2
             elif res == 2:
-                if self.enemyOnOM[self.relic] > self.modelOnOM[self.relic]:
-                    self.enemyVP += 6
-                elif self.modelOnOM[self.relic] > self.enemyOnOM[self.relic]:
-                    self.modelVP += 6
+                model_vp_before = self.modelVP
+                enemy_vp_before = self.enemyVP
+                self._apply_ancient_relic_endgame_bonus()
+                if self.modelVP != model_vp_before:
+                    self._log_vp_scoring("model (endgame)", model_vp_before, self.modelVP)
+                if self.enemyVP != enemy_vp_before:
+                    self._log_vp_scoring("enemy (endgame)", enemy_vp_before, self.enemyVP)
                 if self.modelVP > self.enemyVP:
                     reward += 2
                 else:
                     reward -= 2
             elif res == 3:
                 if self.modelVP > self.enemyVP:
                     reward += 2
                 else:
                     reward -= 2
 
         self.iter += 1
         info = self.get_info()
         return self._get_observation(), reward, self.game_over, res, info
 
     # for a real person playing
     def player(self):
         self.enemyCP += 1
         self.modelCP += 1
 
         if self.numTurns == 0:
             if self.playType is False:
                 if self.vicCond == 1:
                     print("Victory Condition rolled: Slay and Secure")
                 elif self.vicCond == 2:
                     print("Victory Condition rolled: Ancient Relic")
@@ -2324,54 +2415,56 @@ class Warhammer40kEnv(gym.Env):
                         self.unitInAttack[idOfE][0] = 0
                         self.unitInAttack[idOfE][1] = 0
 
                     elif fallB.lower() == "quit":
                         self.game_over = True
                         info = self.get_info()
                         return self.game_over, info
                     else:
                         if self.playType is False:
                             fallB = input("It's a yes or no question dude: ")
                         else:
                             sendToGUI("It's a yes or no question dude: ")
                             fallB = recieveGUI()
 
             elif self.enemy_health[i] == 0:
                 if self.playType is False:
                     print("Unit", playerName, "is dead")
                 else:
                     sendToGUI("Unit {} is dead".format(playerName))
 
         if self.modelStrat["overwatch"] != -1:
             self.modelStrat["overwatch"] = -1
         if self.modelStrat["smokescreen"] != -1:
             self.modelStrat["smokescreen"] = -1
 
+        vp_before = self.enemyVP
         self.refresh_objective_control()
         for i in range(len(self.enemyOnOM)):
             if self.enemyOnOM[i] > self.modelOnOM[i]:
                 self.enemyVP += 1
+        self._log_vp_scoring("enemy", vp_before, self.enemyVP)
 
         for k in range(len(self.enemy_health)):
             if self.enemy_health[k] < 0:
                 self.enemy_health[k] = 0
 
         self.iter += 1
         info = self.get_info()
         return self.game_over, info
 
     def updateBoard(self):
         self.render(mode="test")
         self.board = np.zeros((self.b_len, self.b_hei))
 
         for i in range(len(self.unit_health)):
             self.unit_coords[i] = bounds(self.unit_coords[i], self.b_len, self.b_hei)
             self.board[self.unit_coords[i][0]][self.unit_coords[i][1]] = 20 + i + 1
 
         for i in range(len(self.enemy_health)):
             self.enemy_coords[i] = bounds(self.enemy_coords[i], self.b_len, self.b_hei)
             self.board[self.enemy_coords[i][0]][self.enemy_coords[i][1]] = 10 + i + 1
 
         for i in range(len(self.coordsOfOM)):
             self.board[int(self.coordsOfOM[i][0])][int(self.coordsOfOM[i][1])] = 3
 
     def returnBoard(self):

