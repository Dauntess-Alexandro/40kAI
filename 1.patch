diff --git a/gui/Application.cpp b/gui/Application.cpp
index c8e415da73592844de8e815f6285c98ec2fb0bd4..6cebbe1acfed46e6f03816c3b14a8cd34a9e011b 100644
--- a/gui/Application.cpp
+++ b/gui/Application.cpp
@@ -90,50 +90,53 @@ int findDefaultModelsCount(const std::string& faction, const std::string& name)
   return 1;
 }
 }  // namespace
 
 std::string gifpth = "img/model_train.gif";
 std::string rewpth = "img/reward.png";
 std::string losspth = "img/loss.png";
 std::string eplenpth = "img/epLen.png";
 std::string winratepth = "img/winrate.png";
 std::string vpdiffpth = "img/vpdiff.png";
 std::string endreasonpth = "img/endreasons.png";
 std::string imgpth = "img/icon.png";
 
 Form :: Form() {
 
   modelClass = " Necrons";
   enemyClass = " Necrons";
   path = " ";
   open = false;
   x = 60;
   y = 40;
   training = false;
   playing = false;
   loadingRoster = false;
   trainEnvPrefix = "";
+  trainingStartLabel = "обучения";
+  trainingStatusLabel = "Обучение";
+  trainingLogTag = "TRAIN";
 
   bar.set_show_close_button(true);
   bar.set_title("40kAI GUI");
   set_titlebar(bar);
 
   set_default_size(kDefaultWidth, kDefaultHeight);
   set_size_request(kMinimumWidth, kMinimumHeight);
 
   rootBox.set_orientation(Gtk::ORIENTATION_VERTICAL);
   topBarBox.set_orientation(Gtk::ORIENTATION_HORIZONTAL);
   topBarBox.set_spacing(8);
   leftBox.set_orientation(Gtk::ORIENTATION_VERTICAL);
   mainSplit.set_orientation(Gtk::ORIENTATION_HORIZONTAL);
   rightSplit.set_orientation(Gtk::ORIENTATION_VERTICAL);
 
   rootBox.set_hexpand(true);
   rootBox.set_vexpand(true);
   topBarBox.set_hexpand(true);
   leftBox.set_hexpand(true);
   leftBox.set_vexpand(true);
   mainSplit.set_hexpand(true);
   mainSplit.set_vexpand(true);
   rightSplit.set_hexpand(true);
   rightSplit.set_vexpand(true);
 
@@ -228,50 +231,53 @@ Form :: Form() {
   radioBottom.set_label("Bottom");
   radioBottom.set_group(radioButtonGroup);
   radioBottom.signal_toggled().connect([this]() {
     tabControl1.set_tab_pos(PositionType::POS_BOTTOM);
   });
 
     // train tab
 
   savetoTxt(enemyUnits, modelUnits);
 
   labelPage2.set_label("Train");
   tabControl1.set_tab_label(tabPage2, labelPage2);
   tabPage2.add(fixedTabPage2);
 
   textbox1.set_text("Train Model:");
   setStatusMessage("Press the Train button to train a model");
     
   button1.set_label("Train");
   button1.signal_button_release_event().connect([&](GdkEventButton*) {
     saveLastRoster();
     syncEnemyUnitsFromRoster();
     updateInits(modelClass, enemyClass);
     if (exists_test("data.json") && training == false) {
       setStatusMessage("Training...");
       trainEnvPrefix = "";
+      trainingStartLabel = "обучения";
+      trainingStatusLabel = "Обучение";
+      trainingLogTag = "TRAIN";
       startTrainInBackground();
     }
     return true;
   });
 
   numOfGames.set_text("# of Games in Training:");
   setIters.set_text("100");
 
   modelUnitLabel.set_text("Enter Model Units:");
   enemyUnitLabel.set_text("Enter Player Units:");
   openArmyPopup.set_label("Army Viewer");
   openArmyPopup.signal_button_release_event().connect([&](GdkEventButton*) {
     openArmyView();
     return true;
   });
 
   dimens.set_text("Dimensions of Board: ");
 
   dimX.set_text("X : ");
   enterDimensX.set_text(std::to_string(x));
   upX.set_label("+");
   upX.signal_button_release_event().connect([&](GdkEventButton*) {
     x+=10;
     enterDimensX.set_text(std::to_string(x));
     return true;
@@ -291,50 +297,53 @@ Form :: Form() {
     enterDimensY.set_text(std::to_string(y));
     return true;
   });
   downY.set_label("-");
   downY.signal_button_release_event().connect([&](GdkEventButton*) {
     y-=10;
     enterDimensY.set_text(std::to_string(y));
     return true;
   });
 
   button3.set_label("Clear Model Cache");
   button3.signal_button_release_event().connect([&](GdkEventButton*) {
     std::string mess = "Warning: You are about to delete all of the saved models";
     openWarnMenu(mess, 0);
     return true;
   });
 
   buttonSelfPlay.set_label("Самообучение");
   buttonSelfPlay.signal_button_release_event().connect([&](GdkEventButton*) {
     saveLastRoster();
     syncEnemyUnitsFromRoster();
     updateInits(modelClass, enemyClass);
     if (exists_test("data.json") && training == false) {
       setStatusMessage("Самообучение: обучение...");
       trainEnvPrefix = "SELF_PLAY_ENABLED=1 ";
+      trainingStartLabel = "самообучения";
+      trainingStatusLabel = "Самообучение";
+      trainingLogTag = "SELFPLAY";
       startTrainInBackground();
     }
     return true;
   });
 
   spmModel.set_label("Space Marine");
   spmModel.set_group(factionModel);
   spmModel.signal_toggled().connect([this]() {
     modelUnits.clear();
     modelClass = " Space_Marine";
   });
 
 
   orksModel.set_label("Orks");
   orksModel.set_group(factionModel);
   orksModel.signal_toggled().connect([this]() {
     modelUnits.clear();
     modelClass = " Orks";
   });
 
   sobModel.set_label("Sisters of Battle");
   sobModel.set_group(factionModel);
   sobModel.signal_toggled().connect([this]() {
     modelUnits.clear();
     modelClass = " Sisters_of_Battle";
@@ -762,67 +771,67 @@ Form :: Form() {
     syncEnemyUnitsFromRoster();
     saveLastRoster();
   }
   signal_hide().connect([this]() {
     saveLastRoster();
     saveWindowGeometry();
   });
   show_all();
 }
 
 void Form :: setStatusMessage(const std::string& message) {
   status.set_text(message);
   appendLogLine(message);
 }
 
 void Form :: appendLogLine(const std::string& message) {
   auto logBuffer = logView.get_buffer();
   if (!logBuffer) {
     return;
   }
   logBuffer->insert(logBuffer->end(), message + "\n");
   auto endIter = logBuffer->end();
   logView.scroll_to(endIter);
 }
 
-void Form :: appendTrainingLogToFile(const std::string& message) {
+void Form :: appendTrainingLogToFile(const std::string& message, const std::string& tag) {
   fs::path logPath = fs::current_path() / "LOGS_FOR_AGENTS.md";
   if (!fs::exists(logPath)) {
     fs::path parentPath = fs::current_path().parent_path() / "LOGS_FOR_AGENTS.md";
     if (fs::exists(parentPath)) {
       logPath = parentPath;
     }
   }
   std::ofstream outfile(logPath, std::ios::app);
   if (!outfile) {
     Glib::signal_idle().connect_once([this]() {
       appendLogLine(
           "Ошибка записи в LOGS_FOR_AGENTS.md (gui/Application.cpp): проверьте путь и права доступа.");
     });
     return;
   }
-  outfile << nowTimestamp() << " | [GUI][TRAIN] " << message << "\n";
+  outfile << nowTimestamp() << " | [GUI][" << tag << "] " << message << "\n";
 }
 
 bool Form :: loadWindowGeometry() {
   std::ifstream infile(geometryPath());
   if (!infile) {
     return false;
   }
   int width = 0;
   int height = 0;
   if (!(infile >> width >> height)) {
     return false;
   }
   set_default_size(width, height);
   return true;
 }
 
 void Form :: saveWindowGeometry() {
   std::string path = geometryPath();
   fs::create_directories(fs::path(path).parent_path());
   int width = 0;
   int height = 0;
   get_size(width, height);
   std::ofstream outfile(path);
   if (!outfile) {
     return;
@@ -1117,94 +1126,97 @@ void Form :: updateInits(std::string model, std::string enemy) {
   std::string command = "cd .. ; ./data.sh ";
   command.append(setIters.get_text().data());
   command.append(model);
   command.append(enemy);
   command.append(" ");
   command.append(enterDimensX.get_text().data());
   command.append(" ");
   command.append(enterDimensY.get_text().data());
   system(command.data());
 }
 
 void Form :: startTrainInBackground() {
   std::thread t(&Form::startTrain, this);
   t.detach();
 }
 
 void Form :: startTrain() {
   training = true;
   system("clear");
   const std::string perDefaults = "PER_ENABLED=1 N_STEP=3 TRAIN_LOG_TO_CONSOLE=1 ";
   std::string command = "cd .. ; ";
   command.append(perDefaults);
   command.append(trainEnvPrefix);
   command.append("./train.sh 2>&1");
 
-  Glib::signal_idle().connect_once([this]() {
-    setStatusMessage("Старт обучения: PER=1, N_STEP=3.");
+  std::string startMessage = "Старт " + trainingStartLabel + ": PER=1, N_STEP=3.";
+  Glib::signal_idle().connect_once([this, startMessage]() {
+    setStatusMessage(startMessage);
   });
-  appendTrainingLogToFile("Старт обучения: PER=1, N_STEP=3.");
+  appendTrainingLogToFile(startMessage, trainingLogTag);
 
   FILE* pipe = popen(command.c_str(), "r");
   if (!pipe) {
-    Glib::signal_idle().connect_once([this]() {
-      setStatusMessage(
-          "Ошибка запуска обучения (gui/Application.cpp): проверьте, что train.sh доступен.");
+    std::string errorMessage = "Ошибка запуска " + trainingStartLabel
+        + " (gui/Application.cpp): проверьте, что train.sh доступен.";
+    Glib::signal_idle().connect_once([this, errorMessage]() {
+      setStatusMessage(errorMessage);
     });
-    appendTrainingLogToFile(
-        "Ошибка запуска обучения (gui/Application.cpp): проверьте, что train.sh доступен.");
+    appendTrainingLogToFile(errorMessage, trainingLogTag);
     training = false;
     return;
   }
 
   std::array<char, 512> buffer{};
   while (fgets(buffer.data(), static_cast<int>(buffer.size()), pipe)) {
     std::string line(buffer.data());
     while (!line.empty() && (line.back() == '\n' || line.back() == '\r')) {
       line.pop_back();
     }
     if (line.empty()) {
       continue;
     }
-    appendTrainingLogToFile(line);
+    appendTrainingLogToFile(line, trainingLogTag);
     Glib::signal_idle().connect_once([this, line]() {
       appendLogLine(line);
     });
   }
 
   int exitCode = pclose(pipe);
   if (exitCode == 0) {
-    Glib::signal_idle().connect_once([this]() {
-      setStatusMessage("Обучение завершено.");
+    std::string doneMessage = trainingStatusLabel + " завершено.";
+    Glib::signal_idle().connect_once([this, doneMessage]() {
+      setStatusMessage(doneMessage);
     });
-    appendTrainingLogToFile("Обучение завершено.");
+    appendTrainingLogToFile(doneMessage, trainingLogTag);
   } else {
-    std::string errLine = "Обучение завершено с ошибкой. Код выхода: " + std::to_string(exitCode);
+    std::string errLine = trainingStatusLabel + " завершено с ошибкой. Код выхода: "
+        + std::to_string(exitCode);
     Glib::signal_idle().connect_once([this, errLine]() {
       setStatusMessage(errLine);
     });
-    appendTrainingLogToFile(errLine);
+    appendTrainingLogToFile(errLine, trainingLogTag);
   }
 
   training = false;
   Glib::signal_idle().connect_once([this]() {
     update_picture();
     update_metrics();
   });
 }
 
 void Form :: runPlayAgainstModelInBackground() {
   std::thread t(&Form::playAgainstModel, this);
   t.detach();
 }
   
 void Form :: playAgainstModel() {
   path = setModelFile.get_text();
 
   std::string envPrefix;
 
   std::string command;
 
   if (playInGUI == "True") {
     command = "cd .. ; " + envPrefix + "./play.sh ";
     if (strlen(path.data()) < 2) {
       command.append("None");
diff --git a/gui/include/Application.h b/gui/include/Application.h
index ef548f8cd4bf3963faf027a2b5399b241f3601d0..d0379712d4d9f3415f62f401aca303210133732f 100644
--- a/gui/include/Application.h
+++ b/gui/include/Application.h
@@ -24,51 +24,51 @@ public :
   void update_picture();
   void update_metrics();
   void updateInits(std::string model, std::string enemy);
   void startTrainInBackground();
   void startTrain();
   void runPlayAgainstModelInBackground();
   void playAgainstModel();
   inline bool exists_test (const std::string& name);
   void on_dropdown_changed();
   void savetoTxt(const std::vector<RosterEntry>& enemyUnits, const std::vector<RosterEntry>& modelUnits);
   bool isValidUnit(int id, std::string name);
   int openArmyView();
   int openWarnMenu(std::string mess, int comm);
   int openHelpMenu();
   int openPlayGUI();
   void changeMetrics(std::string path);
   void recentMetrics();
   std::string toLower(std::string data);
   void mirrorRoster();
   void saveLastRoster();
   void loadLastRoster();
   void syncEnemyUnitsFromRoster();
   bool addEnemyUnitFromEntry(const std::string& entryText);
   void resetLayout();
   void appendLogLine(const std::string& message);
-  void appendTrainingLogToFile(const std::string& message);
+  void appendTrainingLogToFile(const std::string& message, const std::string& tag = "TRAIN");
 
 private:
   void setStatusMessage(const std::string& message);
   void applyFactionToModel(const std::string& faction);
   void applyFactionToEnemy(const std::string& faction);
   bool loadWindowGeometry();
   void saveWindowGeometry();
   void ensureMinimumSize();
   Window* boardShow;
   Window* armyView;
   Window* warn;
   Window* play;
   Window* helpMenu;
   Image pictureBox1;
   Image metricBox;
   Image metricBox2;
   Image metricBox3;
 Image metricBox4;
 Image metricBox5;
 Image metricBox6;
   Box rootBox;
   Box topBarBox;
   Box leftBox;
   Paned mainSplit;
   Paned rightSplit;
@@ -153,28 +153,31 @@ Image metricBox6;
   Button mirrorRosterButton;
   Button openArmyPopup;
   Entry enterModelUnit;
   Entry enterEnemyUnit;
   Button clearAllModel;
   Button clearAllEnemy;
   int x;
   int y;
   bool open;
   bool training;
   bool playing;
   bool loadingRoster;
   Label error;
   Label modelUnitLabel;
   Label enemyUnitLabel;
   std::vector<RosterEntry> modelUnits;
   std::vector<RosterEntry> enemyUnits;
   RosterModel rosterModel;
   HeaderBar bar;
   Button help;
   Button resetLayoutButton;
   Button chooseMetrics;
   Button playGUI;
   std::string playInGUI;
   std::string trainEnvPrefix;
+  std::string trainingStartLabel;
+  std::string trainingStatusLabel;
+  std::string trainingLogTag;
 };
 
 #endif

