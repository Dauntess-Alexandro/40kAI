diff --git a/gui/Application.cpp b/gui/Application.cpp
index 47cf9f025efbce1143a861a8fccfab7368812256..c8e415da73592844de8e815f6285c98ec2fb0bd4 100644
--- a/gui/Application.cpp
+++ b/gui/Application.cpp
@@ -1,68 +1,87 @@
 #include <iostream>
 #include <gtkmm.h>
 #include <cstdlib>
 #include <stdlib.h>
 #include <string>
 #include <fstream>
 #include <thread>
 #include <chrono>
 #include <fstream>
+#include <cstdio>
+#include <ctime>
+#include <iomanip>
+#include <sstream>
 #include <filesystem>
 #include <vector>
 #include <algorithm>
+#include <array>
 #include <nlohmann/json.hpp>
 #include "include/Application.h"
 #include "include/popup.h"
 #include "include/units.h"
 #include "include/warn.h"
 #include "include/help.h"
 #include "include/play.h"
 
 using namespace Glib;
 using namespace Gtk;
 namespace fs = std::filesystem;
 using json = nlohmann::json;
 
 namespace {
 constexpr int kDefaultWidth = 1500;
 constexpr int kDefaultHeight = 900;
 constexpr int kMinimumWidth = 1200;
 constexpr int kMinimumHeight = 800;
 
 std::string geometryPath() {
   const char* home = std::getenv("HOME");
   std::string base = home ? home : ".";
   return base + "/.config/40kAI/gui_layout.conf";
 }
 
 std::string toLowerCopy(std::string data) {
   std::transform(data.begin(), data.end(), data.begin(),
                  [](unsigned char c) { return static_cast<char>(std::tolower(c)); });
   return data;
 }
 
+std::string nowTimestamp() {
+  auto now = std::chrono::system_clock::now();
+  std::time_t now_time = std::chrono::system_clock::to_time_t(now);
+  std::tm local_tm{};
+#if defined(_WIN32)
+  localtime_s(&local_tm, &now_time);
+#else
+  localtime_r(&now_time, &local_tm);
+#endif
+  std::ostringstream oss;
+  oss << std::put_time(&local_tm, "%Y-%m-%d %H:%M:%S");
+  return oss.str();
+}
+
 int findDefaultModelsCount(const std::string& faction, const std::string& name) {
   std::ifstream infile("../gym_mod/gym_mod/engine/unitData.json");
   if (!infile) {
     return 1;
   }
   json j;
   infile >> j;
   if (!j.contains("UnitData") || !j.at("UnitData").is_array()) {
     return 1;
   }
   std::string factionLower = toLowerCopy(faction);
   std::string nameLower = toLowerCopy(name);
   for (const auto& unit : j.at("UnitData")) {
     if (!unit.contains("Name") || !unit.contains("Army")) {
       continue;
     }
     if (toLowerCopy(unit.at("Name").get<std::string>()) != nameLower) {
       continue;
     }
     if (toLowerCopy(unit.at("Army").get<std::string>()) != factionLower) {
       continue;
     }
     if (unit.contains("#OfModels") && unit.at("#OfModels").is_number_integer()) {
       return unit.at("#OfModels").get<int>();
     }
@@ -730,59 +749,82 @@ Form :: Form() {
 
   loadWindowGeometry();
   loadLastRoster();
   if (modelUnits.empty()) {
     modelUnits.push_back({"Apothecary", "Space_Marine", findDefaultModelsCount("Space_Marine", "Apothecary"),
                           RosterModel::generateInstanceId()});
     modelUnits.push_back({"Eliminator Squad", "Space_Marine",
                           findDefaultModelsCount("Space_Marine", "Eliminator Squad"),
                           RosterModel::generateInstanceId()});
   }
   if (enemyUnits.empty()) {
     rosterModel.addUnit("Apothecary", 1, enemyClass.substr(1));
     rosterModel.addUnit("Eliminator Squad", 1, enemyClass.substr(1));
     syncEnemyUnitsFromRoster();
     saveLastRoster();
   }
   signal_hide().connect([this]() {
     saveLastRoster();
     saveWindowGeometry();
   });
   show_all();
 }
 
 void Form :: setStatusMessage(const std::string& message) {
   status.set_text(message);
+  appendLogLine(message);
+}
+
+void Form :: appendLogLine(const std::string& message) {
   auto logBuffer = logView.get_buffer();
   if (!logBuffer) {
     return;
   }
   logBuffer->insert(logBuffer->end(), message + "\n");
   auto endIter = logBuffer->end();
   logView.scroll_to(endIter);
 }
 
+void Form :: appendTrainingLogToFile(const std::string& message) {
+  fs::path logPath = fs::current_path() / "LOGS_FOR_AGENTS.md";
+  if (!fs::exists(logPath)) {
+    fs::path parentPath = fs::current_path().parent_path() / "LOGS_FOR_AGENTS.md";
+    if (fs::exists(parentPath)) {
+      logPath = parentPath;
+    }
+  }
+  std::ofstream outfile(logPath, std::ios::app);
+  if (!outfile) {
+    Glib::signal_idle().connect_once([this]() {
+      appendLogLine(
+          "Ошибка записи в LOGS_FOR_AGENTS.md (gui/Application.cpp): проверьте путь и права доступа.");
+    });
+    return;
+  }
+  outfile << nowTimestamp() << " | [GUI][TRAIN] " << message << "\n";
+}
+
 bool Form :: loadWindowGeometry() {
   std::ifstream infile(geometryPath());
   if (!infile) {
     return false;
   }
   int width = 0;
   int height = 0;
   if (!(infile >> width >> height)) {
     return false;
   }
   set_default_size(width, height);
   return true;
 }
 
 void Form :: saveWindowGeometry() {
   std::string path = geometryPath();
   fs::create_directories(fs::path(path).parent_path());
   int width = 0;
   int height = 0;
   get_size(width, height);
   std::ofstream outfile(path);
   if (!outfile) {
     return;
   }
   outfile << width << " " << height;
@@ -1069,58 +1111,107 @@ void Form :: update_metrics() {
   if (auto p = load_scaled(eplenpth)) metricBox3.set(p);
   if (auto p = load_scaled(endreasonpth)) metricBox6.set(p);
 
 }
 
 void Form :: updateInits(std::string model, std::string enemy) {
   std::string command = "cd .. ; ./data.sh ";
   command.append(setIters.get_text().data());
   command.append(model);
   command.append(enemy);
   command.append(" ");
   command.append(enterDimensX.get_text().data());
   command.append(" ");
   command.append(enterDimensY.get_text().data());
   system(command.data());
 }
 
 void Form :: startTrainInBackground() {
   std::thread t(&Form::startTrain, this);
   t.detach();
 }
 
 void Form :: startTrain() {
   training = true;
   system("clear");
+  const std::string perDefaults = "PER_ENABLED=1 N_STEP=3 TRAIN_LOG_TO_CONSOLE=1 ";
   std::string command = "cd .. ; ";
+  command.append(perDefaults);
   command.append(trainEnvPrefix);
-  command.append("./train.sh");
-  system(command.data());
-  setStatusMessage("Completed!");
+  command.append("./train.sh 2>&1");
+
+  Glib::signal_idle().connect_once([this]() {
+    setStatusMessage("Старт обучения: PER=1, N_STEP=3.");
+  });
+  appendTrainingLogToFile("Старт обучения: PER=1, N_STEP=3.");
+
+  FILE* pipe = popen(command.c_str(), "r");
+  if (!pipe) {
+    Glib::signal_idle().connect_once([this]() {
+      setStatusMessage(
+          "Ошибка запуска обучения (gui/Application.cpp): проверьте, что train.sh доступен.");
+    });
+    appendTrainingLogToFile(
+        "Ошибка запуска обучения (gui/Application.cpp): проверьте, что train.sh доступен.");
+    training = false;
+    return;
+  }
+
+  std::array<char, 512> buffer{};
+  while (fgets(buffer.data(), static_cast<int>(buffer.size()), pipe)) {
+    std::string line(buffer.data());
+    while (!line.empty() && (line.back() == '\n' || line.back() == '\r')) {
+      line.pop_back();
+    }
+    if (line.empty()) {
+      continue;
+    }
+    appendTrainingLogToFile(line);
+    Glib::signal_idle().connect_once([this, line]() {
+      appendLogLine(line);
+    });
+  }
+
+  int exitCode = pclose(pipe);
+  if (exitCode == 0) {
+    Glib::signal_idle().connect_once([this]() {
+      setStatusMessage("Обучение завершено.");
+    });
+    appendTrainingLogToFile("Обучение завершено.");
+  } else {
+    std::string errLine = "Обучение завершено с ошибкой. Код выхода: " + std::to_string(exitCode);
+    Glib::signal_idle().connect_once([this, errLine]() {
+      setStatusMessage(errLine);
+    });
+    appendTrainingLogToFile(errLine);
+  }
+
   training = false;
-  update_picture();
-  update_metrics();
+  Glib::signal_idle().connect_once([this]() {
+    update_picture();
+    update_metrics();
+  });
 }
 
 void Form :: runPlayAgainstModelInBackground() {
   std::thread t(&Form::playAgainstModel, this);
   t.detach();
 }
   
 void Form :: playAgainstModel() {
   path = setModelFile.get_text();
 
   std::string envPrefix;
 
   std::string command;
 
   if (playInGUI == "True") {
     command = "cd .. ; " + envPrefix + "./play.sh ";
     if (strlen(path.data()) < 2) {
       command.append("None");
     } else {
       command.append("\"");
       command.append(path);
       command.append("\"");
     }
     command.append(" True");
   } else {
diff --git a/gui/include/Application.h b/gui/include/Application.h
index 46a13d373383c61b6794474174350649300544d1..ef548f8cd4bf3963faf027a2b5399b241f3601d0 100644
--- a/gui/include/Application.h
+++ b/gui/include/Application.h
@@ -23,50 +23,52 @@ public :
   int openPopUp(bool textMode);
   void update_picture();
   void update_metrics();
   void updateInits(std::string model, std::string enemy);
   void startTrainInBackground();
   void startTrain();
   void runPlayAgainstModelInBackground();
   void playAgainstModel();
   inline bool exists_test (const std::string& name);
   void on_dropdown_changed();
   void savetoTxt(const std::vector<RosterEntry>& enemyUnits, const std::vector<RosterEntry>& modelUnits);
   bool isValidUnit(int id, std::string name);
   int openArmyView();
   int openWarnMenu(std::string mess, int comm);
   int openHelpMenu();
   int openPlayGUI();
   void changeMetrics(std::string path);
   void recentMetrics();
   std::string toLower(std::string data);
   void mirrorRoster();
   void saveLastRoster();
   void loadLastRoster();
   void syncEnemyUnitsFromRoster();
   bool addEnemyUnitFromEntry(const std::string& entryText);
   void resetLayout();
+  void appendLogLine(const std::string& message);
+  void appendTrainingLogToFile(const std::string& message);
 
 private:
   void setStatusMessage(const std::string& message);
   void applyFactionToModel(const std::string& faction);
   void applyFactionToEnemy(const std::string& faction);
   bool loadWindowGeometry();
   void saveWindowGeometry();
   void ensureMinimumSize();
   Window* boardShow;
   Window* armyView;
   Window* warn;
   Window* play;
   Window* helpMenu;
   Image pictureBox1;
   Image metricBox;
   Image metricBox2;
   Image metricBox3;
 Image metricBox4;
 Image metricBox5;
 Image metricBox6;
   Box rootBox;
   Box topBarBox;
   Box leftBox;
   Paned mainSplit;
   Paned rightSplit;

