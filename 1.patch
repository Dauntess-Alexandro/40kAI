diff --git a/gui_qt/main.py b/gui_qt/main.py
index 4ffca7a1a622741ac50b6aa5f345ee257cf282b6..d5ebd7dee2d33be9343e2426874076c3767cb163 100644
--- a/gui_qt/main.py
+++ b/gui_qt/main.py
@@ -475,62 +475,107 @@ class GUIController(QtCore.QObject):
                     "Ошибка подготовки данных (gui_qt/main.py): "
                     "проверьте data.sh и зависимости."
                 )
                 self._emit_status(message)
                 self._emit_log(
                     f"[GUI] {message}\nstdout: {result.stdout}\nstderr: {result.stderr}",
                     level="ERROR",
                 )
                 return False
             return True
         except OSError as exc:
             message = (
                 "Ошибка подготовки данных (gui_qt/main.py): "
                 "проверьте доступность data.sh."
             )
             self._emit_status(message)
             self._emit_log(f"[GUI] {message} Детали: {exc}", level="ERROR")
             return False
 
     def _read_stdout(self) -> None:
         if self._process is None:
             return
         data = self._process.readAllStandardOutput().data().decode("utf-8", errors="replace")
         for line in data.splitlines():
             if line.strip():
-                self._emit_log(line)
+                if self._should_show_train_log(line):
+                    self._emit_log(line)
                 self._handle_progress_line(line)
 
     def _read_stderr(self) -> None:
         if self._process is None:
             return
         data = self._process.readAllStandardError().data().decode("utf-8", errors="replace")
         for line in data.splitlines():
             if line.strip():
-                self._emit_log(line, level="ERROR")
+                if not self._is_tqdm_progress_line(line):
+                    self._emit_log(line, level="ERROR")
                 self._handle_progress_line(line)
 
+    def _is_tqdm_progress_line(self, line: str) -> bool:
+        normalized = line.strip()
+        if not normalized:
+            return False
+        return bool(re.search(r"\d+%\|.+\|\s*\d+\s*/\s*\d+", normalized))
+
+    def _should_show_train_log(self, line: str) -> bool:
+        normalized = line.strip()
+        if not normalized:
+            return False
+        if normalized.startswith("[GUI]"):
+            return True
+        if normalized.startswith("[ERROR]") or normalized.startswith("[WARN]"):
+            return True
+        allowed_prefixes = (
+            "[TRAIN8] Старт",
+            "[TRAIN] Старт",
+            "[SELFPLAY] Старт",
+            "[TRAIN][START]",
+            "[DEVICE CHECK]",
+            "[metrics] saved:",
+        )
+        allowed_contains = (
+            "Training...",
+            "Model Units:",
+            "Enemy Units:",
+            "Action keys:",
+            "Generated metrics",
+            "Forging model_train.gif",
+            "genDisplay.makeGif:",
+        )
+        if normalized.startswith(allowed_prefixes):
+            return True
+        if any(token in normalized for token in allowed_contains):
+            return True
+        if normalized.startswith("Name:"):
+            return True
+        if normalized.startswith("[") and re.match(r"^\[\s*\d", normalized):
+            return True
+        if normalized == "[]":
+            return True
+        return False
+
     def _handle_progress_line(self, line: str) -> None:
         current, total = self._parse_training_progress(line, self._train_total_episodes)
         if current is None:
             return
         self._set_progress(current, total)
         now = time.time()
         if now - self._training_last_ui_update >= 0.25:
             self._training_last_ui_update = now
             self._update_progress_stats(current)
 
     def _parse_training_progress(self, line: str, fallback_total: int) -> tuple[Optional[int], int]:
         tqdm_match = re.search(r"(\d+)\s*/\s*(\d+)", line)
         if tqdm_match:
             return int(tqdm_match.group(1)), int(tqdm_match.group(2))
         ep_match = re.search(r"\bep=(\d+)", line)
         if ep_match:
             return int(ep_match.group(1)), fallback_total
         return None, fallback_total
 
     def _reset_training_stats(self) -> None:
         self._training_samples.clear()
         now = time.time()
         self._training_start_time = now
         self._training_last_ui_update = now - 1
 

