diff --git a/viewer/app.py b/viewer/app.py
index 4ebd41ce94705d9990729f4352d4ca3647028421..14522f819eb9e82d991829a2d4e9a97554fdf92c 100644
--- a/viewer/app.py
+++ b/viewer/app.py
@@ -1,28 +1,29 @@
 import os
 import re
 import sys
+from datetime import datetime
 from PySide6 import QtCore, QtGui, QtWidgets
 
 ROOT_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
 GYM_PATH = os.path.join(ROOT_DIR, "gym_mod")
 if GYM_PATH not in sys.path:
     sys.path.insert(0, GYM_PATH)
 
 from viewer.scene import MapScene
 from viewer.state import StateWatcher
 from viewer.styles import Theme
 
 from gym_mod.engine.game_controller import GameController
 from gym_mod.engine.game_io import parse_dice_values
 
 
 class MapView(QtWidgets.QGraphicsView):
     def __init__(self, *args, **kwargs):
         super().__init__(*args, **kwargs)
         self.setRenderHints(
             QtGui.QPainter.Antialiasing
             | QtGui.QPainter.TextAntialiasing
             | QtGui.QPainter.SmoothPixmapTransform
         )
         self.setDragMode(QtWidgets.QGraphicsView.ScrollHandDrag)
         self.setTransformationAnchor(QtWidgets.QGraphicsView.AnchorUnderMouse)
@@ -63,89 +64,93 @@ class ViewerWindow(QtWidgets.QMainWindow):
         self.status_turn = QtWidgets.QLabel("–•–æ–¥: ‚Äî")
         self.status_phase = QtWidgets.QLabel("–§–∞–∑–∞: ‚Äî")
         self.status_active = QtWidgets.QLabel("–ê–∫—Ç–∏–≤–µ–Ω: ‚Äî")
 
         self.points_vp_player = QtWidgets.QLabel("Player VP: ‚Äî")
         self.points_vp_model = QtWidgets.QLabel("Model VP: ‚Äî")
         self.points_cp_player = QtWidgets.QLabel("Player CP: ‚Äî")
         self.points_cp_model = QtWidgets.QLabel("Model CP: ‚Äî")
 
         self.units_table = QtWidgets.QTableWidget(0, 5)
         self.units_table.setHorizontalHeaderLabels(["–°—Ç–æ—Ä–æ–Ω–∞", "ID", "–ò–º—è", "HP", "–ú–æ–¥–µ–ª–∏"])
         header = self.units_table.horizontalHeader()
         header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)
         header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
         header.setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
         header.setSectionResizeMode(3, QtWidgets.QHeaderView.ResizeToContents)
         header.setSectionResizeMode(4, QtWidgets.QHeaderView.ResizeToContents)
         header.sortIndicatorChanged.connect(self._rebuild_unit_row_mapping)
         self.units_table.verticalHeader().setVisible(False)
         self.units_table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
         self.units_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
         self.units_table.setAlternatingRowColors(True)
         self.units_table.itemSelectionChanged.connect(self._sync_selection_from_table)
         self._apply_units_table_font()
 
-        self.log_view = QtWidgets.QPlainTextEdit()
-        self.log_view.setReadOnly(True)
-        self.log_view.setMaximumBlockCount(500)
-
-        copy_button = QtWidgets.QPushButton("Copy")
-        clear_button = QtWidgets.QPushButton("Clear")
-        copy_button.clicked.connect(self._copy_log)
-        clear_button.clicked.connect(self.log_view.clear)
+        self._log_entries = []
+        self._current_turn_number = None
+        self._log_tail_snapshot = None
+        self._log_tabs = {}
+        self._log_tab_defs = [
+            ("all", "–í—Å–µ"),
+            ("turn", "–•–æ–¥"),
+            ("shooting", "–°—Ç—Ä–µ–ª—å–±–∞"),
+            ("fight", "–ë–ª–∏–∂–Ω–∏–π –±–æ–π"),
+            ("dice", "–ö—É–±—ã"),
+            ("errors", "–û—à–∏–±–∫–∏"),
+        ]
+        self._max_log_lines = 5000
+        self._log_file_path = os.path.join(ROOT_DIR, "LOGS_FOR_AGENTS.md")
+        self._log_file_max_bytes = 5 * 1024 * 1024
+        self._init_log_viewer()
 
         fit_button = QtWidgets.QPushButton("Fit")
         fit_button.clicked.connect(self._fit_view)
 
         left_widget = QtWidgets.QWidget()
         left_layout = QtWidgets.QVBoxLayout(left_widget)
         left_layout.addWidget(fit_button, alignment=QtCore.Qt.AlignLeft)
         left_layout.addWidget(self.map_view)
 
         right_widget = QtWidgets.QWidget()
         right_layout = QtWidgets.QVBoxLayout(right_widget)
         right_layout.addWidget(self._group_status())
         right_layout.addWidget(self._group_points())
         right_layout.addWidget(self._group_units())
         right_layout.addWidget(self._group_legend())
         right_layout.addStretch()
 
         splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
         splitter.addWidget(left_widget)
         splitter.addWidget(right_widget)
         splitter.setStretchFactor(0, 3)
         splitter.setStretchFactor(1, 1)
 
         log_group = QtWidgets.QGroupBox("–ñ–£–†–ù–ê–õ")
         log_layout = QtWidgets.QVBoxLayout(log_group)
-        log_layout.addWidget(self.log_view)
-        log_buttons = QtWidgets.QHBoxLayout()
-        log_buttons.addStretch()
-        log_buttons.addWidget(copy_button)
-        log_buttons.addWidget(clear_button)
-        log_layout.addLayout(log_buttons)
+        log_layout.addLayout(self._log_controls_layout)
+        log_layout.addWidget(self.log_tabs)
 
         command_group = QtWidgets.QGroupBox("–ö–û–ú–ê–ù–î–´")
         command_layout = QtWidgets.QVBoxLayout(command_group)
         self.command_prompt = QtWidgets.QLabel("–û–∂–∏–¥–∞—é –∫–æ–º–∞–Ω–¥—É...")
         self.command_prompt.setWordWrap(True)
         command_layout.addWidget(self.command_prompt)
         self.command_hint = QtWidgets.QLabel("–ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏: ‚Äî")
         self.command_hint.setStyleSheet(f"color: {Theme.muted.name()};")
         command_layout.addWidget(self.command_hint)
 
         self.command_stack = QtWidgets.QStackedWidget()
         self._build_command_pages()
         command_layout.addWidget(self.command_stack)
 
         central = QtWidgets.QWidget()
         central_layout = QtWidgets.QVBoxLayout(central)
         central_layout.addWidget(splitter, stretch=3)
         central_layout.addWidget(log_group, stretch=1)
         central_layout.addWidget(command_group, stretch=0)
         self.setCentralWidget(central)
 
         self._apply_dark_theme()
         self._build_toolbar()
         self._fit_view()
         app = QtWidgets.QApplication.instance()
@@ -354,108 +359,131 @@ class ViewerWindow(QtWidgets.QMainWindow):
             comma = ",".join(example_values)
             compact = "".join(example_values)
             self.command_input.setPlaceholderText(
                 f"–ù–∞–ø—Ä–∏–º–µ—Ä: {spaced} –∏–ª–∏ {comma}"
                 + (f" –∏–ª–∏ {compact}" if compact else "")
             )
             self.command_stack.setCurrentIndex(self._command_pages["text"])
         else:
             self.command_input.setPlaceholderText("–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É...")
             self.command_stack.setCurrentIndex(self._command_pages["text"])
         self._update_command_hint(kind)
         self._refresh_active_context()
 
     def _update_command_hint(self, kind):
         if kind == "direction":
             self.command_hint.setText("–ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏: ‚Üë ‚Üì ‚Üê ‚Üí, –ø—Ä–æ–±–µ–ª/0 ‚Äî –Ω–µ—Ç")
         elif kind == "bool":
             self.command_hint.setText("–ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏: Y ‚Äî –¥–∞, N ‚Äî –Ω–µ—Ç")
         elif kind == "int":
             self.command_hint.setText("–ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏: Enter ‚Äî –æ—Ç–ø—Ä–∞–≤–∏—Ç—å")
         elif kind == "choice":
             self.command_hint.setText("–ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏: Enter ‚Äî –≤—ã–±—Ä–∞—Ç—å")
         else:
             self.command_hint.setText("–ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏: Enter ‚Äî –æ—Ç–ø—Ä–∞–≤–∏—Ç—å")
 
+    def _init_log_viewer(self):
+        fixed_font = QtGui.QFontDatabase.systemFont(QtGui.QFontDatabase.FixedFont)
+        fixed_font.setPointSize(10)
+
+        self.log_tabs = QtWidgets.QTabWidget()
+        for key, label in self._log_tab_defs:
+            view = QtWidgets.QPlainTextEdit()
+            view.setReadOnly(True)
+            view.setFont(fixed_font)
+            view.setMaximumBlockCount(self._max_log_lines)
+            self._log_tabs[key] = view
+            self.log_tabs.addTab(view, label)
+
+        self.log_only_current_turn = QtWidgets.QCheckBox("–ü–æ–∫–∞–∑–∞—Ç—å —Ç–æ–ª—å–∫–æ —Ç–µ–∫—É—â–∏–π —Ö–æ–¥")
+        self.log_only_current_turn.toggled.connect(self._refresh_log_views)
+
+        self.log_copy_turn = QtWidgets.QPushButton("–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Ö–æ–¥")
+        self.log_copy_turn.clicked.connect(self._copy_current_turn)
+        self.log_clear = QtWidgets.QPushButton("–û—á–∏—Å—Ç–∏—Ç—å")
+        self.log_clear.clicked.connect(self._clear_log_viewer)
+
+        self._log_controls_layout = QtWidgets.QHBoxLayout()
+        self._log_controls_layout.addWidget(self.log_only_current_turn)
+        self._log_controls_layout.addStretch()
+        self._log_controls_layout.addWidget(self.log_copy_turn)
+        self._log_controls_layout.addWidget(self.log_clear)
+
     def _append_log(self, messages):
         if not messages:
             return
         for msg in messages:
-            self.log_view.appendPlainText(str(msg))
-        self.log_view.verticalScrollBar().setValue(self.log_view.verticalScrollBar().maximum())
+            self.add_log_line(str(msg))
 
     def _start_controller(self):
         messages, request = self.controller.start()
         self._append_log(messages)
         self._set_request(request)
         self._poll_state()
 
     def _submit_text(self):
         text = self.command_input.text().strip()
         if not text:
             return
         if self._pending_request and getattr(self._pending_request, "kind", "") == "dice":
             count = self._pending_request.count or 0
             min_value = self._pending_request.min_value or 1
             max_value = self._pending_request.max_value or 6
             try:
                 values = parse_dice_values(text, count=count, min_value=min_value, max_value=max_value)
             except ValueError as exc:
                 entered = self._count_dice_entries(text)
                 self.command_prompt.setText(
                     "–û—à–∏–±–∫–∞ –≤–≤–æ–¥–∞ –∫—É–±–æ–≤ –≤ –ø–∞–Ω–µ–ª–∏ ¬´–ö–æ–º–∞–Ω–¥—ã¬ª: "
                     f"{exc}. –ù—É–∂–Ω–æ {count}, –≤–≤–µ–¥–µ–Ω–æ {entered}. "
                     "–ß—Ç–æ –¥–µ–ª–∞—Ç—å –¥–∞–ª—å—à–µ: –∏—Å–ø—Ä–∞–≤—å—Ç–µ –≤–≤–æ–¥ –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–Ω–æ–≤–∞.\n"
                     f"{self._pending_request.prompt}"
                 )
                 return
             self.command_input.clear()
             self._submit_answer(values)
             return
         self.command_input.clear()
         self._submit_answer(text)
 
     def _submit_choice(self):
         value = self.choice_combo.currentText()
         self._submit_answer(value)
 
     def _submit_answer(self, value):
         if self._pending_request is None:
             return
         messages, request = self.controller.answer(value)
         self._append_log(messages)
         self._set_request(request)
         self._poll_state()
 
     def _fit_view(self):
         rect = self.map_scene.sceneRect()
         if rect.width() > 0 and rect.height() > 0:
             self.map_view.fitInView(rect, QtCore.Qt.KeepAspectRatio)
 
-    def _copy_log(self):
-        QtWidgets.QApplication.clipboard().setText(self.log_view.toPlainText())
-
     def _poll_state(self):
         if self.state_watcher.load_if_changed():
             self._apply_state(self.state_watcher.state)
 
     def _apply_state(self, state):
         board = state.get("board", {})
         self.map_scene.update_state(state)
 
         self._units_by_key = {}
         for unit in state.get("units", []) or []:
             self._units_by_key[(unit.get("side"), unit.get("id"))] = unit
 
         self.status_round.setText(f"–†–∞—É–Ω–¥: {state.get('round', '‚Äî')}")
         self.status_turn.setText(f"–•–æ–¥: {state.get('turn', '‚Äî')}")
         self.status_phase.setText(f"–§–∞–∑–∞: {state.get('phase', '‚Äî')}")
         active = state.get("active")
         active_label = "–ò–≥—Ä–æ–∫" if active == "player" else "–ú–æ–¥–µ–ª—å" if active == "model" else "‚Äî"
         self.status_active.setText(f"–ê–∫—Ç–∏–≤–µ–Ω: {active_label}")
 
         vp = state.get("vp", {})
         cp = state.get("cp", {})
         self.points_vp_player.setText(f"Player VP: {vp.get('player', '‚Äî')}")
         self.points_vp_model.setText(f"Model VP: {vp.get('model', '‚Äî')}")
         self.points_cp_player.setText(f"Player CP: {cp.get('player', '‚Äî')}")
         self.points_cp_model.setText(f"Model CP: {cp.get('model', '‚Äî')}")
@@ -467,80 +495,294 @@ class ViewerWindow(QtWidgets.QMainWindow):
     def _populate_units_table(self, units):
         self.units_table.setRowCount(len(units))
         self.units_table.setSortingEnabled(False)
         self._unit_row_by_key = {}
         for row, unit in enumerate(units):
             side_label = "–ò–≥—Ä–æ–∫" if unit.get("side") == "player" else "–ú–æ–¥–µ–ª—å"
             unit_key = (unit.get("side"), unit.get("id"))
             values = [
                 side_label,
                 str(unit.get("id", "‚Äî")),
                 unit.get("name", "‚Äî"),
                 str(unit.get("hp", "‚Äî")),
                 str(unit.get("models", "‚Äî")),
             ]
             for col, value in enumerate(values):
                 item = QtWidgets.QTableWidgetItem(value)
                 if col == 0:
                     item.setData(QtCore.Qt.UserRole, unit_key)
                 self.units_table.setItem(row, col, item)
             self._unit_row_by_key[unit_key] = row
         self.units_table.setSortingEnabled(True)
         self._rebuild_unit_row_mapping()
 
     def _update_log(self, lines):
         if isinstance(lines, list):
-            self.log_view.setPlainText("\n".join(lines))
-            self.log_view.verticalScrollBar().setValue(self.log_view.verticalScrollBar().maximum())
+            text_lines = [str(line) for line in lines]
+            if self._log_tail_snapshot == text_lines:
+                return
+            if not self._log_entries:
+                self._reset_log_lines(text_lines, write_to_file=True)
+                self._log_tail_snapshot = text_lines
+                return
+            existing = [entry["text"] for entry in self._log_entries]
+            if len(text_lines) >= len(existing) and text_lines[: len(existing)] == existing:
+                for line in text_lines[len(existing) :]:
+                    self.add_log_line(line)
+                self._log_tail_snapshot = text_lines
+                return
+            self._reset_log_lines(text_lines, write_to_file=False)
+            self._log_tail_snapshot = text_lines
 
     def _select_row_for_unit(self, side, unit_id):
         unit_key = (side, unit_id)
         row = self._unit_row_by_key.get(unit_key)
         if row is None:
             row = self._find_row_for_unit(unit_key)
         if row is None:
             return
         self.units_table.selectRow(row)
         unit_name = self._units_by_key.get(unit_key, {}).get("name", "‚Äî")
         self._append_log([f"–í—ã–±—Ä–∞–Ω–æ –Ω–∞ –∫–∞—Ä—Ç–µ: unit_id={unit_id}, name={unit_name}"])
 
     def _sync_selection_from_table(self):
         selected = self.units_table.selectionModel().selectedRows()
         if not selected:
             return
         row = selected[0].row()
         item = self.units_table.item(row, 0)
         if item is None:
             return
         unit_key = item.data(QtCore.Qt.UserRole)
         if not unit_key:
             return
         side, unit_id = unit_key
         if side and unit_id is not None:
             self.map_scene.select_unit(side, unit_id)
             self._append_log([f"–í—ã–±—Ä–∞–Ω–æ –≤ —Ç–∞–±–ª–∏—Ü–µ: row={row} -> unit_id={unit_id}"])
 
+    def add_log_line(self, line: str):
+        text = str(line)
+        new_turn = self._detect_turn_number(text)
+        if new_turn is not None:
+            self._current_turn_number = new_turn
+        categories = self._classify_line(text)
+        entry = {
+            "text": text,
+            "turn": self._current_turn_number,
+            "categories": categories,
+        }
+        self._log_entries.append(entry)
+        self._append_log_to_file(text)
+        if len(self._log_entries) > self._max_log_lines:
+            self._log_entries = self._log_entries[-self._max_log_lines :]
+            self._refresh_log_views()
+            return
+        if new_turn is not None and self.log_only_current_turn.isChecked():
+            self._refresh_log_views()
+            return
+        for key, _ in self._log_tab_defs:
+            if self._should_show_entry(entry, key):
+                self._append_to_view(self._log_tabs[key], text)
+
+    def _append_to_view(self, view: QtWidgets.QPlainTextEdit, text: str):
+        scrollbar = view.verticalScrollBar()
+        at_bottom = scrollbar.value() >= scrollbar.maximum()
+        view.appendPlainText(text)
+        if at_bottom:
+            scrollbar.setValue(scrollbar.maximum())
+
+    def _classify_line(self, line: str):
+        lowered = line.lower()
+        categories = set()
+        if self._matches_any(
+            lowered,
+            [
+                "–±–æ–µ–≤–æ–≥–æ —Ä–∞—É–Ω–¥–∞",
+                "—Ñ–∞–∑–∞",
+                "===",
+                "iteration",
+                "—Ä–∞—É–Ω–¥",
+                "turn",
+            ],
+        ):
+            categories.add("turn")
+        if self._matches_any(
+            lowered,
+            [
+                "[shoot]",
+                "–æ—Ç—á—ë—Ç –ø–æ —Å—Ç—Ä–µ–ª—å–±–µ",
+                "hit rolls",
+                "wound",
+                "save",
+                "–æ—Ä—É–∂–∏–µ",
+                "—Å—Ç—Ä–µ–ª—å–±",
+            ],
+        ):
+            categories.add("shooting")
+        if self._matches_any(
+            lowered,
+            [
+                "[fight]",
+                "—Ñ–∞–∑–∞ –±–æ—è",
+                "melee",
+                "–∞—Ç–∞–∫–∏",
+                "—É–¥–∞—Ä",
+            ],
+        ):
+            categories.add("fight")
+        if self._matches_any(
+            lowered,
+            [
+                "d6",
+                "2d6",
+                "d3",
+                "–±—Ä–æ—Å–æ–∫",
+                "roll",
+                "rolling",
+                "üé≤",
+            ],
+        ):
+            categories.add("dice")
+        if self._matches_any(
+            lowered,
+            [
+                "error",
+                "traceback",
+                "exception",
+                "warn",
+                "warning",
+                "–Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω",
+                "–æ—à–∏–±–∫–∞",
+            ],
+        ):
+            categories.add("errors")
+        return categories
+
+    def _matches_any(self, lowered: str, tokens):
+        return any(token in lowered for token in tokens)
+
+    def _detect_turn_number(self, line: str):
+        match = re.search(r"–±–æ–µ–≤–æ–≥–æ —Ä–∞—É–Ω–¥–∞\\s*(\\d+)", line, re.IGNORECASE)
+        if match:
+            return int(match.group(1))
+        match = re.search(r"\\bturn\\s*(\\d+)", line, re.IGNORECASE)
+        if match:
+            return int(match.group(1))
+        match = re.search(r"\\b—Ä–∞—É–Ω–¥\\s*(\\d+)", line, re.IGNORECASE)
+        if match:
+            return int(match.group(1))
+        return None
+
+    def _should_show_entry(self, entry, tab_key):
+        if tab_key != "all" and tab_key not in entry["categories"]:
+            return False
+        if not self.log_only_current_turn.isChecked():
+            return True
+        if self._current_turn_number is None:
+            return True
+        return entry["turn"] == self._current_turn_number
+
+    def _refresh_log_views(self):
+        for view in self._log_tabs.values():
+            view.clear()
+        grouped_lines = {key: [] for key, _ in self._log_tab_defs}
+        for entry in self._log_entries:
+            for key, _ in self._log_tab_defs:
+                if self._should_show_entry(entry, key):
+                    grouped_lines[key].append(entry["text"])
+        for key, lines in grouped_lines.items():
+            if lines:
+                self._log_tabs[key].setPlainText("\n".join(lines))
+                scrollbar = self._log_tabs[key].verticalScrollBar()
+                scrollbar.setValue(scrollbar.maximum())
+
+    def _reset_log_lines(self, lines, write_to_file: bool):
+        self._log_entries = []
+        self._current_turn_number = None
+        for line in lines:
+            if write_to_file:
+                self.add_log_line(line)
+            else:
+                text = str(line)
+                new_turn = self._detect_turn_number(text)
+                if new_turn is not None:
+                    self._current_turn_number = new_turn
+                self._log_entries.append(
+                    {
+                        "text": text,
+                        "turn": self._current_turn_number,
+                        "categories": self._classify_line(text),
+                    }
+                )
+        self._refresh_log_views()
+
+    def _clear_log_viewer(self):
+        self._log_entries = []
+        self._current_turn_number = None
+        self._log_tail_snapshot = None
+        for view in self._log_tabs.values():
+            view.clear()
+
+    def _collect_current_turn_logs(self):
+        if self._current_turn_number is None:
+            return "\n".join(entry["text"] for entry in self._log_entries)
+        return "\n".join(
+            entry["text"]
+            for entry in self._log_entries
+            if entry["turn"] == self._current_turn_number
+        )
+
+    def _copy_current_turn(self):
+        QtWidgets.QApplication.clipboard().setText(self._collect_current_turn_logs())
+
+    def _append_log_to_file(self, line: str):
+        self._rotate_log_file_if_needed()
+        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
+        try:
+            with open(self._log_file_path, "a", encoding="utf-8") as log_file:
+                log_file.write(f"{timestamp} | {line}\n")
+        except OSError:
+            pass
+
+    def _rotate_log_file_if_needed(self):
+        if not os.path.exists(self._log_file_path):
+            return
+        try:
+            size = os.path.getsize(self._log_file_path)
+        except OSError:
+            return
+        if size <= self._log_file_max_bytes:
+            return
+        rotated = os.path.join(ROOT_DIR, "LOGS_FOR_AGENTS.old.md")
+        try:
+            if os.path.exists(rotated):
+                os.remove(rotated)
+            os.replace(self._log_file_path, rotated)
+        except OSError:
+            pass
+
     def _count_dice_entries(self, text: str) -> int:
         stripped = text.strip()
         if not stripped:
             return 0
         if stripped.isdigit():
             return len(stripped)
         parts = [part for part in re.split(r"[,\s]+", stripped) if part]
         return len(parts)
 
     def _rebuild_unit_row_mapping(self):
         self._unit_row_by_key = {}
         for row in range(self.units_table.rowCount()):
             item = self.units_table.item(row, 0)
             if item is None:
                 continue
             unit_key = item.data(QtCore.Qt.UserRole)
             if unit_key:
                 self._unit_row_by_key[unit_key] = row
 
     def _find_row_for_unit(self, unit_key):
         for row in range(self.units_table.rowCount()):
             item = self.units_table.item(row, 0)
             if item is None:
                 continue
             if item.data(QtCore.Qt.UserRole) == unit_key:

