diff --git a/viewer/app.py b/viewer/app.py
index 7b2e4630359a70757ab70062eecc1b61db43e721..017c627c478489c7e6fdb034d626b1ab63e93c82 100644
--- a/viewer/app.py
+++ b/viewer/app.py
@@ -53,58 +53,62 @@ class ViewerWindow(QtWidgets.QMainWindow):
         self.units_table = QtWidgets.QTableWidget(0, 5)
         self.units_table.setHorizontalHeaderLabels(["Сторона", "ID", "Имя", "HP", "Модели"])
         header = self.units_table.horizontalHeader()
         header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)
         header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
         header.setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
         header.setSectionResizeMode(3, QtWidgets.QHeaderView.ResizeToContents)
         header.setSectionResizeMode(4, QtWidgets.QHeaderView.ResizeToContents)
         header.sortIndicatorChanged.connect(self._rebuild_unit_row_mapping)
         self.units_table.verticalHeader().setVisible(False)
         self.units_table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
         self.units_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
         self.units_table.setAlternatingRowColors(True)
         self.units_table.itemSelectionChanged.connect(self._sync_selection_from_table)
         self._apply_units_table_font()
 
         self._log_entries = []
         self._current_turn_number = None
         self._log_tail_snapshot = None
         self._model_events_snapshot = None
         self._model_event_queue: queue.Queue = queue.Queue()
         self._model_log_source = None
         self._model_events_stream = []
         self._model_events_current = []
         self._log_tabs = {}
+        self._log_tab_indices = {}
+        self._log_tab_programmatic_switch = False
+        self._last_manual_log_tab_index = None
         self._log_tab_defs = [
             ("player", "Все ходы игрока"),
             ("model", "Все ходы модели"),
             ("key", "Ключевые события"),
         ]
         self._max_log_lines = 5000
         self._log_file_path = os.path.join(ROOT_DIR, "LOGS_FOR_AGENTS.md")
         self._log_file_max_bytes = 5 * 1024 * 1024
+        self._last_active_side = None
         self._init_log_viewer()
         self.add_log_line("[VIEWER] Рендер: OpenGL (QOpenGLWidget).")
         self.add_log_line("[VIEWER] Фоллбэк-рендер не активирован.")
         try:
             get_event_bus().subscribe(self._on_event_bus_event)
         except Exception:
             pass
 
         fit_button = QtWidgets.QPushButton("Fit")
         fit_button.clicked.connect(self._fit_view)
 
         left_widget = QtWidgets.QWidget()
         left_layout = QtWidgets.QVBoxLayout(left_widget)
         left_layout.addWidget(fit_button, alignment=QtCore.Qt.AlignLeft)
         left_layout.addWidget(self.map_scene)
 
         log_group = QtWidgets.QGroupBox("ЖУРНАЛ")
         log_layout = QtWidgets.QVBoxLayout(log_group)
         log_layout.addLayout(self._log_controls_layout)
         log_layout.addWidget(self.log_tabs)
         log_group.setSizePolicy(
             QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding
         )
 
         command_group = QtWidgets.QGroupBox("КОМАНДЫ")
@@ -361,57 +365,59 @@ class ViewerWindow(QtWidgets.QMainWindow):
             )
             self.command_stack.setCurrentIndex(self._command_pages["text"])
         else:
             self.command_input.setPlaceholderText("Введите команду...")
             self.command_stack.setCurrentIndex(self._command_pages["text"])
         self._update_command_hint(kind)
         self._refresh_active_context()
 
     def _update_command_hint(self, kind):
         if kind == "direction":
             self.command_hint.setText("Горячие клавиши: ↑ ↓ ← →, пробел/0 — нет")
         elif kind == "bool":
             self.command_hint.setText("Горячие клавиши: Y — да, N — нет")
         elif kind == "int":
             self.command_hint.setText("Горячие клавиши: Enter — отправить")
         elif kind == "choice":
             self.command_hint.setText("Горячие клавиши: Enter — выбрать")
         else:
             self.command_hint.setText("Горячие клавиши: Enter — отправить")
 
     def _init_log_viewer(self):
         fixed_font = QtGui.QFontDatabase.systemFont(QtGui.QFontDatabase.FixedFont)
         fixed_font.setPointSize(10)
 
         self.log_tabs = QtWidgets.QTabWidget()
-        for key, label in self._log_tab_defs:
+        for index, (key, label) in enumerate(self._log_tab_defs):
             view = QtWidgets.QPlainTextEdit()
             view.setReadOnly(True)
             view.setFont(fixed_font)
             view.setMaximumBlockCount(self._max_log_lines)
             self._log_tabs[key] = view
+            self._log_tab_indices[key] = index
             self.log_tabs.addTab(view, label)
+        self.log_tabs.currentChanged.connect(self._on_log_tab_changed)
 
         self.log_only_current_turn = QtWidgets.QCheckBox("Показать только текущий ход")
         self.log_only_current_turn.toggled.connect(self._refresh_log_views)
 
         self.log_model_verbose = QtWidgets.QCheckBox("Подробно (verbose)")
         self.log_model_verbose.toggled.connect(self._refresh_model_log_view)
 
         self.log_copy_turn = QtWidgets.QPushButton("Копировать ход")
         self.log_copy_turn.clicked.connect(self._copy_current_turn)
         self.log_clear = QtWidgets.QPushButton("Очистить")
         self.log_clear.clicked.connect(self._clear_log_viewer)
 
         self._log_controls_layout = QtWidgets.QHBoxLayout()
         self._log_controls_layout.addWidget(self.log_only_current_turn)
         self._log_controls_layout.addWidget(self.log_model_verbose)
         self._log_controls_layout.addStretch()
         self._log_controls_layout.addWidget(self.log_copy_turn)
         self._log_controls_layout.addWidget(self.log_clear)
 
     def _append_log(self, messages):
         if not messages:
             return
         for msg in messages:
             self.add_log_line(str(msg))
 
@@ -481,53 +487,54 @@ class ViewerWindow(QtWidgets.QMainWindow):
 
     def _fit_view(self):
         self.map_scene.fit_to_view()
 
     def _poll_state(self):
         if not os.path.exists(self.state_watcher.path):
             self.map_scene.set_error_message(
                 "Состояние игры недоступно. Где: viewer/state.json. "
                 "Что делать дальше: запустите игру и дождитесь генерации state.json."
             )
             return
         if self.state_watcher.load_if_changed():
             self._apply_state(self.state_watcher.state)
 
     def _apply_state(self, state):
         board = state.get("board", {})
         self.map_scene.update_state(state)
 
         self._units_by_key = {}
         for unit in state.get("units", []) or []:
             self._units_by_key[(unit.get("side"), unit.get("id"))] = unit
 
         self.status_round.setText(f"Раунд: {state.get('round', '—')}")
         self.status_turn.setText(f"Ход: {state.get('turn', '—')}")
         self.status_phase.setText(f"Фаза: {state.get('phase', '—')}")
-        active = state.get("active")
+        active = state.get("active") or state.get("active_side")
         active_label = "Игрок" if active == "player" else "Модель" if active == "model" else "—"
         self.status_active.setText(f"Активен: {active_label}")
+        self._auto_switch_log_tab(active)
 
         vp = state.get("vp", {})
         cp = state.get("cp", {})
         self.points_vp_player.setText(f"Player VP: {vp.get('player', '—')}")
         self.points_vp_model.setText(f"Model VP: {vp.get('model', '—')}")
         self.points_cp_player.setText(f"Player CP: {cp.get('player', '—')}")
         self.points_cp_model.setText(f"Model CP: {cp.get('model', '—')}")
 
         self._populate_units_table(state.get("units", []))
         self._update_log(state.get("log_tail", []))
         self._update_model_events(state.get("model_events", []))
         self._drain_event_queue()
         self._refresh_active_context()
 
     def _populate_units_table(self, units):
         self.units_table.setRowCount(len(units))
         self.units_table.setSortingEnabled(False)
         self._unit_row_by_key = {}
         for row, unit in enumerate(units):
             side_label = "Игрок" if unit.get("side") == "player" else "Модель"
             unit_key = (unit.get("side"), unit.get("id"))
             values = [
                 side_label,
                 str(unit.get("id", "—")),
                 unit.get("name", "—"),
@@ -982,50 +989,70 @@ class ViewerWindow(QtWidgets.QMainWindow):
         unit_id, side = self._resolve_active_unit()
         self._active_unit_id = unit_id
         self._active_unit_side = side
         active_unit = self._units_by_key.get((side, unit_id))
         phase = None
         if self.state_watcher and self.state_watcher.state:
             phase = self.state_watcher.state.get("phase")
         move_range = None
         shoot_range = None
         if self._is_movement_phase(phase):
             move_range = self._resolve_move_range(active_unit)
         if self._is_shooting_phase(phase):
             shoot_range = self._resolve_weapon_range(active_unit)
         self.map_scene.set_active_context(
             active_unit_id=unit_id,
             active_unit_side=side,
             phase=phase,
             move_range=move_range,
             shoot_range=shoot_range,
             show_objective_radius=self._show_objective_radius,
             targets=self.state_watcher.state.get("available_targets")
             if self.state_watcher and self.state_watcher.state
             else None,
         )
 
+    def _auto_switch_log_tab(self, active_side):
+        if active_side not in ("player", "model"):
+            return
+        if active_side == self._last_active_side:
+            return
+        self._last_active_side = active_side
+        target_index = self._log_tab_indices.get(active_side)
+        if target_index is None:
+            return
+        self._log_tab_programmatic_switch = True
+        try:
+            self.log_tabs.setCurrentIndex(target_index)
+        finally:
+            self._log_tab_programmatic_switch = False
+
+    def _on_log_tab_changed(self, index):
+        if self._log_tab_programmatic_switch:
+            return
+        self._last_manual_log_tab_index = index
+
     def _is_movement_phase(self, phase):
         phase_text = str(phase or "").lower()
         return "move" in phase_text or "движ" in phase_text or "movement" in phase_text
 
     def _is_shooting_phase(self, phase):
         phase_text = str(phase or "").lower()
         return "shoot" in phase_text or "стрел" in phase_text or "shooting" in phase_text
 
     def eventFilter(self, obj, event):
         if event.type() == QtCore.QEvent.KeyPress and self._pending_request:
             kind = getattr(self._pending_request, "kind", "")
             key = event.key()
             text = event.text().lower()
             if kind == "direction":
                 if key == QtCore.Qt.Key_Up:
                     self._submit_answer("up")
                     return True
                 if key == QtCore.Qt.Key_Down:
                     self._submit_answer("down")
                     return True
                 if key == QtCore.Qt.Key_Left:
                     self._submit_answer("left")
                     return True
                 if key == QtCore.Qt.Key_Right:
                     self._submit_answer("right")
