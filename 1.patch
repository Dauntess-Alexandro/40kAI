diff --git a/gym_mod/gym_mod/engine/game_controller.py b/gym_mod/gym_mod/engine/game_controller.py
index 7931e842cb38e798f7934f405482b5d5ec0d141f..a482e1b166ba8b590dfaa02c028d921619b037a5 100644
--- a/gym_mod/gym_mod/engine/game_controller.py
+++ b/gym_mod/gym_mod/engine/game_controller.py
@@ -46,73 +46,84 @@ class GameController:
         request = self._next_request(block=True)
         return self._consume_messages(), request
 
     def _consume_messages(self):
         return self._io.consume_messages()
 
     def _next_request(self, block: bool):
         if self._finished and self._request_queue.empty():
             return None
         if not block:
             try:
                 return self._request_queue.get_nowait()
             except queue.Empty:
                 return None
         while True:
             try:
                 return self._request_queue.get(timeout=0.1)
             except queue.Empty:
                 if self._finished:
                     return None
 
     def _load_game(self):
         if self.model_path == "None":
             save_path = "models/"
             folders = os.listdir(save_path) if os.path.isdir(save_path) else []
-            envs = []
-            modelpth = []
+            paired_models = []
 
             for folder in folders:
                 full = os.path.join(save_path, folder)
                 if os.path.isdir(full):
                     files = os.listdir(full)
                     for filename in files:
-                        if filename.endswith(".pickle"):
-                            envs.append(os.path.join(full, filename))
-                        elif filename.endswith(".pth"):
-                            modelpth.append(os.path.join(full, filename))
-
-            if not envs or not modelpth:
-                raise FileNotFoundError("Не найдены файлы моделей в папке models/.")
-
-            envs.sort(key=lambda x: os.path.getmtime(x))
-            modelpth.sort()
-            model_path = envs[-1]
-            checkpoint_path = modelpth[-1]
+                        if not filename.endswith(".pickle"):
+                            continue
+                        pickle_path = os.path.join(full, filename)
+                        checkpoint_path = os.path.splitext(pickle_path)[0] + ".pth"
+                        if os.path.isfile(checkpoint_path):
+                            paired_models.append((os.path.getmtime(pickle_path), pickle_path, checkpoint_path))
+
+            if not paired_models:
+                raise FileNotFoundError(
+                    "Не найдены пары файлов моделей (.pickle/.pth) в папке models/."
+                )
+
+            paired_models.sort(key=lambda item: item[0])
+            _, model_path, checkpoint_path = paired_models[-1]
         else:
             model_path = self.model_path
-            checkpoint_path = model_path[:-len("pickle")] + "pth"
+            checkpoint_path = os.path.splitext(model_path)[0] + ".pth"
+            if not os.path.isfile(model_path):
+                raise FileNotFoundError(f"Не найден файл модели: {model_path}")
+            if not os.path.isfile(checkpoint_path):
+                raise FileNotFoundError(
+                    f"Не найден checkpoint для модели: {checkpoint_path}. "
+                    "Проверьте, что рядом есть .pth файл."
+                )
+
+        self._io.log(f"[MODEL] pickle={model_path}")
+        self._io.log(f"[MODEL] checkpoint={checkpoint_path}")
 
         with open(model_path, "rb") as handle:
             env, model, enemy = pickle.load(handle)
 
         checkpoint = torch.load(checkpoint_path)
         return env, model, enemy, checkpoint
 
     def _run_game_loop(self):
         os.environ["STATE_JSON_PATH"] = self.state_path
         if "MANUAL_DICE" not in os.environ:
             os.environ["MANUAL_DICE"] = "1"
         if "VERBOSE_LOGS" not in os.environ and os.environ.get("MANUAL_DICE") == "1":
             os.environ["VERBOSE_LOGS"] = "1"
         set_active_io(self._io)
 
         try:
             env, model, enemy, checkpoint = self._load_game()
 
             env.io = self._io
             env.playType = True
 
             device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
 
             attacker_side, defender_side = roll_off_attacker_defender(
                 manual_roll_allowed=True,
@@ -129,52 +140,63 @@ class GameController:
                 )
             )
 
             from gym_mod.engine.deployment import deploy_only_war, post_deploy_setup
 
             deploy_only_war(
                 model_units=model,
                 enemy_units=enemy,
                 b_len=env.unwrapped.b_len,
                 b_hei=env.unwrapped.b_hei,
                 attacker_side=attacker_side,
                 log_fn=self._io.log,
             )
             post_deploy_setup(log_fn=self._io.log)
 
             env.attacker_side = attacker_side
             env.defender_side = defender_side
 
             state, info = env.reset(m=model, e=enemy, playType=True, Type="big", trunc=True)
 
             n_actions = [5, 2, len(info["player health"]), len(info["player health"]), 5, len(info["model health"])]
             for _ in range(len(model)):
                 n_actions.append(12)
             n_observations = len(state)
 
-            policy_net = DQN(n_observations, n_actions).to(device)
-            target_net = DQN(n_observations, n_actions).to(device)
+            net_type = checkpoint.get("net_type") if isinstance(checkpoint, dict) else None
+            dueling = net_type == "dueling"
+            if not dueling and isinstance(checkpoint, dict):
+                policy_state = checkpoint.get("policy_net", {})
+                if any(key.startswith("advantage_heads.") for key in policy_state.keys()):
+                    dueling = True
+
+            net_label = "dueling" if dueling else "basic"
+            net_source = "net_type" if net_type else "state_dict"
+            self._io.log(f"[MODEL] Архитектура сети: {net_label} (источник: {net_source})")
+
+            policy_net = DQN(n_observations, n_actions, dueling=dueling).to(device)
+            target_net = DQN(n_observations, n_actions, dueling=dueling).to(device)
             optimizer = torch.optim.Adam(policy_net.parameters())
 
             policy_net.load_state_dict(checkpoint["policy_net"])
             target_net.load_state_dict(checkpoint["target_net"])
             optimizer.load_state_dict(checkpoint["optimizer"])
 
             policy_net.eval()
             target_net.eval()
 
             self._io.log(
                 "\nИнструкции:\nИгрок управляет юнитами, начинающимися с 1 (т.е. 11, 12 и т.д.).\n"
                 "Модель управляет юнитами, начинающимися с 2 (т.е. 21, 22 и т.д.).\n"
             )
 
             is_done = False
             i = 0
             reward = 0
 
             while not is_done:
                 done, info = env.unwrapped.player()
                 env.updateBoard()
                 state_tensor = torch.tensor(state, dtype=torch.float32, device=device).unsqueeze(0)
                 shoot_mask = build_shoot_action_mask(env)
                 action = select_action(env, state_tensor, i, policy_net, len(model), shoot_mask=shoot_mask)
                 action_dict = convertToDict(action)

