diff --git a/gui/RosterModel.cpp b/gui/RosterModel.cpp
index d6cc78caf2a6acc4445e766830a25e3872171b9f..78b886ae624ded3340e21f66083e3af943fc8b79 100644
--- a/gui/RosterModel.cpp
+++ b/gui/RosterModel.cpp
@@ -1,79 +1,85 @@
 #include "include/RosterModel.h"
 
 #include <algorithm>
 #include <fstream>
+#include <iostream>
 
 void RosterModel::setFaction(const std::string& faction) {
   rosterFaction = faction;
 }
 
 const std::string& RosterModel::faction() const {
   return rosterFaction;
 }
 
 const std::vector<RosterEntry>& RosterModel::units() const {
   return rosterUnits;
 }
 
 bool RosterModel::empty() const {
   return rosterUnits.empty();
 }
 
 void RosterModel::addUnit(const std::string& name, int countDefault, const std::string& faction) {
   if (!faction.empty()) {
     rosterFaction = faction;
   }
 
   int countToAdd = countDefault > 0 ? countDefault : 1;
   auto it = std::find_if(rosterUnits.begin(), rosterUnits.end(),
                          [&](const RosterEntry& entry) { return entry.name == name; });
   if (it != rosterUnits.end()) {
     it->count += countToAdd;
     return;
   }
 
   rosterUnits.push_back({name, countToAdd});
 }
 
 void RosterModel::removeUnit(size_t index) {
   if (index >= rosterUnits.size()) {
     return;
   }
   rosterUnits.erase(rosterUnits.begin() + static_cast<long>(index));
 }
 
 void RosterModel::clear() {
   rosterUnits.clear();
 }
 
 std::vector<std::string> RosterModel::expandedUnits() const {
   std::vector<std::string> expanded;
   for (const auto& entry : rosterUnits) {
-    for (int i = 0; i < entry.count; ++i) {
-      expanded.push_back(entry.name);
+    constexpr int kMaxUnitsPerEntry = 10;
+    if (entry.count > kMaxUnitsPerEntry) {
+      std::cerr << "[RosterModel] Warning: entry '" << entry.name
+                << "' count=" << entry.count
+                << " looks like a model count; limiting to a single unit."
+                << std::endl;
     }
+    expanded.push_back(entry.name);
   }
   return expanded;
 }
 
 nlohmann::json RosterModel::toJson() const {
   nlohmann::json j;
   j["faction"] = rosterFaction;
   j["units"] = nlohmann::json::array();
   for (const auto& entry : rosterUnits) {
     j["units"].push_back({{"name", entry.name}, {"count", entry.count}});
   }
   return j;
 }
 
 bool RosterModel::fromJson(const nlohmann::json& data) {
   if (!data.is_object()) {
     return false;
   }
   std::string loadedFaction;
   if (data.contains("faction") && data.at("faction").is_string()) {
     loadedFaction = data.at("faction").get<std::string>();
   }
 
   std::vector<RosterEntry> loadedUnits;
   if (data.contains("units") && data.at("units").is_array()) {
diff --git a/play.py b/play.py
index f9e51ef51e25262ed3edb7094315341c08b1f1fe..3c214f97f287b467db2c3bd6abb4114b406c3799 100644
--- a/play.py
+++ b/play.py
@@ -67,50 +67,66 @@ def _log(msg: str):
 
 verbose = os.getenv("VERBOSE_LOGS", "0") == "1"
 log_fn = _log if verbose else None
 
 attacker_side, defender_side = roll_off_attacker_defender(
     manual_roll_allowed=(playInGUI is False),
     log_fn=_log,
 )
 if verbose:
     _log(f"[MISSION Only War] Attacker={attacker_side}, Defender={defender_side}")
 
 deploy_only_war(
     model_units=model,
     enemy_units=enemy,
     b_len=env.b_len,
     b_hei=env.b_hei,
     attacker_side=attacker_side,
     log_fn=log_fn,
 )
 post_deploy_setup(log_fn=log_fn)
 
 env.attacker_side = attacker_side
 env.defender_side = defender_side
 
 state, info = env.reset(m=model, e=enemy)
+if verbose:
+    squads_for_actions_count = len(model)
+    _log(f"[action_space] squads_for_actions_count={squads_for_actions_count}")
+    for idx, unit in enumerate(model):
+        unit_data = unit.showUnitData()
+        unit_name = unit_data.get("Name", "Unknown")
+        _log(f"[action_space] squad[{idx}] name={unit_name}")
+    total_models_count = 0
+    for unit in model:
+        unit_data = unit.showUnitData()
+        total_models_count += int(unit_data.get("#OfModels", 1))
+    _log(f"[action_space] total_models_count={total_models_count}")
+    move_num_keys = [
+        key for key in env.action_space.spaces.keys() if key.startswith("move_num_")
+    ]
+    _log(f"[action_space] move_num_keys_count={len(move_num_keys)}")
 n_actions = [5,2,len(info["player health"]), len(info["player health"]), 5, len(info["model health"])]
 for i in range(len(model)):
     n_actions.append(12)
 n_observations = len(state)
 
 policy_net = DQN(n_observations, n_actions).to(device)
 target_net = DQN(n_observations, n_actions).to(device)
 optimizer = torch.optim.Adam(policy_net.parameters())
 
 policy_net.load_state_dict(checkpoint['policy_net'])
 target_net.load_state_dict(checkpoint['target_net'])
 optimizer.load_state_dict(checkpoint['optimizer'])
 
 policy_net.eval()
 target_net.eval()
 
 isdone = False
 i = 0
 
 if playInGUI == True:
     env.reset(m=model, e=enemy, playType = playInGUI, Type="big", trunc=True)
 else:
     env.reset(m=model, e=enemy, playType = playInGUI, Type="big", trunc=False)
 
 reward = 0
diff --git a/train.py b/train.py
index 20f02de3ea4c327afff102fb0c9f719f039bc904..b661ece0279cc9aa0afac7ef91d0be92ed8bdb44 100644
--- a/train.py
+++ b/train.py
@@ -195,50 +195,66 @@ post_deploy_setup(log_fn=log_fn)
 env = gym.make("40kAI-v0", disable_env_checker=True, enemy = enemy, model = model, b_len = b_len, b_hei = b_hei)
 env.attacker_side = attacker_side
 env.defender_side = defender_side
 
 ordered_keys = ["move", "attack", "shoot", "charge", "use_cp", "cp_on"]
 for i_u in range(len(model)):
     ordered_keys.append(f"move_num_{i_u}")
 
 n_actions = []
 for k in ordered_keys:
     sp = env.action_space.spaces[k]
 
     # Discrete (и gym, и gymnasium)
     if hasattr(sp, "n"):
         n_actions.append(int(sp.n))
 
     # MultiDiscrete (на всякий)
     elif hasattr(sp, "nvec"):
         n_actions.extend([int(x) for x in sp.nvec])
 
     else:
         raise TypeError(f"Unsupported action space for {k}: {type(sp)}")
 
 
 state, info = env.reset(m=model, e=enemy, trunc=True)
+if verbose:
+    squads_for_actions_count = len(model)
+    print(f"[action_space] squads_for_actions_count={squads_for_actions_count}")
+    for idx, unit in enumerate(model):
+        unit_data = unit.showUnitData()
+        unit_name = unit_data.get("Name", "Unknown")
+        print(f"[action_space] squad[{idx}] name={unit_name}")
+    total_models_count = 0
+    for unit in model:
+        unit_data = unit.showUnitData()
+        total_models_count += int(unit_data.get("#OfModels", 1))
+    print(f"[action_space] total_models_count={total_models_count}")
+    move_num_keys = [
+        key for key in env.action_space.spaces.keys() if key.startswith("move_num_")
+    ]
+    print(f"[action_space] move_num_keys_count={len(move_num_keys)}")
 
 # state может быть np.array или OrderedDict
 if isinstance(state, dict) or "OrderedDict" in str(type(state)):
     n_observations = len(list(state.values()))
 else:
     n_observations = int(np.array(state).shape[0])
 
 
 policy_net = DQN(n_observations, n_actions).to(device)
 target_net = DQN(n_observations, n_actions).to(device)
 target_net.load_state_dict(policy_net.state_dict())
 target_net.eval()
 
 
 optimizer = optim.AdamW(policy_net.parameters(), lr=LR, amsgrad=True)
 memory = ReplayMemory(10000)
 
 inText = []
 
 inText.append("Model units:")
 for i in model:
     inText.append("Name: {}, Army Type: {}".format(i.showUnitData()["Name"], i.showUnitData()["Army"]))
 inText.append("Enemy units:")
 for i in enemy:
     inText.append("Name: {}, Army Type: {}".format(i.showUnitData()["Name"], i.showUnitData()["Army"]))

