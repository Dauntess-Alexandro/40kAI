diff --git a/gui/warn.cpp b/gui/warn.cpp
index 0df5c5a2a7679ccb22e5dcdcc95a4b82a69546d1..8d878b97d2bc292cd6bd35fe511958c9aebc8af9 100644
--- a/gui/warn.cpp
+++ b/gui/warn.cpp
@@ -1,46 +1,120 @@
 #include <iostream>
 #include <gtkmm.h>
 #include <cstdlib>
 #include <stdlib.h>
 #include <string>
+#include <filesystem>
+#include <fstream>
+#include <sstream>
 #include "include/warn.h"
 
 using namespace Glib;
 using namespace Gtk;
+namespace fs = std::filesystem;
+
+namespace {
+fs::path resolveSourceDir() {
+    fs::path source = fs::path(__FILE__);
+    std::error_code ec;
+    if (!source.is_absolute()) {
+        source = fs::absolute(source, ec);
+    }
+    if (ec || source.empty()) {
+        return fs::current_path();
+    }
+    return source.parent_path();
+}
+
+fs::path findProjectRoot() {
+    fs::path current = resolveSourceDir();
+    fs::path last = current;
+    std::error_code ec;
+    while (!current.empty()) {
+        if (fs::exists(current / "LOGS_FOR_AGENTS.md", ec) || fs::exists(current / ".git", ec)) {
+            return current;
+        }
+        if (current == current.root_path()) {
+            break;
+        }
+        last = current;
+        current = current.parent_path();
+    }
+    return last;
+}
+
+bool truncateAgentLogs(std::string* error_message, fs::path* log_path_out) {
+    fs::path root = findProjectRoot();
+    fs::path log_path = root / "LOGS_FOR_AGENTS.md";
+    if (log_path_out) {
+        *log_path_out = log_path;
+    }
+    std::ofstream log_file(log_path, std::ios::out | std::ios::trunc);
+    if (!log_file) {
+        if (error_message) {
+            std::ostringstream message;
+            message << "Не удалось очистить LOGS_FOR_AGENTS.md по пути: " << log_path.string()
+                    << ". Проверьте права доступа или занятость файла и повторите.";
+            *error_message = message.str();
+        }
+        return false;
+    }
+    return true;
+}
+}  // namespace
 
 Warn :: Warn(std::string message, int comm) {
     bar.set_show_close_button(true);
     set_titlebar(bar);
 
     add(scrolledWindow);
     scrolledWindow.add(fixed);
 
     text.set_text(message);
     cancel.set_label("Cancel");
     cancel.signal_button_release_event().connect([&](GdkEventButton*) {
         this->hide();
         return true;
     });
     cont.set_label("Continue");
     cont.signal_button_release_event().connect([&](GdkEventButton*) {
         if (comm == 0) {
             system("cd .. ; rm -r models/*");
             system("cd .. ; rm -r metrics/*");
             system("cd .. ; find gui/img/ -type f ! -name 'epLen.png' ! -name 'reward.png' ! -name 'loss.png' ! -name 'icon.png' -delete");
+            std::string error_message;
+            fs::path log_path;
+            bool cleared = truncateAgentLogs(&error_message, &log_path);
+            if (cleared) {
+                Gtk::MessageDialog dialog(*this,
+                                          "Кэш моделей и LOGS_FOR_AGENTS.md очищены.",
+                                          false,
+                                          Gtk::MESSAGE_INFO,
+                                          Gtk::BUTTONS_OK,
+                                          true);
+                dialog.run();
+            } else {
+                Gtk::MessageDialog dialog(*this,
+                                          error_message,
+                                          false,
+                                          Gtk::MESSAGE_ERROR,
+                                          Gtk::BUTTONS_OK,
+                                          true);
+                dialog.run();
+            }
 		}
         this->hide();
         return true;
     });
 
     fixed.add(text);
     fixed.move(text, 10, 10);
     fixed.add(cancel);
     fixed.move(cancel, 10, 40);
     fixed.add(cont);
     fixed.move(cont, 320, 40);
 
     bar.set_title("Warning Message");
 
     resize(400,200);
     show_all();
 }

