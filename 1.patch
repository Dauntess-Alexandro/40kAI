diff --git a/gym_mod/gym_mod/envs/warhamEnv.py b/gym_mod/gym_mod/envs/warhamEnv.py
index 477ccc0949dd95767c042b259c2af746c152ca20..e230ccbeaf375ae9573a9a12be6fc06fb42111bb 100644
--- a/gym_mod/gym_mod/envs/warhamEnv.py
+++ b/gym_mod/gym_mod/envs/warhamEnv.py
@@ -1277,132 +1277,146 @@ class Warhammer40kEnv(gym.Env):
         self._log(f"=== КОНЕЦ БОЕВОГО РАУНДА {self.battle_round} ===")
         self.battle_round += 1
         self.numTurns = self.battle_round
         self._round_banner_shown = False
         apply_end_of_battle(self, log_fn=self._log)
 
     def _advance_turn_order(self):
         if self.active_side == self.turn_order[-1]:
             self._end_battle_round()
             self.active_side = self.turn_order[0]
         else:
             current_index = self.turn_order.index(self.active_side)
             self.active_side = self.turn_order[current_index + 1]
         self.phase = "command"
 
     def command_phase(self, side: str, action=None, manual: bool = False):
         self.begin_phase(side, "command")
         if side == "model":
             self._log_phase("MODEL", "command")
             self.modelCP += 1
             self.enemyCP += 1
             reward_delta = 0
             battle_shock = [False] * len(self.unit_health)
             for i in range(len(self.unit_health)):
                 unit_label = self._format_unit_label("model", i)
+                if self.unit_health[i] <= 0:
+                    self.modelOC[i] = 0
+                    continue
+                self.modelOC[i] = self.unit_data[i]["OC"]
                 if isBelowHalfStr(self.unit_data[i], self.unit_health[i]) is True and self.unit_health[i] > 0:
                     if self.trunc is False:
                         self._log(f"{unit_label}: ниже половины состава, тест Battle-shock.")
                         self._log("Бросок 2D6...", verbose_only=True)
                     diceRoll = dice(num=2)
                     if self.trunc is False:
                         self._log(f"Бросок: {diceRoll[0]} {diceRoll[1]}", verbose_only=True)
                     if sum(diceRoll) >= self.unit_data[i]["Ld"]:
                         self.modelOC[i] = self.unit_data[i]["OC"]
                         if self.trunc is False:
                             self._log(f"{unit_label}: тест Battle-shock пройден.")
                     else:
                         battle_shock[i] = True
                         self.modelOC[i] = 0
                         if self.trunc is False:
                             self._log(f"{unit_label}: тест Battle-shock провален.")
                         if action and action.get("use_cp") == 1 and action.get("cp_on") == i:
                             if self.modelCP - 1 >= 0:
                                 battle_shock[i] = False
                                 reward_delta += 0.5
                                 self.modelCP -= 1
                                 if self.trunc is False:
                                     self._log(f"{unit_label}: применена Insane Bravery (-1 CP), тест пройден.")
                             else:
                                 reward_delta -= 0.5
             dice_fn = player_dice if os.getenv("MANUAL_DICE", "0") == "1" and side == "enemy" else auto_dice
             apply_end_of_command_phase(self, side="model", dice_fn=dice_fn, log_fn=self._log)
             score_end_of_command_phase(self, "model", log_fn=self._log)
             return battle_shock, reward_delta
 
         if side == "enemy" and manual:
             self.enemyCP += 1
             self.modelCP += 1
             battle_shock = [False] * len(self.enemy_health)
             for i in range(len(self.enemy_health)):
                 playerName = i + 11
                 battleSh = False
                 unit_label = self._format_unit_label("enemy", i, unit_id=playerName)
-                if isBelowHalfStr(self.enemy_data[i], self.enemy_health[i]) is True and self.unit_health[i] > 0:
+                if self.enemy_health[i] <= 0:
+                    self.enemyOC[i] = 0
+                    battle_shock[i] = False
+                    continue
+                self.enemyOC[i] = self.enemy_data[i]["OC"]
+                if isBelowHalfStr(self.enemy_data[i], self.enemy_health[i]) is True and self.enemy_health[i] > 0:
                     self._log(f"{unit_label}: ниже половины состава, тест Battle-shock.")
                     self._log("Бросок 2D6...", verbose_only=True)
                     diceRoll = player_dice(num=2)
                     self._log(f"Бросок: {diceRoll[0]} {diceRoll[1]}", verbose_only=True)
                     if sum(diceRoll) >= self.enemy_data[i]["Ld"]:
                         self._log(f"{unit_label}: тест Battle-shock пройден.")
                         self.enemyOC[i] = self.enemy_data[i]["OC"]
                     else:
                         battleSh = True
                         self._log(f"{unit_label}: тест Battle-shock провален.")
                         self.enemyOC[i] = 0
                         if self.enemyCP - 1 >= 0:
                             strat = self._prompt_yes_no(
                                 f"{unit_label}. Использовать стратагему Insane Bravery (1 CP)? (y/n): "
                             )
                             if strat is None:
                                 self.game_over = True
                                 return None
                             if strat:
                                 battleSh = False
                                 self.enemyCP -= 1
                                 self.enemyOC[i] = self.enemy_data[i]["OC"]
                 battle_shock[i] = battleSh
                 if battleSh:
                     continue
             self._manual_enemy_battle_shock = battle_shock
             dice_fn = player_dice if os.getenv("MANUAL_DICE", "0") == "1" and side == "enemy" else auto_dice
             apply_end_of_command_phase(self, side="enemy", dice_fn=dice_fn, log_fn=self._log)
             score_end_of_command_phase(self, "enemy", log_fn=self._log)
             return battle_shock
 
         if side == "enemy":
             self.enemyCP += 1
             self.modelCP += 1
             battle_shock = [False] * len(self.enemy_health)
             cp_on = np.random.randint(0, len(self.enemy_health))
             use_cp = np.random.randint(0, 5)
             self._enemy_cp_on = cp_on
             self._enemy_use_cp = use_cp
             for i in range(len(self.enemy_health)):
                 battleSh = False
                 unit_label = self._format_unit_label("enemy", i)
-                if isBelowHalfStr(self.enemy_data[i], self.enemy_health[i]) is True and self.unit_health[i] > 0:
+                if self.enemy_health[i] <= 0:
+                    self.enemyOC[i] = 0
+                    battle_shock[i] = False
+                    continue
+                self.enemyOC[i] = self.enemy_data[i]["OC"]
+                if isBelowHalfStr(self.enemy_data[i], self.enemy_health[i]) is True and self.enemy_health[i] > 0:
                     if self.trunc is False:
                         self._log(f"{unit_label}: ниже половины состава, тест Battle-shock.")
                         self._log("Бросок 2D6...", verbose_only=True)
                     diceRoll = dice(num=2)
                     if self.trunc is False:
                         self._log(f"Бросок: {diceRoll[0]} {diceRoll[1]}", verbose_only=True)
                     if sum(diceRoll) >= self.enemy_data[i]["Ld"]:
                         if self.trunc is False:
                             self._log(f"{unit_label}: тест Battle-shock пройден.")
                         self.enemyOC[i] = self.enemy_data[i]["OC"]
                     else:
                         battleSh = True
                         self.enemyOC[i] = 0
                         if self.trunc is False:
                             self._log(f"{unit_label}: тест Battle-shock провален.")
                         if use_cp == 1 and cp_on == i and self.enemyCP - 1 >= 0:
                             battleSh = False
                             self.enemyCP -= 1
                             self.enemyOC[i] = self.enemy_data[i]["OC"]
 
                 battle_shock[i] = battleSh
             dice_fn = player_dice if os.getenv("MANUAL_DICE", "0") == "1" and side == "enemy" else auto_dice
             apply_end_of_command_phase(self, side="enemy", dice_fn=dice_fn, log_fn=self._log)
             score_end_of_command_phase(self, "enemy", log_fn=self._log)
             return battle_shock
@@ -1543,53 +1557,58 @@ class Warhammer40kEnv(gym.Env):
             return advanced_flags, reward_delta
 
         if side == "enemy" and manual:
             direction_map = {"up": "up", "down": "down", "left": "left", "right": "right", "none": "none"}
             normalize = {"u": "up", "d": "down", "l": "left", "r": "right", "n": "none"}
             advanced_flags = [False] * len(self.enemy_health)
             for i in range(len(self.enemy_health)):
                 playerName = i + 11
                 battleSh = battle_shock[i] if battle_shock else False
                 unit_label = self._format_unit_label("enemy", i, unit_id=playerName)
                 pos_before = tuple(self.enemy_coords[i])
                 if self.enemyInAttack[i][0] == 1 and self.enemy_health[i] > 0:
                     fall_back = self._prompt_yes_no(f"{unit_label}. Отступить (fallback)? (y/n): ")
                     if fall_back is None:
                         self.game_over = True
                         return None
                     if fall_back:
                         idOfE = self.enemyInAttack[i][1]
                         self._log(f"{unit_label} отступил из боя с {self._format_unit_label('model', idOfE)}")
                         self.enemyFellBack[i] = True
                         if battleSh is True:
                             diceRoll = dice()
                             if diceRoll < 3:
                                 self.enemy_health[i] -= self.enemy_data[i]["W"]
                         self.enemy_coords[i][0] += self.enemy_data[i]["Movement"]
+                        self.enemy_coords[i] = bounds(self.enemy_coords[i], self.b_len, self.b_hei)
                         self.enemyInAttack[i] = [0, 0]
                         self.unitInAttack[idOfE][0] = 0
                         self.unitInAttack[idOfE][1] = 0
+                        pos_after = tuple(self.enemy_coords[i])
+                        self._log(f"{unit_label}: отступление завершено. Позиция после: {pos_after}")
+                        self.updateBoard()
+                        self.showBoard()
                     else:
                         idOfE = self.enemyInAttack[i][1]
                         self._log(
                             f"{unit_label} остаётся в бою с {self._format_unit_label('model', idOfE)} (будет драться в фазе боя)."
                         )
                     continue
 
                 if self.enemyInAttack[i][0] == 0 and self.enemy_health[i] > 0:
                     self.enemy_coords[i] = bounds(self.enemy_coords[i], self.b_len, self.b_hei)
                     for j in range(len(self.enemy_health)):
                         if self.enemy_coords[i] == self.unit_coords[j]:
                             self.enemy_coords[i][0] -= 1
 
                     self.updateBoard()
                     self.showBoard()
 
                     dire = self._prompt_choice(
                         f"Ход юнита: {unit_label}. Выберите направление (up/down/left/right/none): ",
                         direction_map,
                         normalize,
                     )
                     if dire is None:
                         self.game_over = True
                         return None
 

