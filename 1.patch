diff --git a/gui/Application.cpp b/gui/Application.cpp
index 1947b3271bc41dfc0141a69154a32316fe68ac09..6470d78611a09f3526be8bb9635adc55ba4e0a5b 100644
--- a/gui/Application.cpp
+++ b/gui/Application.cpp
@@ -191,105 +191,108 @@ std::string buildTrainingStatsLine(double itPerSec,
                                    bool showEta,
                                    std::chrono::seconds eta) {
   std::ostringstream oss;
   if (itPerSec > 0.0) {
     oss << std::fixed << std::setprecision(1) << itPerSec << " it/s";
   } else {
     oss << "— it/s";
   }
   oss << " • elapsed " << formatDuration(elapsed);
   if (showEta) {
     oss << " • ETA " << formatDuration(eta);
   }
   return oss.str();
 }
 }  // namespace
 
 std::string rewpth = "img/reward.png";
 std::string losspth = "img/loss.png";
 std::string eplenpth = "img/epLen.png";
 std::string winratepth = "img/winrate.png";
 std::string vpdiffpth = "img/vpdiff.png";
 std::string endreasonpth = "img/endreasons.png";
 std::string imgpth = "img/icon.png";
 
 namespace {
-constexpr bool kEnableDarkTheme = false;
 constexpr auto kDarkThemePath = "style-dark.css";
 }  // namespace
 
 Form :: Form() {
 
   modelClass = " Necrons";
   enemyClass = " Necrons";
   path = " ";
   open = false;
   x = 60;
   y = 40;
   training = false;
   playing = false;
   loadingRoster = false;
   hideTrainingLogs = true;
   trainingTotalEpisodes = 0;
   trainEnvPrefix = "";
   trainingStartLabel = "обучения";
   trainingStatusLabel = "Обучение";
   trainingLogTag = "TRAIN";
   evaluating = false;
 
   bar.set_show_close_button(true);
   bar.set_title("40kAI GUI");
   set_titlebar(bar);
 
   set_default_size(kDefaultWidth, kDefaultHeight);
   set_size_request(kMinimumWidth, kMinimumHeight);
 
-  if (kEnableDarkTheme) {
+  auto settings = Gtk::Settings::get_default();
+  if (settings) {
+    settings->property_gtk_application_prefer_dark_theme() = true;
+  }
+
+  const char* enableCustomCss = std::getenv("GUI_CUSTOM_CSS");
+  const bool useCustomCss = enableCustomCss && std::string(enableCustomCss) == "1";
+  if (useCustomCss) {
     cssProvider = Gtk::CssProvider::create();
     try {
       cssProvider->load_from_path(kDarkThemePath);
       Gtk::StyleContext::add_provider_for_screen(
           Gdk::Screen::get_default(), cssProvider,
           GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
     } catch (const Glib::Error& error) {
       std::cerr << "Не удалось загрузить тему: " << error.what() << std::endl;
     }
   }
 
   rootBox.set_orientation(Gtk::ORIENTATION_VERTICAL);
   topBarBox.set_orientation(Gtk::ORIENTATION_HORIZONTAL);
   topBarBox.set_spacing(8);
   leftBox.set_orientation(Gtk::ORIENTATION_VERTICAL);
 
   rootBox.set_hexpand(true);
   rootBox.set_vexpand(true);
   topBarBox.set_hexpand(true);
   leftBox.set_hexpand(true);
   leftBox.set_vexpand(true);
-  rootBox.get_style_context()->add_class("app-root");
-  tabControl1.get_style_context()->add_class("panel");
-  logView.get_style_context()->add_class("mono");
 
   help.set_image_from_icon_name("help-about");
   help.signal_button_release_event().connect([&](GdkEventButton*){
     openHelpMenu();
     return true;
   });
   resetLayoutButton.set_label("Reset Layout");
   resetLayoutButton.signal_button_release_event().connect([&](GdkEventButton*) {
     resetLayout();
     return true;
   });
   topBarBox.pack_start(resetLayoutButton, Gtk::PACK_SHRINK);
   topBarBox.pack_start(help, Gtk::PACK_SHRINK);
 
   add(rootBox);
   rootBox.pack_start(topBarBox, Gtk::PACK_SHRINK);
   rootBox.pack_start(leftBox, Gtk::PACK_EXPAND_WIDGET);
 
   tabControl1.set_hexpand(true);
   tabControl1.set_vexpand(true);
   leftBox.pack_start(tabControl1, Gtk::PACK_EXPAND_WIDGET);
 
   logView.set_hexpand(true);
   logView.set_vexpand(true);
   logView.set_editable(false);
@@ -390,51 +393,50 @@ Form :: Form() {
 
   evalLogScroll.set_hexpand(true);
   evalLogScroll.set_vexpand(true);
   evalLogScroll.set_policy(PolicyType::POLICY_AUTOMATIC, PolicyType::POLICY_AUTOMATIC);
   evalLogScroll.set_size_request(900, 600);
   evalLogScroll.add(evalLogView);
   fixedTabPage6.add(evalLogScroll);
   fixedTabPage6.move(evalLogScroll, 10, 90);
 
     // train tab
 
   savetoTxt(enemyUnits, modelUnits);
 
   labelPage2.set_label("Train");
   tabControl1.set_tab_label(tabPage2, labelPage2);
   tabPage2.add(trainGrid);
 
   trainGrid.set_margin_top(12);
   trainGrid.set_margin_bottom(12);
   trainGrid.set_margin_start(12);
   trainGrid.set_margin_end(12);
   trainGrid.set_row_spacing(8);
   trainGrid.set_column_spacing(12);
   trainGrid.set_hexpand(true);
   trainGrid.set_vexpand(true);
-  trainGrid.get_style_context()->add_class("panel");
 
   textbox1.set_text("Train Model:");
   textbox1.set_halign(Gtk::ALIGN_START);
   setStatusMessage("Press the Train button to train a model");
   trainingProgressLabel.set_text("ep=0/0 (0%)");
   trainingProgressStatsLabel.set_text("— it/s • elapsed 00:00");
   trainingProgress.set_fraction(0.0);
   trainingProgress.set_show_text(true);
   trainingProgress.set_text("0%");
   trainingProgress.set_size_request(360, 24);
   trainingProgressStatsLabel.set_xalign(0.0);
   trainingProgressStatsLabel.set_size_request(520, -1);
   status.set_halign(Gtk::ALIGN_START);
   trainingProgressLabel.set_halign(Gtk::ALIGN_START);
   trainingProgress.set_hexpand(true);
   trainingProgressStatsLabel.set_halign(Gtk::ALIGN_START);
   trainingProgressStatsLabel.set_hexpand(true);
     
   button1.set_label("Train");
   button1.signal_button_release_event().connect([&](GdkEventButton*) {
     saveLastRoster();
     syncEnemyUnitsFromRoster();
     updateInits(modelClass, enemyClass);
     if (exists_test("data.json") && training == false) {
       training = true;
@@ -558,65 +560,63 @@ Form :: Form() {
       rosterModel.clear();
     }
     rosterModel.setFaction("Necrons");
     if (!loadingRoster) {
       syncEnemyUnitsFromRoster();
     }
   });
   necEnemy.set_active(true);
 
   enemyFact.set_text("Player Faction: ");
   modelFact.set_text("Model Faction: ");
   enemyFact.set_halign(Gtk::ALIGN_START);
   modelFact.set_halign(Gtk::ALIGN_START);
 
   trainSettingsGrid.set_row_spacing(6);
   trainSettingsGrid.set_column_spacing(8);
   trainSettingsGrid.set_hexpand(true);
   trainSettingsGrid.attach(numOfGames, 0, 0, 1, 1);
   trainSettingsGrid.attach(setIters, 1, 0, 1, 1);
   trainSettingsGrid.attach(modelFact, 0, 1, 1, 1);
   trainSettingsGrid.attach(necModel, 1, 1, 1, 1);
   trainSettingsGrid.attach(enemyFact, 0, 2, 1, 1);
   trainSettingsGrid.attach(necEnemy, 1, 2, 1, 1);
 
   rosterFrame.set_label("Ростер");
-  rosterFrame.get_style_context()->add_class("card");
   rosterFrame.set_hexpand(true);
   rosterFrame.set_vexpand(false);
   rosterGrid.set_margin_top(8);
   rosterGrid.set_margin_bottom(8);
   rosterGrid.set_margin_start(10);
   rosterGrid.set_margin_end(10);
   rosterGrid.set_row_spacing(6);
   rosterSummaryLabel.set_xalign(0.0);
   rosterGrid.attach(openArmyPopup, 0, 0, 1, 1);
   rosterGrid.attach(rosterSummaryLabel, 0, 1, 1, 1);
   rosterFrame.add(rosterGrid);
 
   boardFrame.set_label("Размеры поля");
-  boardFrame.get_style_context()->add_class("card");
   boardFrame.set_hexpand(true);
   boardGrid.set_margin_top(8);
   boardGrid.set_margin_bottom(8);
   boardGrid.set_margin_start(10);
   boardGrid.set_margin_end(10);
   boardGrid.set_row_spacing(6);
   boardGrid.set_column_spacing(8);
   boardGrid.attach(dimens, 0, 0, 4, 1);
   boardGrid.attach(dimX, 0, 1, 1, 1);
   boardGrid.attach(enterDimensX, 1, 1, 1, 1);
   boardGrid.attach(upX, 2, 1, 1, 1);
   boardGrid.attach(downX, 3, 1, 1, 1);
   boardGrid.attach(dimY, 0, 2, 1, 1);
   boardGrid.attach(enterDimensY, 1, 2, 1, 1);
   boardGrid.attach(upY, 2, 2, 1, 1);
   boardGrid.attach(downY, 3, 2, 1, 1);
   boardFrame.add(boardGrid);
 
   trainActionGrid.set_row_spacing(6);
   trainActionGrid.set_column_spacing(8);
   trainActionGrid.attach(button3, 0, 0, 1, 1);
   trainActionGrid.attach(buttonSelfPlay, 1, 0, 1, 1);
   trainActionGrid.attach(button1, 0, 1, 1, 1);
   trainActionGrid.attach(buttonTrain6, 1, 1, 1, 1);
 

